/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/index.mjs");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./src/aframe-audio-vis-component.mjs":
/*!********************************************!*\
  !*** ./src/aframe-audio-vis-component.mjs ***!
  \********************************************/
/*! no exports provided */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n// Copyright 2018-2019 harlyq\r\n// MIT license\r\n\r\nconst elementName = el => {\r\n  const classes = el.className.split(\" \")\r\n  return el.localName.toLowerCase() + (classes[0] ? \".\" + classes.join(\".\") : \"\") + \"#\" + el.id\r\n}\r\n\r\nAFRAME.registerSystem(\"audio-vis\", {\r\n  schema: {\r\n    src: {\r\n      type: \"selector\"\r\n    },\r\n    fftSize: {\r\n      default: 32,\r\n    },\r\n  },\r\n\r\n  init: function () {\r\n    this.context = new AudioContext()\r\n    this.analysers = {}\r\n  },\r\n\r\n  getOrCreateAnalyser: function() {\r\n    const srcEl = this.data.src\r\n    const srcName = elementName(srcEl)\r\n    if (this.analysers[srcName]) { return this.analysers[srcName]}\r\n\r\n    const fftSize = this.data.fftSize\r\n    let analyser = this.context.createAnalyser()\r\n    let source = this.context.createMediaElementSource(srcEl)\r\n    source.connect(analyser)\r\n    analyser.connect(this.context.destination)\r\n    analyser.fftSize = fftSize\r\n    analyser.fetchTime = -1\r\n    analyser.frequencyData = new Uint8Array(fftSize)\r\n\r\n    this.analysers[srcName] = analyser\r\n\r\n    return analyser\r\n  },\r\n\r\n  getByteFrequencyData: function(analyser, time) {\r\n    if (time !== analyser.fetchTime) {\r\n      analyser.getByteFrequencyData(analyser.frequencyData)\r\n      analyser.fetchTime = time\r\n    }\r\n    return analyser.frequencyData\r\n  }\r\n})\r\n\r\n// 1 2 3..4 5 6 => [[1,2,3], [4,5,6]]\r\nconst toNumber = a => Number(a)\r\nconst parseCoords = a => a.trim().split(\" \").map(toNumber)\r\nconst isRange = a => a.includes(\"..\")\r\nconst parseRangeCoords = a => a.split(\"..\").map(parseCoords)\r\nconst lerpRange = (range, t) => {\r\n  if (range.length < 1) { return range[0] }\r\n\r\n  let out = []\r\n  const a = range[0]\r\n  const b = range[1]\r\n\r\n  for (let i = 0, n = Math.max(a.length, b.length); i < n; i++) {\r\n    out[i] = THREE.Math.lerp(a[i] || 0, b[i] || 0, t)\r\n  }\r\n\r\n  return out\r\n}\r\n\r\n// const attributeToKebabCase = function(a) {\r\n//   const parts = a.split(\".\")\r\n//   if (parts.length <= 1) { return a }\r\n//   return parts[0] + \".\" + parts[1].replace(/([A-Z])/g, \"-$1\")\r\n// }\r\n\r\nconst isObjectEmpty = x => {\r\n  for (let k in x) {\r\n    if (x.hasOwnProperty(k)) {\r\n      return false\r\n    }\r\n  }\r\n  return true\r\n}\r\n\r\nconst audioVisSchema = {\r\n  bins: {\r\n    type: \"array\", \r\n    default: [0],\r\n    parse: str => typeof str === \"string\" ? str.split(\",\").map(toNumber) : str\r\n  },\r\n  threshold: {\r\n    default: 0,\r\n    min: 0,\r\n    max: 1,\r\n  }\r\n}\r\n\r\nAFRAME.registerComponent(\"audio-vis\", {\r\n  schema: audioVisSchema,\r\n  multiple: true,\r\n\r\n  init: function () {\r\n    this.ranges = {}\r\n    this.analyser = this.system.getOrCreateAnalyser()\r\n  },\r\n\r\n  updateSchema: function (data) {\r\n    let newRules = {}\r\n\r\n    for (let key in data) {\r\n      if (!(key in this.schema)) {\r\n        newRules[key] = { type: \"string\", }\r\n      }\r\n    }\r\n\r\n    if (!isObjectEmpty(newRules)) { \r\n      this.extendSchema(newRules) \r\n    }\r\n  },\r\n\r\n  update: function (oldData) {\r\n    const data = this.data\r\n    for (let key in data) {\r\n      if (!(key in audioVisSchema) && isRange(data[key])) {\r\n        this.ranges[key] = parseRangeCoords(data[key])\r\n      }\r\n    }\r\n  },\r\n\r\n  tick: function (time, deltaTime) {\r\n    const data = this.data\r\n    const frequencyData = this.system.getByteFrequencyData(this.analyser, time)\r\n\r\n    const bins = data.bins\r\n    const n = bins.length\r\n    let total = 0\r\n    for (let bin of bins) {\r\n      total += frequencyData[bin]\r\n    }\r\n\r\n    let avg = total/n/255 // avg is in range range (0,1)\r\n    let filteredAvg = avg > data.threshold ? avg : 0\r\n    let el = this.el\r\n\r\n    for (let key in this.ranges) {\r\n      const value = lerpRange(this.ranges[key], filteredAvg)\r\n      switch (key) {\r\n        case \"position\":\r\n        case \"scale\":\r\n          el.object3D[key].set(...value)\r\n          break\r\n        case \"rotation\":\r\n          el.object3D[key].set(...(value.map(THREE.Math.degToRad)))\r\n          break;\r\n        default:\r\n          el.setAttribute(key, value.map(x => x.toFixed(4)).join(\" \"))\r\n      }\r\n    }\r\n  },\r\n})\r\n\n\n//# sourceURL=webpack:///./src/aframe-audio-vis-component.mjs?");

/***/ }),

/***/ "./src/aframe-clone-entity-component.mjs":
/*!***********************************************!*\
  !*** ./src/aframe-clone-entity-component.mjs ***!
  \***********************************************/
/*! no exports provided */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n// Copyright 2018-2019 harlyq\n// MIT license\n\nlet cloneID = 0\n\nAFRAME.registerComponent(\"clone-entity\", {\n  schema: {\n    type: \"selector\",\n  },\n  multiple: true,\n\n  update() {\n    const idPostFix = \"_clone\"\n    const data = this.data\n    const template = data.template\n    let cloneEl = document.importNode(template instanceof HTMLTemplateElement ? template.content : template, true)\n\n    const makeUniqueIDs = el => {\n      if (el.id) el.id += idPostFix + cloneID\n      el.children.forEach(addUniqueIDs)\n    }\n    makeUniqueIDs(cloneEl)\n\n    this.el.appendChild(cloneEl)\n    cloneID++\n  }\n})\n\n\n//# sourceURL=webpack:///./src/aframe-clone-entity-component.mjs?");

/***/ }),

/***/ "./src/aframe-clone-geo-component.mjs":
/*!********************************************!*\
  !*** ./src/aframe-clone-geo-component.mjs ***!
  \********************************************/
/*! no exports provided */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n// Copyright 2018-2019 harlyq\n// MIT license\n\nAFRAME.registerComponent(\"clone-geo\", {\n  schema: {\n    type: \"selector\",\n  },\n\n  init() {\n    this.onObject3DSet = this.onObject3DSet.bind(this) // used for models which may have a delay before loading\n  },\n\n  // TODO does this handle models that need to load?\n  update(oldData) {\n    if (this.data !== oldData) {\n      if (oldData instanceof HTMLElement) { oldData.removeEventListener(\"object3dset\", this.onObject3DSet) }\n\n      const template = this.data\n      if (template instanceof HTMLElement && template.object3D) {\n        template.object3D.children.forEach(a => this.el.object3D.add(a.clone()))\n        this.el.object3DMap = template.object3DMap\n        template.addEventListener(\"object3dset\", this.onObject3DSet)\n      }\n    }\n  },\n\n  onObject3DSet(evt) {\n    const template = this.data\n    if (evt.target === template && evt.detail.type) {\n      this.el.setObject3D(evt.detail.type, template.getObject3D(evt.detail.type))\n    }\n  }\n})\n\n\n//# sourceURL=webpack:///./src/aframe-clone-geo-component.mjs?");

/***/ }),

/***/ "./src/aframe-keyframe-component.mjs":
/*!*******************************************!*\
  !*** ./src/aframe-keyframe-component.mjs ***!
  \*******************************************/
/*! no exports provided */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _aframe_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./aframe-utils */ \"./src/aframe-utils.mjs\");\n/* harmony import */ var _basic_random__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./basic-random */ \"./src/basic-random.mjs\");\n// Copyright 2018-2019 harlyq\n// MIT license\n\n// import {deepEqual} from \"./aframe-utils\"\n\n\nconst MAX_FRAME_TIME_MS = 100\n\n// easing functions copied from TWEEN.js\nconst Easing = {\n\tLinear: {\n\t\tNone: function (k) {\n\t\t\treturn k;\n\t\t}\n\t},\n\tQuadratic: {\n\t\tIn: function (k) {\n\t\t\treturn k * k;\n\t\t},\n\t\tOut: function (k) {\n\t\t\treturn k * (2 - k);\n\t\t},\n\t\tInOut: function (k) {\n\t\t\tif ((k *= 2) < 1) {\n\t\t\t\treturn 0.5 * k * k;\n\t\t\t}\n\t\t\treturn - 0.5 * (--k * (k - 2) - 1);\n\t\t}\n\t},\n\tCubic: {\n\t\tIn: function (k) {\n\t\t\treturn k * k * k;\n\t\t},\n\t\tOut: function (k) {\n\t\t\treturn --k * k * k + 1;\n\t\t},\n\t\tInOut: function (k) {\n\t\t\tif ((k *= 2) < 1) {\n\t\t\t\treturn 0.5 * k * k * k;\n\t\t\t}\n\t\t\treturn 0.5 * ((k -= 2) * k * k + 2);\n\t\t}\n\t},\n\tQuartic: {\n\t\tIn: function (k) {\n\t\t\treturn k * k * k * k;\n\t\t},\n\t\tOut: function (k) {\n\t\t\treturn 1 - (--k * k * k * k);\n\t\t},\n\t\tInOut: function (k) {\n\t\t\tif ((k *= 2) < 1) {\n\t\t\t\treturn 0.5 * k * k * k * k;\n\t\t\t}\n\t\t\treturn - 0.5 * ((k -= 2) * k * k * k - 2);\n\t\t}\n\t},\n\tQuintic: {\n\t\tIn: function (k) {\n\t\t\treturn k * k * k * k * k;\n\t\t},\n\t\tOut: function (k) {\n\t\t\treturn --k * k * k * k * k + 1;\n\t\t},\n\t\tInOut: function (k) {\n\t\t\tif ((k *= 2) < 1) {\n\t\t\t\treturn 0.5 * k * k * k * k * k;\n\t\t\t}\n\t\t\treturn 0.5 * ((k -= 2) * k * k * k * k + 2);\n\t\t}\n\t},\n\tSinusoidal: {\n\t\tIn: function (k) {\n\t\t\treturn 1 - Math.cos(k * Math.PI / 2);\n\t\t},\n\t\tOut: function (k) {\n\t\t\treturn Math.sin(k * Math.PI / 2);\n\t\t},\n\t\tInOut: function (k) {\n\t\t\treturn 0.5 * (1 - Math.cos(Math.PI * k));\n\t\t}\n\t},\n\tExponential: {\n\t\tIn: function (k) {\n\t\t\treturn k === 0 ? 0 : Math.pow(1024, k - 1);\n\t\t},\n\t\tOut: function (k) {\n\t\t\treturn k === 1 ? 1 : 1 - Math.pow(2, - 10 * k);\n\t\t},\n\t\tInOut: function (k) {\n\t\t\tif (k === 0) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (k === 1) {\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tif ((k *= 2) < 1) {\n\t\t\t\treturn 0.5 * Math.pow(1024, k - 1);\n\t\t\t}\n\t\t\treturn 0.5 * (- Math.pow(2, - 10 * (k - 1)) + 2);\n\t\t}\n\t},\n\tCircular: {\n\t\tIn: function (k) {\n\t\t\treturn 1 - Math.sqrt(1 - k * k);\n\t\t},\n\t\tOut: function (k) {\n\t\t\treturn Math.sqrt(1 - (--k * k));\n\t\t},\n\t\tInOut: function (k) {\n\t\t\tif ((k *= 2) < 1) {\n\t\t\t\treturn - 0.5 * (Math.sqrt(1 - k * k) - 1);\n\t\t\t}\n\t\t\treturn 0.5 * (Math.sqrt(1 - (k -= 2) * k) + 1);\n\t\t}\n\t},\n\tElastic: {\n\t\tIn: function (k) {\n\t\t\tif (k === 0) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (k === 1) {\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\treturn -Math.pow(2, 10 * (k - 1)) * Math.sin((k - 1.1) * 5 * Math.PI);\n\t\t},\n\t\tOut: function (k) {\n\t\t\tif (k === 0) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (k === 1) {\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\treturn Math.pow(2, -10 * k) * Math.sin((k - 0.1) * 5 * Math.PI) + 1;\n\t\t},\n\t\tInOut: function (k) {\n\t\t\tif (k === 0) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (k === 1) {\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tk *= 2;\n\t\t\tif (k < 1) {\n\t\t\t\treturn -0.5 * Math.pow(2, 10 * (k - 1)) * Math.sin((k - 1.1) * 5 * Math.PI);\n\t\t\t}\n\t\t\treturn 0.5 * Math.pow(2, -10 * (k - 1)) * Math.sin((k - 1.1) * 5 * Math.PI) + 1;\n\t\t}\n\t},\n\tBack: {\n\t\tIn: function (k) {\n\t\t\tvar s = 1.70158;\n\t\t\treturn k * k * ((s + 1) * k - s);\n\t\t},\n\t\tOut: function (k) {\n\t\t\tvar s = 1.70158;\n\t\t\treturn --k * k * ((s + 1) * k + s) + 1;\n\t\t},\n\t\tInOut: function (k) {\n\t\t\tvar s = 1.70158 * 1.525;\n\t\t\tif ((k *= 2) < 1) {\n\t\t\t\treturn 0.5 * (k * k * ((s + 1) * k - s));\n\t\t\t}\n\t\t\treturn 0.5 * ((k -= 2) * k * ((s + 1) * k + s) + 2);\n\t\t}\n\t},\n\tBounce: {\n\t\tIn: function (k) {\n\t\t\treturn 1 - Easing.Bounce.Out(1 - k);\n\t\t},\n\t\tOut: function (k) {\n\t\t\tif (k < (1 / 2.75)) {\n\t\t\t\treturn 7.5625 * k * k;\n\t\t\t} else if (k < (2 / 2.75)) {\n\t\t\t\treturn 7.5625 * (k -= (1.5 / 2.75)) * k + 0.75;\n\t\t\t} else if (k < (2.5 / 2.75)) {\n\t\t\t\treturn 7.5625 * (k -= (2.25 / 2.75)) * k + 0.9375;\n\t\t\t} else {\n\t\t\t\treturn 7.5625 * (k -= (2.625 / 2.75)) * k + 0.984375;\n\t\t\t}\n\t\t},\n\t\tInOut: function (k) {\n\t\t\tif (k < 0.5) {\n\t\t\t\treturn Easing.Bounce.In(k * 2) * 0.5;\n\t\t\t}\n\t\t\treturn Easing.Bounce.Out(k * 2 - 1) * 0.5 + 0.5;\n\t\t}\n\t}\n}\n\nconst EASING_FUNCTIONS = {\n  'linear': Easing.Linear.None,\n\n  'ease': Easing.Cubic.InOut,\n  'ease-in': Easing.Cubic.In,\n  'ease-out': Easing.Cubic.Out,\n  'ease-in-out': Easing.Cubic.InOut,\n\n  'ease-cubic': Easing.Cubic.In,\n  'ease-in-cubic': Easing.Cubic.In,\n  'ease-out-cubic': Easing.Cubic.Out,\n  'ease-in-out-cubic': Easing.Cubic.InOut,\n\n  'ease-quad': Easing.Quadratic.InOut,\n  'ease-in-quad': Easing.Quadratic.In,\n  'ease-out-quad': Easing.Quadratic.Out,\n  'ease-in-out-quad': Easing.Quadratic.InOut,\n\n  'ease-quart': Easing.Quartic.InOut,\n  'ease-in-quart': Easing.Quartic.In,\n  'ease-out-quart': Easing.Quartic.Out,\n  'ease-in-out-quart': Easing.Quartic.InOut,\n\n  'ease-quint': Easing.Quintic.InOut,\n  'ease-in-quint': Easing.Quintic.In,\n  'ease-out-quint': Easing.Quintic.Out,\n  'ease-in-out-quint': Easing.Quintic.InOut,\n\n  'ease-sine': Easing.Sinusoidal.InOut,\n  'ease-in-sine': Easing.Sinusoidal.In,\n  'ease-out-sine': Easing.Sinusoidal.Out,\n  'ease-in-out-sine': Easing.Sinusoidal.InOut,\n\n  'ease-expo': Easing.Exponential.InOut,\n  'ease-in-expo': Easing.Exponential.In,\n  'ease-out-expo': Easing.Exponential.Out,\n  'ease-in-out-expo': Easing.Exponential.InOut,\n\n  'ease-circ': Easing.Circular.InOut,\n  'ease-in-circ': Easing.Circular.In,\n  'ease-out-circ': Easing.Circular.Out,\n  'ease-in-out-circ': Easing.Circular.InOut,\n\n  'ease-elastic': Easing.Elastic.InOut,\n  'ease-in-elastic': Easing.Elastic.In,\n  'ease-out-elastic': Easing.Elastic.Out,\n  'ease-in-out-elastic': Easing.Elastic.InOut,\n\n  'ease-back': Easing.Back.InOut,\n  'ease-in-back': Easing.Back.In,\n  'ease-out-back': Easing.Back.Out,\n  'ease-in-out-back': Easing.Back.InOut,\n\n  'ease-bounce': Easing.Bounce.InOut,\n  'ease-in-bounce': Easing.Bounce.In,\n  'ease-out-bounce': Easing.Bounce.Out,\n  'ease-in-out-bounce': Easing.Bounce.InOut,\n}\n\n\n// given [{type: \"numbers\", value: [1,2]}, {type: \"any\", value: \"\"}, {type: \"numbers\", value: [5]}] return type \"numbers\"\n// if there are inconsistencies in the the types then generate an warning\nfunction calcTypeOfArrayOfTypes(list) {\n  let type = \"any\"\n  for (let item of list) {\n    if (item.type === \"any\" || item.type === type) {\n      continue\n    } else if (type === \"any\") {\n      type = item.type\n    } else {\n      console.warn(`incompatible type found '${item.type}', expecting '${type}'`)\n    }\n  }\n  return type\n}\n\n// Convert a string \"1 2 3\" into {type: \"numbers\", value: [1,2,3]}\n// Convert a string \"1..3\" into {type: \"numbers\", range: [1,3]}\n// Convert a string \"1|2|3\" into {type: \"numbers\", options: [1,2,3]}\nfunction parseValueRangeOption(str) {\n  const options = str.split(\"|\")\n  if (options.length > 1) {\n    const parsedOptions = options.map(_aframe_utils__WEBPACK_IMPORTED_MODULE_0__[\"parseValue\"])\n    return { options: parsedOptions.map(x => x.value), type: calcTypeOfArrayOfTypes(parsedOptions) }\n  }\n\n  const range = str.split(\"..\")\n  if (range.length > 1) {\n    const parsedRange = range.map(_aframe_utils__WEBPACK_IMPORTED_MODULE_0__[\"parseValue\"])\n    return { range: parsedRange.map(x => x.value), type: calcTypeOfArrayOfTypes(parsedRange) } \n  }\n\n  const info = Object(_aframe_utils__WEBPACK_IMPORTED_MODULE_0__[\"parseValue\"])(str)\n  return { value: info.value, type: info.type }\n}\n\n// console.assert(deepEqual(parseValueRangeOption(\"1 2 3\"), { type: \"numbers\", value: [1,2,3]}))\n// console.assert(deepEqual(parseValueRangeOption(\"1 2..3 4 5\"), { type: \"numbers\", range: [[1,2],[3,4,5]]}))\n// console.assert(deepEqual(parseValueRangeOption(\"a|b|c\"), { type: \"string\", options: [\"a\",\"b\",\"c\"]}))\n// console.assert(deepEqual(parseValueRangeOption(\"1 2||3\"), { type: \"numbers\", options: [[1,2],\"\",[3]]}))\n// console.assert(deepEqual(parseValueRangeOption(\"..3\"), { type: \"numbers\", range: [\"\",[3]]}))\n\n\n// Convert a string \"1 2 3, 4|5 6, 7..8\" into a type and an array of values, ranges or options {type: \"numbers\", slots: [value: [1,2,3], options: [[4],[5,6]]: range: [[7],[8]]]}\nfunction parseKeyframeData(str) {\n  let slots = str.split(\",\").map(parseValueRangeOption)\n\n  // return the type and slots (stripping type information from each slot)\n  return { \n    type: calcTypeOfArrayOfTypes(slots), \n    slots: slots.map(x => {\n      if (\"range\" in x) return { range: x.range }\n      if (\"options\" in x) return { options: x.options }\n      if (\"value\" in x) return { value: x.value }\n    })\n  }\n}\n\n\n// const colorRulesToHexString = (rules) => { \n//   const colorToString = x => x instanceof THREE.Color ? x.getHexString() : x\n//   return { \n//     type: rules.type, \n//     slots: rules.slots.map(x => { \n//       for (let type in x) { \n//         return { [type] : Array.isArray(x[type]) ? x[type].map(colorToString) : colorToString(x[type]) }\n//       } \n//     }) \n//   }\n// }\n// console.assert(deepEqual(parseKeyframeData(\"1,2,3\"), { type: \"numbers\", slots: [{value: [1]}, {value: [2]}, {value: [3]}] }))\n// console.assert(deepEqual(parseKeyframeData(\"1..2, 3, 4..5\"), { type: \"numbers\", slots: [{range: [[1],[2]]}, {value: [3]}, {range: [[4],[5]]}] }))\n// console.assert(deepEqual(parseKeyframeData(\"a|b|c, d|e, f\"), { type: \"string\", slots: [{options: [\"a\",\"b\",\"c\"]}, {options: [\"d\",\"e\"]}, {value: \"f\"}] }))\n// console.assert(deepEqual(colorRulesToHexString(parseKeyframeData(\"yellow, black..blue, orange|green\")), { type: \"color\", slots: [{value: \"ffff00\"}, {range: [\"000000\", \"0000ff\"]}, {options: [\"ffa500\",\"008000\"]}] }))\n// console.assert(deepEqual(parseKeyframeData(\",1 2,3 4 5\"), { type: \"numbers\", slots: [{value: \"\"}, {value: [1,2]}, {value: [3,4,5]}] }))\n// console.assert(deepEqual(colorRulesToHexString(parseKeyframeData(\"..red,,blue|green|\")), { type: \"color\", slots: [{range: [\"\", \"ff0000\"]}, {value: \"\"}, {options: [\"0000ff\", \"008000\", \"\"]}] }))\n\n\nfunction randomizeRange(type, range, randFn) {\n  const min = range[0]\n  const max = range[1]\n\n  const randomNumber = (min, max) => {\n    if (min === max) return min\n    return randFn()*(max - min) + min\n  }\n\n  if (type === \"numbers\") {\n    const m = Math.min(min.length, max.length) // count the least elements\n    let result = max.length > m ? max.slice() : min.slice() // copy the larger array\n    for (let i = 0; i < m; i++) {\n      result[i] = randomNumber(min[i], max[i]) // randomize the parts where values exist for both min and max\n    }\n    return result\n  }\n  \n  if (type === \"color\") {\n    return new THREE.Color(randomNumber(min.r, max.r), randomNumber(min.g, max.g), randomNumber(min.b, max.b))\n  }\n\n  return randFn() > 0.5 ? min : max\n}\n\n\nconst RULE_RANDOMIZER = {\n  \"value\": (type, value, randFn) => value,\n  \"options\": (type, parts, randFn) => parts[~~(randFn()*parts.length)],\n  \"range\": randomizeRange\n}\n\n\n// const stringParts = [\"a\",\"ab\",\"bc\"];\n// const vecParts = [[1,2,3],[10,20]]\n// for (let i = 0; i < 50; i++) {\n//   console.assert(typeof RULE_RANDOMIZER[\"options\"](\"numbers\", [], Math.random) === \"undefined\")\n//   console.assert(RULE_RANDOMIZER[\"options\"](\"string\", [\"x\"], Math.random) === \"x\")\n//   console.assert(stringParts.includes(RULE_RANDOMIZER[\"options\"](\"string\", stringParts, Math.random)))\n//   console.assert([\"a\", \"b\"].includes(RULE_RANDOMIZER[\"range\"](\"string\", [\"a\", \"b\", \"c\"], Math.random)))\n  \n//   const x = RULE_RANDOMIZER[\"range\"](\"numbers\", [[1],[2]], Math.random)\n//   console.assert(x >= 1 && x < 2)\n\n//   const y = RULE_RANDOMIZER[\"range\"](\"numbers\", vecParts, Math.random)\n//   console.assert(y.length === 3 && y[0] >= vecParts[0][0] && y[0] < vecParts[1][0] && y[1] >= vecParts[0][1] && y[1] < vecParts[1][1] && y[2] === vecParts[0][2])\n// }\n\n\n// takes a set of rules (e.g from parseKeyframeData) and provides an array of random values that meets those rules\n// e.g. {type: \"numbers\", slots: [value: [1,2,3], options: [[4],[5,6]]: range: [[7],[8]]]} produces [[1,2,3],[5,6],[7.5]]\nfunction randomRules(rules, randFn) {\n  let prevX // this will always be value because the first slot will always contain valid data\n\n  return rules.slots.map(x => {\n    const slotType = Object.keys(x)[0]\n    \n    // replace empty parts with the previous value\n    let slot = x[slotType]\n    if (Array.isArray(slot) && slot.includes(\"\")) {\n      console.assert(typeof prevX !== \"undefined\")\n      slot = slot.map(x => x === \"\" ? prevX : x)\n    } else if (slot === \"\") {\n      console.assert(typeof prevX !== \"undefined\")\n      slot = prevX\n    }\n\n    prevX = RULE_RANDOMIZER[slotType](rules.type, slot, randFn)\n    return prevX\n  })\n}\n\nfunction hasRandomness(rules) {\n  return rules.slots.some(x => !(\"value\" in x))\n}\n\n// a and b may be different lengths\nfunction lerpNumbers(a, b, t, out) {\n  const m = Math.min(a.length, b.length)\n  out.length = Math.max(a.length, b.length)\n\n  for (let i = 0; i < m; i++) {\n    out[i] = THREE.Math.lerp(a[i], b[i], t)\n  }\n  for (let i = m; i < a.length; i++) {\n    out[i] = a[i]\n  }\n  for (let i = m; i < b.length; i++) {\n    out[i] = b[i]\n  }\n\n  return out\n}\n\n// const lerpHSL = (a, b, t) => {\n//   let h = THREE.Math.lerp(a.h, b.h, t)\n//   let s = THREE.Math.lerp(a.s, b.s, t)\n//   let l = THREE.Math.lerp(a.l, b.l, t)\n//   return {h,s,l}\n// }\n\n\nfunction lerpColor(a, b, t, outColor) {\n  return outColor.setRGB(a.r, a.g, a.b).lerp(b, t)\n}\n\n\nfunction lerpReturnFirst(a, b, t, out) {\n  return a\n}\n\n\nconst SLOT_LERP_FUNCTION = {\n  \"numbers\": lerpNumbers,\n  \"color\": lerpColor,\n  \"string\": lerpReturnFirst,\n  \"boolean\": lerpReturnFirst,\n  \"any\": lerpReturnFirst,\n}\n\n\nlet lerpResultHolder = {\n  \"numbers\": [],\n  \"color\": new THREE.Color(),\n  \"string\": \"\",\n  \"boolean\": false,\n  \"any\": \"\"\n}\n\n// Takes a set of keys (from randomRules()), and provides an interpolated value, where r is 0 (first key) to 1 (last key)\n// e.g. [[1,2,3],[5,6],[7.5]] @ r = 0.25 becomes [3,4,3]\nfunction lerpKeys(type, keys, r, easingFn) {\n  const n = keys.length\n\n  if (r <= 0 || n <= 1) {\n    return keys[0]\n  } else if (r >= 1) {\n    return keys[n - 1]\n  }\n\n  const k = r*(n - 1)\n  const i = ~~k\n  const t = easingFn(k - i)\n  return SLOT_LERP_FUNCTION[type](keys[i], keys[i+1], t, lerpResultHolder[type])\n}\n\n// const EPSILON = 1e-4\n// console.assert( Math.abs(lerpKeys(\"numbers\", [[1],[2],[3]], 0)[0] - 1) < EPSILON )\n// console.assert( Math.abs(lerpKeys(\"numbers\", [[1],[2],[3]], 0.5)[0] - 2) < EPSILON )\n// console.assert( Math.abs(lerpKeys(\"numbers\", [[1],[2],[3]], 0.25)[0] - 1.5) < EPSILON )\n// console.assert( Math.abs(lerpKeys(\"numbers\", [[1],[2],[3]], 0.75)[0] - 2.5) < EPSILON )\n// console.assert( Math.abs(lerpKeys(\"numbers\", [[1],[2],[3]], 1)[0] - 3) < EPSILON )\n// console.assert( Math.abs(lerpKeys(\"numbers\", [[1,2,3],[4,5,6],[7,8,9]], 0.75)[1] - 6.5) < EPSILON )\n// console.assert( lerpKeys(\"string\", [\"a\",\"b\",\"c\"], 0) === \"a\" )\n// console.assert( lerpKeys(\"string\", [\"a\",\"b\",\"c\"], 1) === \"c\" )\n// console.assert( lerpKeys(\"string\", [\"a\",\"b\",\"c\"], 0.25) === \"a\" )\n// console.assert( lerpKeys(\"string\", [\"a\",\"b\",\"c\"], 0.75) === \"b\" )\n\n\nfunction getPropertyAsString(target, prop) {\n  const parts = prop.split(\".\")\n  if (parts.length <= 2) {\n    return Object(_aframe_utils__WEBPACK_IMPORTED_MODULE_0__[\"convertToString\"])(AFRAME.utils.entity.getComponentProperty(target, prop))\n  }\n\n  // e.g. object3dmap.mesh.material.uniforms.color\n  const path = Object(_aframe_utils__WEBPACK_IMPORTED_MODULE_0__[\"buildPath\"])(target, parts)\n  if (path) {\n    return Object(_aframe_utils__WEBPACK_IMPORTED_MODULE_0__[\"convertToString\"])(path[part])\n  } else {\n    console.warn(`unknown path for getProperty() '${prop}'`)\n  }\n}\n\n\n//-----------------------------------------------------------------------------\n// \"keyframe\" component for setting attributes on this element over time\n// \nAFRAME.registerComponent(\"keyframe\", {\n  schema: {\n    enableInEditor: { default: false },\n    duration: { default: 1 },\n    direction: { default: \"forward\", oneOf: [\"forward\", \"backward\", \"alternate\"] },\n    loops: { default: -1 },\n    seed: { default: -1, type: \"int\" },\n    easing: { default: \"linear\", oneOf: Object.keys(EASING_FUNCTIONS) },\n    randomizeEachLoop: { default: true },\n  },\n  multiple: true,\n\n  init() {\n    this.pauseTick = this.pauseTick.bind(this)\n    this.pseudoRandom = Object(_basic_random__WEBPACK_IMPORTED_MODULE_1__[\"default\"])()\n\n    this.loopTime = 0 // seconds\n    this.loops = 0\n    this.keys = {}\n    this.rules = {}\n  },\n\n  updateSchema(newData) {\n    const originalSchema = AFRAME.components[this.name].schema\n    let newSchema = {} // everything that has changed from the ORIGINAL schema\n\n    // add new rules\n    for (let prop in newData) {\n      if (!(prop in originalSchema)) {\n        newSchema[prop] = { type: \"string\" }\n      }\n    }\n\n    // extend the schema so the new rules appear in the inspector\n    if (Object.keys(newSchema).length > 0) {\n      this.extendSchema(newSchema)\n    }\n  },\n\n  update(oldData) {\n    const data = this.data\n    const originalSchema = AFRAME.components[this.name].schema\n\n    if (oldData.seed !== data.seed) {\n      this.pseudoRandom.setSeed(data.seed) // must be updated before other attributes\n    }\n\n    // remove old rules and keys\n    for (let prop in this.rules) {\n      if (!(prop in data)) {\n        delete this.rules[prop]\n        delete this.keys[prop]\n      }\n    }\n\n    for (let prop in data) {\n      if (oldData[prop] !== data[prop] && !(prop in originalSchema)) {\n        this.rules[prop] = parseKeyframeData(data[prop])\n\n        this.guessMissingFirstValue(prop, this.rules[prop])\n\n        this.keys[prop] = randomRules(this.rules[prop], this.pseudoRandom.random)\n      }\n    }\n\n    if (oldData.duration !== data.duration || oldData.loops !== data.loops) {\n      this.loopTime = 0\n      this.loops = 0\n    }\n\n    if (oldData.direction !== data.direction) {\n      this.forward = (data.direction !== \"backward\")\n      this.loopTime = this.forward ? 0 : data.duration\n    }\n\n    if (data.enableInEditor !== oldData.enableInEditor) {\n      this.enablePauseTick(data.enableInEditor)\n    }\n  },\n\n  tick(time, timeDelta) {\n    const dt = Math.min(timeDelta, MAX_FRAME_TIME_MS)/1000\n    this.step(dt)\n  },\n\n  pause() {\n    this.enablePauseTick(this.data.enableInEditor)\n  },\n\n  play() {\n    this.enablePauseTick(false)\n  },\n\n  enablePauseTick(enable) {\n    if (enable) {\n      this.pauseRAF = requestAnimationFrame(this.pauseTick)\n    } else {\n      cancelAnimationFrame(this.pauseRAF)\n    }\n  },\n\n  pauseTick() {\n    this.step(0.016)\n    this.enablePauseTick(true)\n  },\n\n  step(dt) {\n    const data = this.data\n\n    if ((data.loops < 0 || this.loops < data.loops) && data.duration > 0) {\n      let looped = false\n      this.loopTime = this.loopTime + (this.forward ? dt : -dt)\n    \n      if (this.loopTime > data.duration || this.loopTime < 0) {\n        this.loops++\n        looped = true\n      }\n\n      if (looped && (data.loops < 0 || this.loops < data.loops)) {\n        if (data.direction === \"alternate\") {\n          this.forward = !this.forward\n          this.loopTime = this.loopTime < 0 ? -this.loopTime : 2*data.duration - this.loopTime // overshoot goes into the opposite direction\n        } else {\n          this.loopTime = this.loopTime + (this.forward ? -data.duration : data.duration)\n        }\n\n        if (data.randomizeEachLoop) {\n          for (let prop in this.keys) {\n            if (hasRandomness(this.rules[prop])) {\n              this.keys[prop] = randomRules(this.rules[prop], this.pseudoRandom.random)\n            }\n          }\n        }\n      }\n\n      const easingFn = EASING_FUNCTIONS[data.easing] || EASING_FUNCTIONS[\"linear\"]\n      \n      for (let prop in this.keys) {\n        let r = THREE.Math.clamp(this.loopTime/data.duration, 0, 1)\n        const value = lerpKeys(this.rules[prop].type, this.keys[prop], r, easingFn)\n        Object(_aframe_utils__WEBPACK_IMPORTED_MODULE_0__[\"setProperty\"])(this.el, prop, value)\n      }\n    }\n  },\n\n  guessMissingFirstValue(prop, rule) {\n    if (rule.slots.length > 0) {\n      let slot0 = rule.slots[0]\n      const emptyValue = slot0.value === \"\"\n      const emptyRange = slot0.range && slot0.range.includes(\"\")\n      const emptyOption = slot0.options && slot0.options.includes(\"\")\n\n      if (emptyValue || emptyRange || emptyOption) {\n        let info = Object(_aframe_utils__WEBPACK_IMPORTED_MODULE_0__[\"parseValue\"])(getPropertyAsString(this.el, prop))\n        if (emptyValue) slot0.value = info.value\n        if (emptyRange) slot0.range = slot0.range.map(x => x === \"\" ? info.value : x)\n        if (emptyOption) slot0.options = slot0.options.map(x => x === \"\" ? info.value : x)\n      }\n    }\n  },\n})\n\n\n\n//# sourceURL=webpack:///./src/aframe-keyframe-component.mjs?");

/***/ }),

/***/ "./src/aframe-sprite-particles-component.mjs":
/*!***************************************************!*\
  !*** ./src/aframe-sprite-particles-component.mjs ***!
  \***************************************************/
/*! no exports provided */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n// Copyright 2018-2019 harlyq\n// License MIT\n\nconst TIME_PARAM = 0 // [0].x\nconst ID_PARAM = 1 // [0].y\nconst RADIAL_X_PARAM = 2 // [0].z\nconst DURATION_PARAM = 3 // [0].w\nconst SPAWN_TYPE_PARAM = 4 // [1].x\nconst SPAWN_RATE_PARAM = 5 // [1].y\nconst SEED_PARAM = 6 // [1].z\nconst VERTEX_COUNT_PARAM = 7 // [1].w\nconst PARTICLE_SIZE_PARAM =  8 // [2].x\nconst USE_PERSPECTIVE_PARAM = 9 // [2].y\nconst DIRECTION_PARAM = 10 // [2].z\nconst DRAG_PARAM = 11 // [2].w\nconst TRAIL_INTERVAL_PARAM = 12 // [3].x\nconst PARTICLE_COUNT_PARAM = 13 // [3].y\nconst TRAIL_COUNT_PARAM = 14 // [3].z\nconst SCREEN_DEPTH_OFFSET_PARAM = 15 // [3].w\nconst RIBBON_WIDTH_PARAM = 16 // [4].x\nconst RIBBON_UV_MULTIPLIER_PARAM = 17 // [4].y\nconst RIBBON_UV_TYPE_PARAM = 18 // [4].z\nconst RADIAL_Y_PARAM = 19 // [4].w\nconst PARAMS_LENGTH = 5 // 0..4\n\nconst MODEL_MESH = \"mesh\"\nconst VERTS_PER_RIBBON = 2\n\nconst RANDOM_REPEAT_COUNT = 131072 // random numbers will start repeating after this number of particles\n\nconst degToRad = THREE.Math.degToRad\n\nconst ATTR_TO_DEFINES = {\n  acceleration: \"USE_PARTICLE_ACCELERATION\",\n  angularAcceleration: \"USE_PARTICLE_ANGULAR_ACCELERATION\",\n  angularVelocity: \"USE_PARTICLE_ANGULAR_VELOCITY\",\n  color: \"USE_PARTICLE_COLOR\",\n  textureFrame: \"USE_PARTICLE_FRAMES\",\n  textureCount: \"USE_PARTICLE_FRAMES\",\n  textureLoop: \"USE_PARTICLE_FRAMES\",\n  position: \"USE_PARTICLE_OFFSET\",\n  opacity: \"USE_PARTICLE_OPACITY\",\n  radialAcceleration: \"USE_PARTICLE_RADIAL_ACCELERATION\",\n  radialPosition: \"USE_PARTICLE_RADIAL_OFFSET\",\n  radialVelocity: \"USE_PARTICLE_RADIAL_VELOCITY\",\n  scale: \"USE_PARTICLE_SCALE\",\n  velocity: \"USE_PARTICLE_VELOCITY\",\n  orbitalVelocity: \"USE_PARTICLE_ORBITAL\",\n  orbitalAcceleration: \"USE_PARTICLE_ORBITAL\",\n  drag: \"USE_PARTICLE_DRAG\",\n  destinationWeight: \"USE_PARTICLE_DESTINATION\",\n  screenDepthOffset: \"USE_PARTICLE_SCREEN_DEPTH_OFFSET\",\n  source: \"USE_PARTICLE_SOURCE\",\n  model: \"USE_PARTICLE_SOURCE\",\n}\n\nconst UV_TYPE_STRINGS = [\"overtime\", \"interval\"]\nconst PARTICLE_ORDER_STRINGS = [\"newest\", \"oldest\", \"original\"]\nconst AXES_NAMES = [\"x\", \"y\", \"z\"]\n\n// Bring all sub-array elements into a single array e.g. [[1,2],[[3],4],5] => [1,2,3,4,5]\nconst flattenDeep = arr1 => arr1.reduce((acc, val) => Array.isArray(val) ? acc.concat(flattenDeep(val)) : acc.concat(val), [])\n\n// Convert a vector range string into an array of elements. def defines the default elements for each vector\nconst parseVecRange = (str, def) => {\n  let parts = str.split(\"..\").map(a => a.trim().split(\" \").map(b => {\n    const num = Number(b)\n    return isNaN(num) ? undefined : num\n  }))\n  if (parts.length === 1) parts[1] = parts[0] // if there is no second part then copy the first part\n  parts.length = 2\n  return flattenDeep( parts.map(a => def.map((x,i) => typeof a[i] === \"undefined\" ? x : a[i])) )\n}\n\n// parse a (\",\" separated) list of vector range elements\nconst parseVecRangeArray = (str, def) => {\n  return flattenDeep( str.split(\",\").map(a => parseVecRange(a, def)) )\n}\n\n// parse a (\",\" separated) list of color range elements\nconst parseColorRangeArray = (str) => {\n  return flattenDeep( str.split(\",\").map(a => { \n    let parts = a.split(\"..\")\n    if (parts.length === 1) parts[1] = parts[0] // if there is no second part then copy the first part\n    parts.length = 2\n    return parts.map(b => new THREE.Color(b.trim())) \n  }) )\n}\n\nconst toLowerCase = x => x.toLowerCase()\n\n// console.assert(AFRAME.utils.deepEqual(parseVecRange(\"\", [1,2,3]), [1,2,3,1,2,3]))\n// console.assert(AFRAME.utils.deepEqual(parseVecRange(\"5\", [1,2,3]), [5,2,3,5,2,3]))\n// console.assert(AFRAME.utils.deepEqual(parseVecRange(\"5 6\", [1,2,3]), [5,6,3,5,6,3]))\n// console.assert(AFRAME.utils.deepEqual(parseVecRange(\"5 6 7 8\", [1,2,3]), [5,6,7,5,6,7]))\n// console.assert(AFRAME.utils.deepEqual(parseVecRange(\"8 9..10\", [1,2,3]), [8,9,3,10,2,3]))\n// console.assert(AFRAME.utils.deepEqual(parseVecRange(\"..5 6 7\", [1,2,3]), [1,2,3,5,6,7]))\n// console.assert(AFRAME.utils.deepEqual(parseVecRange(\"2 3 4..5 6 7\", [1,2,3]), [2,3,4,5,6,7]))\n// console.assert(AFRAME.utils.deepEqual(parseVecRange(\"5 6 7..\", [1,2,3]), [5,6,7,1,2,3]))\n\n// console.assert(AFRAME.utils.deepEqual(parseVecRangeArray(\"5 6 7..,9..10 11 12\", [1,2,3]), [5,6,7,1,2,3,9,2,3,10,11,12]))\n// console.assert(AFRAME.utils.deepEqual(parseVecRangeArray(\"1,2,,,3\", [10]), [1,1,2,2,10,10,10,10,3,3]))\n\n// console.assert(AFRAME.utils.deepEqual(parseColorRangeArray(\"black..red,blue,,#ff0..#00ffaa\").map(a => a.getHexString()), [\"000000\",\"ff0000\",\"0000ff\",\"0000ff\",\"ffffff\",\"ffffff\",\"ffff00\",\"00ffaa\"]))\n\nlet WHITE_TEXTURE = new THREE.DataTexture(new Uint8Array(3).fill(255), 1, 1, THREE.RGBFormat)\nWHITE_TEXTURE.needsUpdate = true\n\nconst BLENDING_MAP = {\n  \"none\": THREE.NoBlending,\n  \"normal\": THREE.NormalBlending,\n  \"additive\": THREE.AdditiveBlending,\n  \"subtractive\": THREE.SubtractiveBlending,\n  \"multiply\": THREE.MultiplyBlending,\n}\n\nconst SIDE_MAP = {\n  \"double\": THREE.DoubleSide,\n  \"front\": THREE.FrontSide,\n  \"back\": THREE.BackSide,\n}\n\nAFRAME.registerComponent(\"sprite-particles\", {\n  schema: {\n    enableInEditor: { default: false },\n    texture: { type: \"map\" },\n    delay: { default: 0 },\n    duration: { default: -1 },\n    spawnType: { default: \"continuous\", oneOf: [\"continuous\", \"burst\"], parse: toLowerCase },\n    spawnRate: { default: 10 },\n    source: { type: \"selector\" },\n    textureFrame: { type: \"vec2\", default: {x: 1, y: 1} },\n    textureCount: { type: \"int\", default: 0 },\n    textureLoop: { default: 1 },\n    randomizeFrames: { default: false },\n    trailInterval: { default: 0 },\n    trailLifeTime: { default: \"0\" },\n    trailType: { default: \"particle\", oneOf: [\"particle\", \"ribbon\", \"ribbon3d\"] },\n    ribbonWidth: { default: 1, },\n    ribbonShape: { default: \"flat\", oneOf: [\"flat\", \"taperin\", \"taperout\", \"taper\"], parse: toLowerCase },\n    ribbonUVType: { default: \"overtime\", oneOf: UV_TYPE_STRINGS, parse: toLowerCase },\n    emitterColor: { type: \"color\" },\n\n    lifeTime: { default: \"1\" },\n    position: { default: \"0 0 0\" },\n    velocity: { default: \"0 0 0\" },\n    acceleration: { default: \"0 0 0\" },\n    radialType: { default: \"circle\", oneOf: [\"circle\", \"sphere\", \"circlexy\", \"circlexz\"], parse: toLowerCase },\n    radialPosition: { default: \"0\" },\n    radialVelocity: { default: \"0\" },\n    radialAcceleration: { default: \"0\" },\n    angularVelocity: { default: \"0 0 0\" },\n    angularAcceleration: { default: \"0 0 0\" },\n    orbitalVelocity: { default: \"0\" },\n    orbitalAcceleration: { default: \"0\" },\n    scale: { default: \"1\" },\n    color: { default: \"white\", parse: toLowerCase },\n    rotation: { default: \"0\" }, // if rotating textureFrames important to have enough space so overlapping parts of frames are blank (circle of sqrt(2) around the center of the frame will be viewable while rotating)\n    opacity: { default: \"1\" },\n    velocityScale: { default: 0 },\n    velocityScaleMinMax: { type: \"vec2\", default: {x: 0, y: 3} },\n    drag: { default: 0 },\n    destination: { type: \"selector\" },\n    destinationOffset: { default: \"0 0 0\" },\n    destinationWeight: { default: \"0\" },\n\n    enable: { default: true },\n    emitterTime: { default: 0 },\n    model: { type: \"selector\" },\n    modelFill: { default: \"triangle\", oneOf: [\"triangle\", \"edge\", \"vertex\"], parse: toLowerCase },\n    direction: { default: \"forward\", oneOf: [\"forward\", \"backward\"], parse: toLowerCase },\n    particleOrder: { default: \"original\", oneOf: PARTICLE_ORDER_STRINGS },\n    ribbonUVMultiplier: { default: 1 },\n    materialSide: { default: \"front\", oneOf: [\"double\", \"front\", \"back\"], parse: toLowerCase },\n    screenDepthOffset: { default: 0 },\n    alphaTest: { default: 0 },\n    fog: { default: true },\n    depthWrite: { default: false },\n    depthTest: { default: true },\n    blending: { default: \"normal\", oneOf: [\"none\", \"normal\", \"additive\", \"subtractive\", \"multiply\"], parse: toLowerCase },\n    transparent: { default: true },\n    particleSize: { default: 100 },\n    usePerspective: { default: true },\n    seed: { type: \"number\", default: -1 },\n    overTimeSlots: { type: \"int\", default: 5 },\n    frustumCulled: { default: true },\n    editorObject: { default: true },\n  },\n  multiple: true,\n  help: \"https://github.com/harlyq/aframe-sprite-particles-component\",\n\n  init() {\n    this.pauseTick = this.pauseTick.bind(this)\n    this.handleObject3DSet = this.handleObject3DSet.bind(this)\n\n    this.count = 0\n    this.trailCount = 0\n    this.overTimeArrayLength = 0\n    this.emitterTime = 0\n    this.delayTime = 0\n    this.lifeTime = [1,1]\n    this.trailLifeTime = [0,0] // if 0, then use this.lifeTime\n\n    // this.useTransparent = false\n    this.textureFrames = new Float32Array(4) // xy is TextureFrame, z is TextureCount, w is TextureLoop\n    this.offset = new Float32Array(2*4).fill(0) // xyz is position, w is radialPosition\n    this.velocity = new Float32Array(2*4).fill(0) // xyz is velocity, w is radialVelocity\n    this.acceleration = new Float32Array(2*4).fill(0) // xyz is acceleration, w is radialAcceleration\n    this.angularVelocity = new Float32Array(2*4).fill(0) // xyz is angularVelocity, w is lifeTime\n    this.angularAcceleration = new Float32Array(2*4).fill(0) // xyz is angularAcceleration\n    this.orbital = new Float32Array(2*2).fill(0) // x is orbitalVelocity, y is orbitalAcceleration\n    this.colorOverTime // color is xyz and opacity is w. created in update()\n    this.rotationScaleOverTime // x is rotation, y is scale. created in update()\n    this.params = new Float32Array(5*4).fill(0) // see ..._PARAM constants\n    this.velocityScale = new Float32Array(3).fill(0) // x is velocityScale, y is velocityScaleMinMax.x and z is velocityScaleMinMax.y\n    this.emitterColor = new THREE.Vector3() // use vec3 for color\n    this.destination = new Float32Array(2*4).fill(0) // range value, xyz is destinationEntity.position + destinationOffset, w is destinationWeight\n    this.destinationOffset // parsed value for destinationOffset, this will be blended into destination\n    this.destinationWeight // parsed value for destinationWeight\n    this.nextID = 0\n    this.nextTime = 0\n    this.numDisabled = 0\n    this.numEnabled = 0\n    this.startDisabled = !this.data.enable // if we start disabled then the tick is disabled, until the component is enabled\n    this.manageIDs = false\n\n    this.params[ID_PARAM] = -1 // unmanaged IDs\n  },\n\n  remove() {\n    if (this.mesh) {\n      this.el.removeObject3D(this.mesh.name)\n    }\n    if (data.model) {\n      data.model.removeEventListener(\"object3dset\", this.handleObject3DSet)\n    }\n  },\n\n  update(oldData) {\n    const data = this.data\n    \n    let boundsDirty = data.particleSize !== oldData.particleSize\n    let overTimeDirty = false\n\n    // can only change overTimeSlots while paused, as it will rebuild the shader (see updateDefines())\n    if (data.overTimeSlots !== oldData.overTimeSlots && !this.isPlaying) {\n      this.overTimeArrayLength = this.data.overTimeSlots*2 + 1 // each slot represents 2 glsl array elements pluse one element for the length info\n      this.colorOverTime = new Float32Array(4*this.overTimeArrayLength).fill(0) // color is xyz and opacity is w\n      this.rotationScaleOverTime = new Float32Array(2*this.overTimeArrayLength).fill(0) // x is rotation, y is scale\n      overTimeDirty = true\n    }\n\n    this.params[PARTICLE_SIZE_PARAM] = data.particleSize\n    this.params[USE_PERSPECTIVE_PARAM] = data.usePerspective ? 1 : 0\n    this.params[DIRECTION_PARAM] = data.direction === \"forward\" ? 0 : 1\n    this.params[DRAG_PARAM] = THREE.Math.clamp(data.drag, 0, 1)\n    this.params[SCREEN_DEPTH_OFFSET_PARAM] = data.screenDepthOffset*1e-5\n    this.params[RIBBON_WIDTH_PARAM] = data.ribbonWidth\n    this.params[RIBBON_UV_MULTIPLIER_PARAM] = data.ribbonUVMultiplier\n\n    this.textureFrames[0] = data.textureFrame.x\n    this.textureFrames[1] = data.textureFrame.y\n    this.textureFrames[2] = data.textureCount > 0 ? data.textureCount : data.textureFrame.x * data.textureFrame.y\n    this.textureFrames[3] = data.textureLoop\n\n    this.velocityScale[0] = data.velocityScale\n    this.velocityScale[1] = data.velocityScaleMinMax.x\n    this.velocityScale[2] = data.velocityScaleMinMax.y\n\n    if (this.material) {\n      this.material.alphaTest = data.alphaTest\n      this.material.depthTest = data.depthTest\n      this.material.depthWrite = data.depthWrite\n      this.material.blending = BLENDING_MAP[data.blending]\n      this.material.fog = data.fog\n    }\n\n    if (data.seed !== oldData.seed) {\n      this.seed = data.seed\n      this.params[SEED_PARAM] = data.seed >= 0 ? data.seed : Math.random()\n    }\n\n    if (data.ribbonUVType !== oldData.ribbonUVType) {\n      this.params[RIBBON_UV_TYPE_PARAM] = UV_TYPE_STRINGS.indexOf(data.ribbonUVType) === -1 ? 0 : UV_TYPE_STRINGS.indexOf(data.ribbonUVType)\n    }\n\n    if (data.radialType !== oldData.radialType) {\n      this.params[RADIAL_X_PARAM] = [\"sphere\", \"circlexy\", \"circle\"].includes(data.radialType) ? 1 : 0\n      this.params[RADIAL_Y_PARAM] = [\"sphere\", \"circlexz\"].includes(data.radialType) ? 1 : 0\n    }\n\n    if (this.mesh && data.frustumCulled !== oldData.frustumCulled) {\n      this.mesh.frustumCulled = data.frustumCulled\n    }\n\n    if (data.emitterColor !== oldData.emitterColor) {\n      const col = new THREE.Color(data.emitterColor)\n      this.emitterColor.set(col.r, col.g, col.b)\n    }\n\n    if (data.position !== oldData.position || data.radialPosition !== oldData.radialPosition) {\n      this.updateVec4XYZRange(data.position, \"offset\")\n      this.updateVec4WRange(data.radialPosition, [0], \"offset\")\n      boundsDirty = true\n    }\n\n    if (data.velocity !== oldData.velocity || data.radialVelocity !== oldData.radialVelocity) {\n      this.updateVec4XYZRange(data.velocity, \"velocity\")\n      this.updateVec4WRange(data.radialVelocity, [0], \"velocity\")\n      boundsDirty = true\n    }\n\n    if (data.acceleration !== oldData.acceleration || data.radialAcceleration !== oldData.radialAcceleration) {\n      this.updateVec4XYZRange(data.acceleration, \"acceleration\")\n      this.updateVec4WRange(data.radialAcceleration, [0], \"acceleration\")\n      boundsDirty = true\n    }\n\n    if (data.rotation !== oldData.rotation || data.scale !== oldData.scale || overTimeDirty) {\n      this.updateRotationScaleOverTime()\n      boundsDirty = true\n    }\n\n    if (data.color !== oldData.color || data.opacity !== oldData.opacity || overTimeDirty) {\n      this.updateColorOverTime()\n    }\n\n    if (data.lifeTime !== oldData.lifeTime) {\n      this.lifeTime = this.updateVec4WRange(data.lifeTime, [1], \"angularVelocity\")\n    }\n\n    if (data.angularVelocity !== oldData.angularVelocity) {\n      this.updateAngularVec4XYZRange(data.angularVelocity, \"angularVelocity\")\n    }\n\n    if (data.trailLifeTime !== oldData.trailLifeTime) {\n      // if trailLifeTime is 0 then use the lifeTime values, and always ensure that trailLifeTime never exceeds the lifeTime\n      this.trailLifeTime = parseVecRange(data.trailLifeTime, [0]).map((x,i) => x > 0 ? x : this.lifeTime[i])\n      this[\"angularAcceleration\"][3] = this.trailLifeTime[0] // angularAcceleration[0].w\n      this[\"angularAcceleration\"][7] = this.trailLifeTime[1] // angularAcceleration[1].w\n    }\n\n    if (data.angularAcceleration !== oldData.angularAcceleration) {\n      this.updateAngularVec4XYZRange(data.angularAcceleration, \"angularAcceleration\")\n    }\n\n    if (data.orbitalVelocity !== oldData.orbitalVelocity) {\n      this.updateAngularVec2PartRange(data.orbitalVelocity, [0], \"orbital\", 0) // x part\n    }\n\n    if (data.orbitalAcceleration !== oldData.orbitalAcceleration) {\n      this.updateAngularVec2PartRange(data.orbitalAcceleration, [0], \"orbital\", 1) // y part\n    }\n\n    if (data.destinationOffset !== oldData.destinationOffset) {\n      this.destinationOffset = this.updateVec4XYZRange(data.destinationOffset, \"destination\")\n    }\n\n    if (data.destinationWeight !== oldData.destinationWeight) {\n      this.destinationWeight = this.updateVec4WRange(data.destinationWeight, [0], \"destination\")\n    }\n\n    if (data.duration !== oldData.duration || data.delay !== oldData.delay || data.emitterTime !== oldData.emitterTime) {\n      // restart the particles\n      this.params[DURATION_PARAM] = data.duration\n      this.emitterTime = data.emitterTime\n      this.delayTime = data.delay\n    }\n\n    if (data.spawnType !== oldData.spawnType || data.spawnRate !== oldData.spawnRate || data.lifeTime !== oldData.lifeTime || data.trailInterval !== oldData.trailInterval) {\n      const maxParticleLifeTime = this.lifeTime[1]\n      const maxTrailLifeTime = data.trailInterval > 0 ? this.trailLifeTime[1] : 0\n      const maxAge = maxParticleLifeTime + maxTrailLifeTime\n      const particleCount = Math.max( 1, Math.ceil(maxAge*data.spawnRate) )\n      this.trailCount = 1 + ( data.trailInterval > 0 ? Math.ceil( Math.min(maxTrailLifeTime, maxParticleLifeTime)/data.trailInterval ) : 0 ) // +1 because the trail includes the lead particle\n\n      if (this.isRibbon()) { \n        this.trailCount++ // short ribbons will need an extra vert so they can bend around an interval, but why the extra vert for long ribbons?\n        this.count = particleCount * this.trailCount * VERTS_PER_RIBBON\n      } else {\n        this.count = particleCount * this.trailCount\n      }\n\n      this.params[SPAWN_TYPE_PARAM] = data.spawnType === \"burst\" ? 0 : 1\n      this.params[SPAWN_RATE_PARAM] = data.spawnRate\n      this.params[VERTEX_COUNT_PARAM] = this.count\n      this.params[PARTICLE_COUNT_PARAM] = particleCount\n      this.params[TRAIL_INTERVAL_PARAM] = data.trailInterval\n      this.params[TRAIL_COUNT_PARAM] = this.trailCount\n      this.updateAttributes()\n    }\n\n    if (data.enableInEditor !== oldData.enableInEditor) {\n      this.enablePauseTick(data.enableInEditor)\n    }\n\n    if (data.enable && this.startDisabled) {\n      this.startDisabled = false\n    }\n\n    if (data.model !== oldData.model && data.model && \"getObject3D\" in data.model) {\n      if (oldData.model) { oldData.model.removeEventListener(\"object3dset\", this.handleObject3DSet) }\n      this.updateModelMesh(data.model.getObject3D(MODEL_MESH))\n      if (data.model) { data.model.addEventListener(\"object3dset\", this.handleObject3DSet) }\n    }\n\n    if (data.particleOrder !== \"original\" && data.source) {\n      console.warn(`changing particleOrder to 'original' (was '${data.particleOrder}'), because particles use a source`)\n    }\n\n    if (!this.mesh) {\n      this.createMesh()\n    } else {\n      this.updateDefines()\n    }\n\n    if (data.materialSide !== oldData.materialSide) {\n      this.material.side = SIDE_MAP[data.materialSide]\n    }\n\n    if (boundsDirty) {\n      this.updateBounds() // call after createMesh()\n    }\n\n    if (this.paused && data.editorObject !== oldData.editorObject) {\n      this.enableEditorObject(data.editorObject)\n    }\n\n    // for managedIDs the CPU defines the ID - and we want to avoid this if at all possible\n    // once managed, always managed\n    this.manageIDs = this.manageIDs || !data.enable || data.source || typeof this.el.getDOMAttribute(this.attrName).enable !== \"undefined\" || data.model || data.delay > 0\n\n    // call loadTexture() after createMesh() to ensure that the material is available to accept the texture\n    if (data.texture !== oldData.texture) {\n      this.loadTexture(data.texture)\n    }\n  },\n\n  tick(time, deltaTime) {\n    const data = this.data\n\n    if (this.startDisabled) { return }\n\n    if (deltaTime > 100) deltaTime = 100 // ignore long pauses\n    const dt = deltaTime/1000 // dt is in seconds\n\n    if (data.enable) { this.delayTime -= dt }\n    if (this.delayTime >= 0) { return }\n\n    if (!data.model || this.modelVertices) {\n      this.emitterTime += dt\n      this.params[TIME_PARAM] = this.emitterTime\n\n      if (this.geometry && this.manageIDs) {\n        this.updateWorldTransform(this.emitterTime)\n      } else {\n        this.params[ID_PARAM] = -1\n      }\n\n      if (data.destination && data.destination.object3D && (this.destinationWeight[0] > 0 || this.destinationWeight[1] > 0)) {\n        this.updateDestinationEntity()\n      }\n    }\n  },\n\n  pause() {\n    this.paused = true\n    this.enablePauseTick(this.data.enableInEditor)\n    this.enableEditorObject(this.data.editorObject)\n  },\n\n  play() {\n    this.paused = false\n    this.enableEditorObject(false)\n    this.enablePauseTick(false)\n  },\n\n  enablePauseTick(enable) {\n    if (enable) {\n      this.pauseRAF = requestAnimationFrame(this.pauseTick)\n    } else {\n      cancelAnimationFrame(this.pauseRAF)\n    }\n  },\n\n  pauseTick() {\n    this.tick(0, 16) // time is not used\n    this.enablePauseTick(true)\n  },\n\n  handleObject3DSet(event) {\n    if (event.target === this.data.model && event.detail.type === MODEL_MESH) {\n      this.updateModelMesh(this.data.model.getObject3D(MODEL_MESH))\n    }\n  },\n\n  loadTexture(filename) {\n    if (filename) {\n      let materialSystem = this.el.sceneEl.systems[\"material\"]\n      materialSystem.loadTexture(filename, {src: filename}, (texture) => {\n        if (this.isRibbon()) {\n          texture.wrapS = THREE.RepeatWrapping // needed by ribbonUVMultipler\n        }\n        this.material.uniforms.map.value = texture          \n      })\n    } else {\n      this.material.uniforms.map.value = WHITE_TEXTURE\n    }\n  },\n\n  isRibbon() {\n    return this.data.trailInterval > 0 && this.data.trailType !== \"particle\"\n  },\n\n  createMesh() {\n    const data = this.data\n\n    this.geometry = new THREE.BufferGeometry()\n\n    this.updateAttributes()\n\n    this.material = new THREE.ShaderMaterial({\n      uniforms: {\n        map: { type: \"t\", value: WHITE_TEXTURE },\n        textureFrames: { value: this.textureFrames },\n\n        params: { value: this.params },\n        offset: { value: this.offset },\n        velocity: { value: this.velocity },\n        acceleration: { value: this.acceleration },\n        angularVelocity: { value: this.angularVelocity },\n        angularAcceleration: { value: this.angularAcceleration },\n        orbital: { value: this.orbital },\n        colorOverTime: { value: this.colorOverTime },\n        rotationScaleOverTime: { value: this.rotationScaleOverTime },\n        velocityScale: { value: this.velocityScale },\n        emitterColor: { value: this.emitterColor },\n        destination: { value: this.destination },\n\n        fogDensity: { value: 0.00025 },\n        fogNear: { value: 1 },\n        fogFar: { value: 2000 },\n        fogColor: { value: new THREE.Color( 0xffffff ) }\n      },\n\n      fragmentShader: particleFragmentShader,\n      vertexShader: particleVertexShader,\n\n      transparent: data.transparent,\n      alphaTest: data.alphaTest,\n      blending: BLENDING_MAP[data.blending],\n      fog: data.fog,\n      depthWrite: data.depthWrite,\n      depthTest: data.depthTest,\n      defines: {}, // updated in updateDefines()\n    })\n\n    this.updateDefines()\n\n    if (this.isRibbon()) {\n      // // this.material.side = THREE.DoubleSide\n      // this.material.side = THREE.FrontSide\n      this.mesh = new THREE.Mesh(this.geometry, [this.material]) // geometry groups need an array of materials\n      this.mesh.drawMode = THREE.TriangleStripDrawMode\n    } else {\n      this.mesh = new THREE.Points(this.geometry, this.material)\n    }\n\n    this.mesh.frustumCulled = data.frustumCulled\n    this.mesh.name = this.attrName\n    this.material.name = this.mesh.name\n    this.el.setObject3D(this.mesh.name, this.mesh)\n  },\n\n  updateColorOverTime() {\n    let color = parseColorRangeArray(this.data.color)\n    let opacity = parseVecRangeArray(this.data.opacity, [1])\n\n    const maxSlots = this.data.overTimeSlots\n    if (color.length > maxSlots*2) color.length = maxSlots*2\n    if (opacity.length > maxSlots*2) opacity.length = maxSlots*2\n\n    this.colorOverTime.fill(0)\n\n    // first colorOverTime block contains length information\n    // divide by 2 because each array contains min and max values\n    this.colorOverTime[0] = color.length/2  // glsl colorOverTime[0].x\n    this.colorOverTime[1] = opacity.length/2 // glsl colorOverTime[0].y\n\n    // set k to 4 because the first vec4 of colorOverTime is use for the length params\n    let n = color.length\n    for (let i = 0, k = 4; i < n; i++, k += 4) {\n      let col = color[i]\n      this.colorOverTime[k] = col.r // glsl colorOverTime[1..].x\n      this.colorOverTime[k+1] = col.g // glsl colorOverTime[1..].y\n      this.colorOverTime[k+2] = col.b // glsl colorOverTime[1..].z\n    }\n\n    n = opacity.length\n    for (let i = 0, k = 4; i < n; i++, k += 4) {\n      let alpha = opacity[i]\n      this.colorOverTime[k+3] = alpha // glsl colorOverTime[1..].w\n      // this.useTransparent = this.useTransparent || alpha < 1\n    }\n  },\n\n  updateRotationScaleOverTime() {\n    const maxSlots = this.data.overTimeSlots\n    let rotation = parseVecRangeArray(this.data.rotation, [0])\n    let scale = parseVecRangeArray(this.data.scale, [1])\n\n\n    if (rotation.length > maxSlots*2) rotation.length = maxSlots*2 // 2 rotations per range\n    if (scale.length > maxSlots*2) scale.length = maxSlots*2 // 2 scales per range\n\n    // first vec4 contains the lengths of the rotation and scale vectors\n    this.rotationScaleOverTime.fill(0)\n    this.rotationScaleOverTime[0] = rotation.length/2\n    this.rotationScaleOverTime[1] = scale.length/2\n\n    // set k to 2 because the first vec2 of rotationScaleOverTime is use for the length params\n    // update i by 1 becase rotation is 1 numbers per vector, and k by 2 because rotationScaleOverTime is 2 numbers per vector\n    let n = rotation.length\n    for (let i = 0, k = 2; i < n; i ++, k += 2) {\n      this.rotationScaleOverTime[k] = degToRad(rotation[i]) // glsl rotationScaleOverTime[1..].x\n    }\n\n    n = scale.length\n    for (let i = 0, k = 2; i < n; i++, k += 2) {\n      this.rotationScaleOverTime[k+1] = scale[i] // glsl rotationScaleOverTime[1..].y\n    }\n  },\n\n  updateVec4XYZRange(vecData, uniformAttr) {\n    const vecRange = parseVecRange(vecData, [0,0,0])\n    for (let i = 0, j = 0; i < vecRange.length; ) {\n      this[uniformAttr][j++] = vecRange[i++] // x\n      this[uniformAttr][j++] = vecRange[i++] // y\n      this[uniformAttr][j++] = vecRange[i++] // z\n      j++ // skip the w\n    }\n    return vecRange\n  },\n\n  updateAngularVec4XYZRange(vecData, uniformAttr) {\n    const vecRange = parseVecRange(vecData, [0,0,0])\n    for (let i = 0, j = 0; i < vecRange.length; ) {\n      this[uniformAttr][j++] = degToRad(vecRange[i++]) // x\n      this[uniformAttr][j++] = degToRad(vecRange[i++]) // y\n      this[uniformAttr][j++] = degToRad(vecRange[i++]) // z\n      j++ // skip the w\n    }\n  },\n\n  updateAngularVec2PartRange(vecData, def, uniformAttr, part) {\n    const vecRange = parseVecRange(vecData, def)\n    this[uniformAttr][part] = degToRad(vecRange[0])\n    this[uniformAttr][part + 2] = degToRad(vecRange[1])\n  },\n\n  // update just the w component\n  updateVec4WRange(floatData, def, uniformAttr) {\n    let floatRange = parseVecRange(floatData, def)\n    this[uniformAttr][3] = floatRange[0] // floatData value is packed into the 4th part of each vec4\n    this[uniformAttr][7] = floatRange[1]\n\n    return floatRange\n  },\n\n  updateBounds() {\n    const data = this.data\n    let maxAge = Math.max(this.lifeTime[0], this.lifeTime[1])\n    const STRIDE = 4\n    let extent = [new Array(STRIDE), new Array(STRIDE)] // extent[0] = min values, extent[1] = max values\n\n    if (data.drag > 0) {\n      maxAge = maxAge*(1 - .5*data.drag)\n    }\n\n    // Use offset, velocity and acceleration to determine the extents for the particles\n    for (let j = 0; j < 2; j++) { // index for extent\n      const compare = j === 0 ? Math.min: Math.max\n\n      for (let i = 0; i < STRIDE; i++) { // 0 = x, 1 = y, 2 = z, 3 = radial\n        const offset = compare(this.offset[i], this.offset[i + STRIDE])\n        const velocity = compare(this.velocity[i], this.velocity[i + STRIDE])\n        const acceleration = compare(this.acceleration[i], this.acceleration[i + STRIDE])\n\n        // extent at time tmax\n        extent[j][i] = offset + (velocity + 0.5 * acceleration * maxAge) * maxAge\n\n        // extent at time t0\n        extent[j][i] = compare(extent[j][i], offset)\n\n        // extent at turning point\n        const turningPoint = -velocity/acceleration\n        if (turningPoint > 0 && turningPoint < maxAge) {\n          extent[j][i] = compare(extent[j][i], offset - 0.5*velocity*velocity/acceleration)\n        }\n      }\n    }\n\n    // include the bounds the base model\n    if (this.modelBounds) {\n      extent[0][0] += this.modelBounds.min.x\n      extent[0][1] += this.modelBounds.min.y\n      extent[0][2] += this.modelBounds.min.z\n      extent[1][0] += this.modelBounds.max.x\n      extent[1][1] += this.modelBounds.max.y\n      extent[1][2] += this.modelBounds.max.z\n    }\n\n    // apply the radial extents to the XYZ extents\n    const domAttrs = this.el.getDOMAttribute(this.attrName)\n    const maxScale = this.rotationScaleOverTime.reduce((max, x, i) => (i & 1) ? Math.max(max, x) : max, 0) // scale is every second number\n    const maxRadial = Math.max(Math.abs(extent[0][3]), Math.abs(extent[1][3])) + data.particleSize*0.00045*maxScale\n    const isSphere = data.radialType === \"sphere\" || domAttrs.angularVelocity || domAttrs.angularAcceleration || domAttrs.orbitalVelocity || domAttrs.orbitalAcceleration\n\n    extent[0][0] -= maxRadial\n    extent[0][1] -= maxRadial\n    extent[0][2] -= isSphere ? maxRadial : 0\n    extent[1][0] += maxRadial\n    extent[1][1] += maxRadial\n    extent[1][2] += isSphere ? maxRadial : 0\n\n    // discard the radial element\n    extent[0].length = 3\n    extent[0].length = 3\n\n    // TODO include destination\n\n    const maxR = Math.max(...extent[0].map(Math.abs), ...extent[1].map(Math.abs))\n    if (!this.geometry.boundingSphere) {\n      this.geometry.boundingSphere = new THREE.Sphere()\n    }\n    this.geometry.boundingSphere.radius = maxR\n\n    if (!this.geometry.boundingBox) {\n      this.geometry.boundingBox = new THREE.Box3()\n    }\n    this.geometry.boundingBox.min.set(...extent[0])\n    this.geometry.boundingBox.max.set(...extent[1])\n\n    const existingMesh = this.el.getObject3D(\"mesh\")\n\n    // update any bounding boxes to the new bounds\n    if (existingMesh && existingMesh.isParticlesEditorObject) {\n      this.enableEditorObject(true)\n    }\n  },\n\n  updateDestinationEntity: (function() {\n    let dest = new THREE.Vector3()\n    let selfPos = new THREE.Vector3()\n\n    return function updateDestinationEntity() {\n      const data = this.data\n\n      data.destination.object3D.getWorldPosition(dest)\n      this.el.object3D.getWorldPosition(selfPos)\n      dest.sub(selfPos)\n\n      // this.destination is a vec4, this.destinationOffset is a vec3\n      for (let i = 0, n = AXES_NAMES.length; i < n; i++) {\n        this.destination[i] = dest[AXES_NAMES[i]] + this.destinationOffset[i] // min part of range\n        this.destination[i + 4] = dest[AXES_NAMES[i]] + this.destinationOffset[i + 3] // max part of range\n      }\n    }\n  })(),\n\n  enableEditorObject(enable) {\n    const existingMesh = this.el.getObject3D(\"mesh\")\n\n    if (enable && (!existingMesh || existingMesh.isParticlesEditorObject)) {\n      const BOX_SIZE = 0.25\n      const maxBound = new THREE.Vector3(BOX_SIZE, BOX_SIZE, BOX_SIZE).max(this.geometry.boundingBox.max)\n      const minBound = new THREE.Vector3(-BOX_SIZE, -BOX_SIZE, -BOX_SIZE).min(this.geometry.boundingBox.min)\n      let box3 = new THREE.Box3(minBound, maxBound)\n      let box3Mesh = new THREE.Box3Helper(box3, 0x808000)\n      box3Mesh.isParticlesEditorObject = true\n      box3Mesh.visible = false\n      this.el.setObject3D(\"mesh\", box3Mesh) // the inspector puts a bounding box around the \"mesh\" object\n    } else if (!enable && existingMesh && existingMesh.isParticlesEditorObject) {\n      this.el.removeObject3D(\"mesh\")\n    }\n  },\n\n  updateAttributes() {\n    if (this.geometry) {\n      const n = this.count\n\n      let vertexIDs = new Float32Array(n)\n      if (this.startDisabled || this.data.delay > 0 || this.data.model) {\n        vertexIDs.fill(-1)\n\n        this.numEnabled = 0\n        this.numDisabled = n  \n      } else {\n        for (let i = 0; i < n; i++) {\n          vertexIDs[i] = i\n        }\n\n        this.numEnabled = n\n        this.numDisabled = 0\n      }\n\n      this.geometry.addAttribute(\"vertexID\", new THREE.Float32BufferAttribute(vertexIDs, 1)) // gl_VertexID is not supported, so make our own id\n      this.geometry.addAttribute(\"position\", new THREE.Float32BufferAttribute(new Float32Array(n*3).fill(0), 3))\n\n      if (this.data.source) {\n        this.geometry.addAttribute(\"quaternion\", new THREE.Float32BufferAttribute(new Float32Array(n*4).fill(0), 4))\n      }\n\n      // the ribbons are presented as triangle strips, so each vert pairs with it's two previous verts to\n      // form a triangle.  To ensure each particle ribbon is not connected to other ribbons we place each\n      // one in a group containing only the verts for that ribbon\n      if (this.isRibbon()) {\n        this.geometry.clearGroups()\n\n        const m = this.trailCount * VERTS_PER_RIBBON\n        for (let i = 0; i < n; i += m) {\n          this.geometry.addGroup(i, m, 0)\n        }\n      }\n    }\n  },\n\n  // to get the fastest shader possible we remove unused glsl code via #if defined(USE_...) clauses,\n  // with each clause matching to one or more component attributes. updateDefines() maps each \n  // attribute to its equivalent USE_... define, and determines if any defines have changed.\n  // If a define has changed and we are playing we generate an error, otherwise (i.e. in the Inspector)\n  // we update the material and rebuild the shader program\n  updateDefines() {\n    const data = this.data\n    const domAttrs = Object.keys(this.el.getDOMAttribute(this.attrName))\n    const domDefines = domAttrs.map(a => ATTR_TO_DEFINES[a]).filter(b => b)\n\n    let defines = {\n      PARAMS_LENGTH,\n      OVER_TIME_ARRAY_LENGTH: this.overTimeArrayLength,\n      RANDOM_REPEAT_COUNT,\n      USE_MAP: true,\n    }\n    for (key of domDefines) {\n      defines[key] = true\n    }\n\n    if (data.velocityScale > 0) {\n      defines.USE_PARTICLE_VELOCITY_SCALE = true\n    }\n\n    if (data.trailInterval > 0) {\n      if (this.isRibbon()) {\n        if (data.trailType === \"ribbon\") {\n          defines.USE_RIBBON_TRAILS = true\n        } else {\n          defines.USE_RIBBON_3D_TRAILS = true\n        }\n      }\n      else {\n        defines.USE_PARTICLE_TRAILS = true\n      }\n    }\n\n    if (data.randomizeFrames) {\n      defines.USE_PARTICLE_RANDOMIZE_FRAMES = true\n    }\n\n    if (domAttrs.includes(\"rotation\")) {\n      if (this.isRibbon()) {\n        defines.USE_RIBBON_ROTATION = true\n      } else {\n        defines.USE_PARTICLE_ROTATION = true\n      }\n    }\n\n    let ribbonShapeFunction = \"1.\"\n    if (data.ribbonShape === \"taperout\") {\n      ribbonShapeFunction = \"1. - p\"\n    } else if (data.ribbonShape === \"taperin\") {\n      ribbonShapeFunction = \"p\"\n    } else if (data.ribbonShape === \"taper\") {\n      ribbonShapeFunction = \"2. * ( p < .5 ? p : 1. - p )\"\n    } else if (data.ribbonShape[0] === \"=\") {\n      ribbonShapeFunction = data.ribbonShape.slice(1)\n    }\n    defines.RIBBON_SHAPE_FUNCTION = ribbonShapeFunction\n\n    if (data.source) {\n      defines.PARTICLE_ORDER = 2\n    } else {\n      defines.PARTICLE_ORDER = PARTICLE_ORDER_STRINGS.indexOf(data.particleOrder)\n    }\n    defines.PARTICLE_TRAIL_ORDER = PARTICLE_ORDER_STRINGS.indexOf(data.particleOrder)\n\n    const extraDefines = Object.keys(defines).filter(b => this.material.defines[b] !== defines[b])\n\n    if (extraDefines.length > 0) {\n      if (this.isPlaying) {\n        const extraAttrs = domAttrs.filter(a => {\n          const b = ATTR_TO_DEFINES[a]\n          return b && !this.material.defines[b]\n        })\n        console.error(`cannot add attributes (${extraAttrs.join(\",\")}) at run-time`)\n      } else {\n        this.material.defines = defines\n        this.material.needsUpdate = true\n      }\n    }\n  },\n\n  updateModelMesh(mesh) {\n    if (!mesh) { return }\n\n    this.modelBounds = new THREE.Box3()\n    this.modelVertices\n    let offset = 0\n    let numFloats = 0\n    let stage = 0\n\n    const parseModel = (obj3D) => {\n      if (!obj3D.geometry) { return }\n\n      let positions = obj3D.geometry.getAttribute(\"position\")\n      if (positions && positions.itemSize !== 3) { return } // some text geometry uses 2D positions \n\n      if (stage == 0) {\n        numFloats += positions.array.length\n      } else {\n        this.modelVertices.set(positions.array, offset)\n        offset += positions.array.length\n      }\n    }\n\n    stage = 0\n    mesh.traverse(parseModel)\n\n    if (numFloats > 0) {\n      stage = 1\n      this.modelVertices = new Float32Array(numFloats)\n      mesh.traverse(parseModel)\n\n      applyScale(this.modelVertices, mesh.el.object3D.scale)\n\n      this.modelBounds.setFromArray(this.modelVertices)\n      this.updateBounds()\n    }\n  },\n\n  updateWorldTransform: (function() {\n    let position = new THREE.Vector3()\n    let quaternion = new THREE.Quaternion()\n    let scale = new THREE.Vector3()\n    let modelPosition = new THREE.Vector3()\n    let m4 = new THREE.Matrix4()\n\n    return function(emitterTime) {\n      const data = this.data\n      const n = this.count\n\n      // for particles using a source the CPU sets the instancePosition and instanceQuaternion\n      // of the new particles to the current object3D position/orientation, and tells the GPU\n      // the ID of last emitted particle (this.params[ID_PARAM])\n      const spawnRate = this.data.spawnRate\n      const isBurst = data.spawnType === \"burst\"\n      const spawnDelta = isBurst ? 0 : 1/spawnRate // for burst particles spawn everything at once\n      const isEnableDisable = data.enable ? this.numEnabled < n : this.numDisabled < n\n      const hasSource = data.source && data.source.object3D != null\n      const isUsingModel = this.modelVertices && this.modelVertices.length\n      const isRibbon = this.isRibbon()\n      const isIDUnique = isUsingModel || hasSource\n\n      let particleVertexID = this.geometry.getAttribute(\"vertexID\")\n      let particlePosition = this.geometry.getAttribute(\"position\")\n      let particleQuaternion = this.geometry.getAttribute(\"quaternion\")\n\n      if (hasSource) {\n        this.el.object3D.updateMatrixWorld()\n        data.source.object3D.updateMatrixWorld()\n\n        // get source matrix in our local space\n        m4.getInverse(this.el.object3D.matrixWorld)\n        m4.multiply(data.source.object3D.matrixWorld)\n        m4.decompose(position, quaternion, scale)\n        this.geometry.boundingSphere.center.copy(position)\n      }\n\n      let startIndex = this.nextID % n\n      let numSpawned = 0 // number of particles and/or trails\n      let index = startIndex\n      let id = this.nextID\n\n      modelFillFn = randomPointInTriangle\n      switch (data.modelFill) {\n        case \"edge\": modelFillFn = randomPointOnTriangleEdge; break\n        case \"vertex\": modelFillFn = randomVertex; break\n      }\n\n      // the nextTime represents the startTime for each particle, so while the nextTime\n      // is less than this frame's time, keep emitting particles. Note, if the spawnRate is\n      // low, we may have to wait several frames before a particle is emitted, but if the \n      // spawnRate is high we will emit several particles per frame\n      while (this.nextTime < emitterTime && numSpawned < this.count) {\n\n        if (isUsingModel) {\n          modelFillFn(this.modelVertices, modelPosition)\n        }\n\n        // for each particle, update all of its trails. if there are no trails, then\n        // trailcount is 1\n        for (let particleVert = 0, particleVertCount = isRibbon ? VERTS_PER_RIBBON : 1; particleVert < particleVertCount; particleVert++ ) {\n          for (let trail = 0; trail < this.trailCount; trail++) {\n            id = this.nextID\n\n            if (isUsingModel) {\n              particlePosition.setXYZ(index, modelPosition.x, modelPosition.y, modelPosition.z)\n            }\n  \n            if (hasSource) {\n              particlePosition.setXYZ(index, position.x, position.y, position.z)\n              particleQuaternion.setXYZW(index, quaternion.x, quaternion.y, quaternion.z, quaternion.w)\n            }\n  \n            particleVertexID.setX(index, data.enable ? id : -1) // id is unique and is tied to position and quaternion\n  \n            if (isEnableDisable) {\n              // if we're enabled then increase the number of enabled and reset the number disabled, once we \n              // reach this.numEnabled === n, all IDs would have been set and isEnableDisable will switch to false.\n              // vice versa if we are disabled. these numbers represent the number of consecutive enables or disables.\n              this.numEnabled = data.enable ? this.numEnabled + 1 : 0\n              this.numDisabled = data.enable ? 0 : this.numDisabled + 1\n            }  \n\n            index = (index + 1) % n\n            numSpawned++\n\n            if (isIDUnique) {\n              this.nextID++\n            } else {\n              this.nextID = index // wrap around to 0 if we'd emitted the last particle in our stack\n            }\n          }\n        }\n\n        this.nextTime += spawnDelta\n      }\n\n      if (numSpawned > 0) {\n        const trailVertCount = this.trailCount * (isRibbon ? VERTS_PER_RIBBON : 1)\n        this.params[ID_PARAM] = Math.floor(id/trailVertCount) // particle ID\n\n        if (isBurst) { // if we did burst emit, then wait for maxAge before emitting again\n          this.nextTime += this.lifeTime[1]\n          if (data.trailInterval > 0) { \n            this.nextTime += this.trailLifeTime[1]\n          }\n        }\n\n        // if the buffer was wrapped, we cannot send just the end and beginning of a buffer, so submit everything\n        if (index < startIndex) {\n          startIndex = 0\n          numSpawned = this.count\n        }\n\n        if (hasSource || isUsingModel) {\n          particlePosition.updateRange.offset = startIndex\n          particlePosition.updateRange.count = numSpawned\n          particlePosition.needsUpdate = true\n        }\n\n        if (hasSource) {\n          particleQuaternion.updateRange.offset = startIndex\n          particleQuaternion.updateRange.count = numSpawned\n          particleQuaternion.needsUpdate = true\n        }\n\n        // if (changeIDs) {\n          particleVertexID.updateRange.offset = startIndex\n          particleVertexID.updateRange.count = numSpawned\n          particleVertexID.needsUpdate = true\n        // }\n\n        // this will cause a glitch in the appearance as we reset the IDs to prevent them from overflowing\n        this.nextID = this.nextID % RANDOM_REPEAT_COUNT\n      }\n    }\n  })(),\n})\n\nconst applyScale = (vertices, scale) => {\n  if (scale.x !== 1 && scale.y !== 1 && scale.z !== 1) {\n    for (let i = 0, n = vertices.length; i < n; i+=3) {\n      vertices[i] *= scale.x\n      vertices[i+1] *= scale.y\n      vertices[i+2] *= scale.z\n    }\n  }\n}\n\nconst randomPointInTriangle = (function() {\n  let v1 = new THREE.Vector3()\n  let v2 = new THREE.Vector3()\n\n  // see http://mathworld.wolfram.com/TrianglePointPicking.html\n  return function randomPointInTriangle(vertices, pos) {\n    // assume each set of 3 vertices (each vertex has 3 floats) is a triangle\n    let triangleOffset = Math.floor(Math.random()*vertices.length/9)*9\n    v1.fromArray(vertices, triangleOffset)\n    v2.fromArray(vertices, triangleOffset + 3)\n    pos.fromArray(vertices, triangleOffset + 6)\n\n    let r1, r2\n    do {\n      r1 = Math.random()\n      r2 = Math.random()\n    } while (r1 + r2 > 1) // discard points outside of the triangle\n\n    v2.sub(v1).multiplyScalar(r1)\n    pos.sub(v1).multiplyScalar(r2).add(v2).add(v1)\n  }  \n})()\n\nconst randomPointOnTriangleEdge = (function() {\n  let v1 = new THREE.Vector3()\n  let v2 = new THREE.Vector3()\n  let v3 = new THREE.Vector3()\n\n  return function randomPointOnTriangleEdge(vertices, pos) {\n    // assume each set of 3 vertices (each vertex has 3 floats) is a triangle\n    let triangleOffset = Math.floor(Math.random()*vertices.length/9)*9\n    v1.fromArray(vertices, triangleOffset)\n    v2.fromArray(vertices, triangleOffset + 3)\n    v3.fromArray(vertices, triangleOffset + 6)\n    r1 = Math.random()\n    if (r1 > 2/3) {\n      pos.copy(v1).sub(v3).multiplyScalar(r1*3 - 2).add(v3)\n    } else if (r1 > 1/3) {\n      pos.copy(v3).sub(v2).multiplyScalar(r1*3 - 1).add(v2)\n    } else {\n      pos.copy(v2).sub(v1).multiplyScalar(r1*3).add(v1)\n    }\n  }  \n})()\n\nfunction randomVertex(vertices, pos) {\n  let index = Math.floor(Math.random()*vertices.length/3)*3\n  pos.fromArray(vertices, index)\n}\n\n// based upon https://github.com/mrdoob/three.js/blob/master/src/renderers/shaders/ShaderLib/points_vert.glsl\nconst particleVertexShader = `\n#include <common>\n// #include <color_pars_vertex>\n#include <fog_pars_vertex>\n// #include <morphtarget_pars_vertex>\n// #include <logdepthbuf_pars_vertex>\n// #include <clipping_planes_pars_vertex>\n\nattribute float vertexID;\n\n#if defined(USE_PARTICLE_SOURCE)\nattribute vec4 quaternion;\n#endif\n\nuniform vec4 params[PARAMS_LENGTH];\nuniform vec4 offset[2];\nuniform vec4 velocity[2];\nuniform vec4 acceleration[2];\nuniform vec4 angularVelocity[2];\nuniform vec4 angularAcceleration[2];\nuniform vec2 orbital[2];\nuniform vec4 colorOverTime[OVER_TIME_ARRAY_LENGTH];\nuniform vec2 rotationScaleOverTime[OVER_TIME_ARRAY_LENGTH];\nuniform vec4 textureFrames;\nuniform vec3 velocityScale;\nuniform vec4 destination[2];\n\nvarying vec4 vParticleColor;\nvarying vec2 vCosSinRotation;\nvarying vec2 vUv;\nvarying float vOverTimeRatio;\nvarying float vFrame;\n\nfloat VERTS_PER_RIBBON = 2.;\n\n// alternative random algorithm, used for the initial seed.  Provides a better\n// result than using rand()\nfloat pseudoRandom( const float seed )\n{\n  return mod( 1664525.*seed + 1013904223., 4294967296. )/4294967296.; // we don't have enough precision in 32-bit float, but results look ok\n}\n\n// each call to random will produce a different result by varying randI\nfloat randI = 0.;\nfloat random( const float seed )\n{\n  randI += 0.001;\n  return rand( vec2( seed, randI ));\n}\n\nvec3 randVec3Range( const vec3 range0, const vec3 range1, const float seed )\n{\n  vec3 lerps = vec3( random( seed ), random( seed ), random( seed ) );\n  return mix( range0, range1, lerps );\n}\n\nvec2 randVec2Range( const vec2 range0, const vec2 range1, const float seed )\n{\n  vec2 lerps = vec2( random( seed ), random( seed ) );\n  return mix( range0, range1, lerps );\n}\n\nfloat randFloatRange( const float range0, const float range1, const float seed )\n{\n  float lerps = random( seed );\n  return mix( range0, range1, lerps );\n}\n\n// theta.x is the angle in XY, theta.y is the angle in XZ\nvec3 radialToVec3( const float r, const vec2 theta )\n{\n  vec2 cosTheta = cos(theta);\n  vec2 sinTheta = sin(theta);\n  float rc = r * cosTheta.x;\n  float x = rc * cosTheta.y;\n  float y = r * sinTheta.x;\n  float z = rc * sinTheta.y;\n  return vec3( x, y, z );\n}\n\n// array lengths are stored in the first slot, followed by actual values from slot 1 onwards\n// colors are packed min,max,min,max,min,max,...\n// color is packed in xyz and opacity in w, and they may have different length arrays\n\nvec4 calcColorOverTime( const float r, const float seed )\n{\n  vec3 color = vec3(1.);\n  float opacity = 1.;\n\n#if defined(USE_PARTICLE_COLOR)\n  int colorN = int( colorOverTime[0].x );\n  if ( colorN == 1 )\n  {\n    color = randVec3Range( colorOverTime[1].xyz, colorOverTime[2].xyz, seed );\n  }\n  else if ( colorN > 1 )\n  {\n    float ck = r * ( float( colorN ) - 1. );\n    float ci = floor( ck );\n    int i = int( ci )*2 + 1;\n    vec3 sColor = randVec3Range( colorOverTime[i].xyz, colorOverTime[i + 1].xyz, seed );\n    vec3 eColor = randVec3Range( colorOverTime[i + 2].xyz, colorOverTime[i + 3].xyz, seed );\n    color = mix( sColor, eColor, ck - ci );\n  }\n#endif\n\n#if defined(USE_PARTICLE_OPACITY)\n  int opacityN = int( colorOverTime[0].y );\n  if ( opacityN == 1 )\n  {\n    opacity = randFloatRange( colorOverTime[1].w, colorOverTime[2].w, seed );\n  }\n  else if ( opacityN > 1 )\n  {\n    float ok = r * ( float( opacityN ) - 1. );\n    float oi = floor( ok );\n    int j = int( oi )*2 + 1;\n    float sOpacity = randFloatRange( colorOverTime[j].w, colorOverTime[j + 1].w, seed );\n    float eOpacity = randFloatRange( colorOverTime[j + 2].w, colorOverTime[j + 3].w, seed );\n    opacity = mix( sOpacity, eOpacity, ok - oi );\n  }\n#endif\n\n  return vec4( color, opacity );\n}\n\n// as per calcColorOverTime but euler rotation is packed in xyz and scale in w\n\nvec2 calcRotationScaleOverTime( const float r, const float seed )\n{\n  float rotation = 0.;\n  float scale = 1.;\n\n#if defined(USE_PARTICLE_ROTATION) || defined(USE_RIBBON_ROTATION)\n  int rotationN = int( rotationScaleOverTime[0].x );\n  if ( rotationN == 1 )\n  {\n    rotation = randFloatRange( rotationScaleOverTime[1].x, rotationScaleOverTime[2].x, seed );\n  }\n  else if ( rotationN > 1 )\n  {\n    float rk = r * ( float( rotationN ) - 1. );\n    float ri = floor( rk );\n    int i = int( ri )*2 + 1; // *2 because each range is 2 vectors, and +1 because the first vector is for the length info\n    float sRotation = randFloatRange( rotationScaleOverTime[i].x, rotationScaleOverTime[i + 1].x, seed );\n    float eRotation = randFloatRange( rotationScaleOverTime[i + 2].x, rotationScaleOverTime[i + 3].x, seed );\n    rotation = mix( sRotation, eRotation, rk - ri );\n  }\n#endif\n\n#if defined(USE_PARTICLE_SCALE)\n  int scaleN = int( rotationScaleOverTime[0].y );\n  if ( scaleN == 1 )\n  {\n    scale = randFloatRange( rotationScaleOverTime[1].y, rotationScaleOverTime[2].y, seed );\n  }\n  else if ( scaleN > 1 )\n  {\n    float sk = r * ( float( scaleN ) - 1. );\n    float si = floor( sk );\n    int j = int( si )*2 + 1; // *2 because each range is 2 vectors, and +1 because the first vector is for the length info\n    float sScale = randFloatRange( rotationScaleOverTime[j].y, rotationScaleOverTime[j + 1].y, seed );\n    float eScale = randFloatRange( rotationScaleOverTime[j + 2].y, rotationScaleOverTime[j + 3].y, seed );\n    scale = mix( sScale, eScale, sk - si );\n  }\n#endif\n\n  return vec2( rotation, scale );\n}\n\n// assumes euler order is YXZ (standard convention for AFrame)\nvec4 eulerToQuaternion( const vec3 euler )\n{\n  // from https://github.com/mrdoob/three.js/blob/master/src/math/Quaternion.js\n\n  vec3 c = cos( euler * .5 );\n  vec3 s = sin( euler * .5 );\n\n  return vec4(\n    s.x * c.y * c.z + c.x * s.y * s.z,\n    c.x * s.y * c.z - s.x * c.y * s.z,\n    c.x * c.y * s.z - s.x * s.y * c.z,\n    c.x * c.y * c.z + s.x * s.y * s.z\n  );\n}\n\n// from http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm\nvec4 axisAngleToQuaternion( const vec3 axis, const float angle ) \n{\n  return vec4( axis * sin( angle*.5 ), cos( angle*.5 ) );\n}\n\nvec3 applyQuaternion( const vec3 v, const vec4 q )\n{\n  return v + 2. * cross( q.xyz, cross( q.xyz, v ) + q.w * v );\n}\n\nvec3 displacement( const vec3 v, const vec3 a, const float t )\n{\n  return (v + 0.5 * a * t) * t;\n}\n\nfloat displacement1D( const float v, const float a, const float t )\n{\n  return (v + 0.5 * a * t) * t;\n}\n\nfloat ribbonShape( const float p )\n{\n  return RIBBON_SHAPE_FUNCTION;\n}\n\nvec3 particleMotion( const vec3 p, const vec3 v, const vec3 a, const vec3 av, const vec3 aa, const vec3 axis, const float ov, const float oa, const vec3 dest, const float weight, const float t )\n{\n  vec3 pos = p + displacement(v, a, t);\n\n#if defined(USE_PARTICLE_ANGULAR_VELOCITY) || defined(USE_PARTICLE_ANGULAR_ACCELERATION)\n  pos = applyQuaternion( pos, eulerToQuaternion( displacement(av, aa, t) ) );\n#endif\n\n#if defined(USE_PARTICLE_ORBITAL)\n  pos = applyQuaternion( pos, axisAngleToQuaternion( axis, displacement1D(ov, oa, t) ) );\n#endif\n\n#if defined(USE_PARTICLE_SOURCE)\n  pos = applyQuaternion( pos, quaternion );\n#endif\n\npos += position;\n\n#if defined(USE_PARTICLE_DESTINATION)\n  pos = mix( pos, dest, weight );\n#endif\n\n  return pos;\n}\n\nvec2 toScreen( const vec4 clipSpacePos )\n{\n  return clipSpacePos.xy / clipSpacePos.w;\n}\n\nvoid main() {\n\n  float time = params[0].x;\n  float cpuID = params[0].y;\n  float radialTypeX = params[0].z;\n  float radialTypeY = params[4].w;\n  float duration = params[0].w;\n  float spawnType = params[1].x;\n  float spawnRate = params[1].y;\n  float baseSeed = params[1].z;\n  float vertexCount = params[1].w;\n  float direction = params[2].z; // 0 is forward, 1 is backward  \n  float trailInterval = params[3].x;\n  float particleCount = params[3].y;\n  float trailCount = params[3].z;\n  float maxParticleLifeTime = angularVelocity[1].w; // lifeTime packed into w component of angularVelocity\n  float maxTrailLifeTime = angularAcceleration[1].w; // trailLifeTime packed into angularAcceleration.w\n  float particleLoopTime = particleCount / spawnRate;\n  float motionAge = -1.; // used to determine the age for particle movement\n\n#if defined(USE_PARTICLE_TRAILS) || defined(USE_RIBBON_TRAILS) || defined(USE_RIBBON_3D_TRAILS)\n  float maxAge = maxParticleLifeTime + maxTrailLifeTime;\n#else\n  float maxAge = maxParticleLifeTime;\n#endif\n\n  // the CPU manages IDs if it sets the position or disables particles, otherwise cpuID is -1\n  float particleID0 = cpuID > -EPSILON ? cpuID : floor( mod( time, particleLoopTime ) * spawnRate ); // this will lose precision eventually\n\n  vOverTimeRatio = -1.; // the vOverTimeRatio will be used for the lerps on over-time attributes\n\n  // particles are either emitted in a burst (spawnType == 0) or spread evenly\n  // throughout 0..particleLoopTime (spawnType == 1).  We calculate the ID of the last spawned particle particleID0 \n  // for this frame, any vertex IDs after particleID0 are assumed to belong to the previous loop\n\n  // vertex 0 = trail0 of particle0, vertex 1 = trail1 of particle0, ..., vertex k = trail0 of particle1, ...\n#if defined(USE_RIBBON_TRAILS) || defined(USE_RIBBON_3D_TRAILS)\n  float rawParticleID = floor( vertexID / VERTS_PER_RIBBON / trailCount );\n#else\n  float rawParticleID = floor( vertexID / trailCount );\n#endif\n\n  float particleLoop = floor( time / particleLoopTime );\n\n#if defined(USE_PARTICLE_SOURCE)\n  // find particleID relative to the last loop\n  float particleID = rawParticleID - floor( particleID0 / particleCount ) * particleCount;\n#else // defined(USE_PARTICLE_SOURCE)\n\n#if PARTICLE_ORDER == 0\n  float particleID = particleID0 - (particleCount - 1. - rawParticleID); // newest last\n#elif PARTICLE_ORDER == 1\n  float particleID = particleID0 - rawParticleID; // oldest last\n#else\n  float particleID = rawParticleID > particleID0 ? rawParticleID - particleCount : rawParticleID; // cyclic (original)\n#endif\n\n#endif // defined(USE_PARTICLE_SOURCE)\n\n  // for burst mode we use the rawParticleID, because the concept of particleID0 is irrelevant\n  particleID = mix( rawParticleID, particleID, spawnType ); \n\n  float particleStartTime = particleLoop * particleLoopTime + particleID / spawnRate * spawnType;\n\n  // we use the id as a seed for the randomizer, but because the IDs are fixed in \n  // the range 0..particleCount we calculate a virtual ID by taking into account\n  // the number of loops that have occurred (note, particles from the previous \n  // loop will have a negative particleID). We use the modoulo of the RANDOM_REPEAT_COUNT \n  // to ensure that the virtualID doesn't exceed the floating point precision\n\n  float virtualID = mod( particleID + particleLoop * particleCount, float( RANDOM_REPEAT_COUNT ) );\n  float seed = pseudoRandom( virtualID*baseSeed*110. );\n\n  float particleLifeTime = randFloatRange( angularVelocity[0].w, angularVelocity[1].w, seed );\n\n  float particleAge = time - particleStartTime;\n  particleAge = particleAge + direction * ( particleLoopTime - 2. * particleAge );\n\n  // don't show particles that would be emitted after the duration\n  if ( duration > 0. && time - particleAge >= duration ) \n  {\n    particleAge = -1.;\n  } \n\n  // always calculate the trailLifeTime, even if we don't use it, so the particles\n  // with the same seed give consistent results\n  float trailLifeTime = randFloatRange( angularAcceleration[0].w, angularAcceleration[1].w, seed );\n\n#if defined(USE_PARTICLE_TRAILS)\n\n  // +1 beceause we show both the lead particle and the first trail at the start\n  // we cap the particleAge to ensure it never goes past the particleLifeTime\n  float cappedParticleAge = min( particleLifeTime - trailInterval, particleAge );\n  float trailID0 = floor( cappedParticleAge / trailInterval ) + 1.;\n  float rawTrailID = mod( vertexID, trailCount );\n\n#if PARTICLE_TRAIL_ORDER == 0\n  float trailID = trailID0 - ( trailCount - 1. - rawTrailID ); // newest last\n#elif PARTICLE_TRAIL_ORDER == 1\n  float trailID = trailID0 - rawTrailID; // oldest last\n#else\n  float trailID = floor( trailID0 / trailCount ) * trailCount;\n  trailID += rawTrailID > mod( trailID0, trailCount ) ? rawTrailID - trailCount : rawTrailID; // cyclic (original)\n#endif\n\n  float trailStartAge = trailID * trailInterval;\n  \n  if (particleAge > -EPSILON && trailStartAge > -EPSILON && trailStartAge < particleLifeTime + EPSILON)\n  {\n    if (particleAge < trailStartAge)\n    {\n      motionAge = particleAge;\n      vOverTimeRatio = 0.;\n    }\n    else if (particleAge < trailStartAge + trailLifeTime)\n    {\n      motionAge = trailStartAge;\n      vOverTimeRatio = (particleAge - trailStartAge)/trailLifeTime;\n    }\n  }\n\n#elif defined(USE_RIBBON_TRAILS) || defined(USE_RIBBON_3D_TRAILS)\n\n  // +1 to the trailID0 because the ribbon needs two elements to start\n  // we cap the particleAge to ensure it never goes past the particleLifeTime\n  float cappedParticleAge = min( particleLifeTime - trailInterval, particleAge );\n  float trailID0 = floor( cappedParticleAge / trailInterval ) + 1.;\n  float rawTrailID = floor( mod( vertexID / VERTS_PER_RIBBON, trailCount ) );\n  float trailID = max( 0., trailID0 - ( trailCount - 1. - rawTrailID ) ); // newest last\n\n  float trailStartAge = trailID * trailInterval;\n\n  if (particleAge > -EPSILON && trailStartAge > -EPSILON && trailStartAge < particleLifeTime + EPSILON)\n  {\n    // motionAge will typically be the trailStartAge, but the lead particle will be the \n    // cappedParticleAge, and the last particle will be the particleAge - trailLifeTime\n\n    motionAge = min( cappedParticleAge, max( particleAge - trailLifeTime, trailStartAge ) );\n    vOverTimeRatio = ( particleAge - motionAge ) / trailLifeTime;\n  }\n  else\n  {\n    motionAge = particleLifeTime;\n    vOverTimeRatio = 1.0;\n  }\n\n#else // defined(USE_PARTICLE_TRAILS) || defined(USE_RIBBON_TRAILS) || defined(USE_RIBBON_3D_TRAILS)\n\n  motionAge = particleAge;\n  vOverTimeRatio = particleAge/particleLifeTime;\n\n#endif // defined(USE_PARTICLE_TRAILS) || defined(USE_RIBBON_TRAILS) || defined(USE_RIBBON_3D_TRAILS)\n\n  // these checks were around large blocks of code above, but this caused instability\n  // in some of the particle systems, so instead we do all of the work, then cancel \n  // it out here\n  if ( particleStartTime < 0. || vertexID < 0. )\n  {\n    vOverTimeRatio = -1.;\n  }\n\n#if defined(USE_PARTICLE_DRAG)\n  // simulate drag by blending the motionAge to (1-.5*drag)*particleLifeTime\n  float drag = params[2].w;\n  motionAge = mix( .5*drag*vOverTimeRatio, 1. - .5*drag, vOverTimeRatio ) * particleLifeTime;\n#endif\n\n  vec3 p = vec3(0.); // position\n  vec3 v = vec3(0.); // velocity\n  vec3 a = vec3(0.); // acceleration\n  vec3 av = vec3(0.); // angular velocity\n  vec3 aa = vec3(0.); // angular acceleration\n  vec3 axis = vec3( 1., 0., 0. ); // axis of orbital motion\n  float ov = 0.; // orbital velocity\n  float oa = 0.; // orbital acceleration\n  vec3 dest = vec3(0.); // destination position\n  float destWeight = 0.; // destination weighting\n\n#if defined(USE_PARTICLE_OFFSET)\n  p = randVec3Range( offset[0].xyz, offset[1].xyz, seed );\n#endif\n\n#if defined(USE_PARTICLE_VELOCITY)\n  v = randVec3Range( velocity[0].xyz, velocity[1].xyz, seed );\n#endif\n\n#if defined(USE_PARTICLE_ACCELERATION)\n  a = randVec3Range( acceleration[0].xyz, acceleration[1].xyz, seed );\n#endif\n\n#if defined(USE_PARTICLE_RADIAL_OFFSET) || defined(USE_PARTICLE_RADIAL_VELOCITY) || defined(USE_PARTICLE_RADIAL_ACCELERATION)\n  vec2 ANGLE_RANGE[2];\n  vec2 radialDir = vec2( radialTypeX, radialTypeY );\n  ANGLE_RANGE[0] = vec2( 0., 0. ) * radialDir;\n  ANGLE_RANGE[1] = vec2( 2.*PI, 2.*PI ) * radialDir;\n\n  vec2 theta = randVec2Range( ANGLE_RANGE[0], ANGLE_RANGE[1], seed );\n#endif\n\n#if defined(USE_PARTICLE_RADIAL_OFFSET)\n  float pr = randFloatRange( offset[0].w, offset[1].w, seed );\n  vec3 p2 = radialToVec3( pr, theta );\n  p += p2;\n#endif\n\n#if defined(USE_PARTICLE_RADIAL_VELOCITY)\n  float vr = randFloatRange( velocity[0].w, velocity[1].w, seed );\n  vec3 v2 = radialToVec3( vr, theta );\n  v += v2;\n#endif\n\n#if defined(USE_PARTICLE_RADIAL_ACCELERATION)\n  float ar = randFloatRange( acceleration[0].w, acceleration[1].w, seed );\n  vec3 a2 = radialToVec3( ar, theta );\n  a += a2;\n#endif\n\n#if defined(USE_PARTICLE_ANGULAR_VELOCITY)\n  av = randVec3Range( angularVelocity[0].xyz, angularVelocity[1].xyz, seed );\n#endif\n\n#if defined(USE_PARTICLE_ANGULAR_ACCELERATION)\n  aa = randVec3Range( angularAcceleration[0].xyz, angularAcceleration[1].xyz, seed );\n#endif\n\n#if defined(USE_PARTICLE_ORBITAL)\n  if ( length(p) > EPSILON ) {\n    ov = randFloatRange( orbital[0].x, orbital[1].x, seed );\n    float oa = randFloatRange( orbital[0].y, orbital[1].y, seed );\n    float angle = displacement1D(ov, oa, motionAge);\n\n    vec3 randomOribit = vec3( random( seed ), random( seed ), random( seed ) ); // should never equal p or 0,0,0\n    axis = normalize( cross( normalize( p ), normalize( randomOribit ) ) );\n  }\n#endif\n\n#if defined(USE_PARTICLE_DESTINATION)\n  destWeight = randFloatRange( destination[0].w, destination[1].w, seed );\n  dest = randVec3Range( destination[0].xyz, destination[1].xyz, seed );\n#endif\n\n  vec3 transformed = particleMotion( p, v, a, av, aa, axis, ov, oa, dest, motionAge/particleLifeTime*destWeight, motionAge );\n\n  vec2 rotScale = calcRotationScaleOverTime( vOverTimeRatio, seed );\n  float particleScale = rotScale.y;\n  float c = cos( rotScale.x );\n  float s = sin( rotScale.x );\n\n  vParticleColor = calcColorOverTime( vOverTimeRatio, seed ); // rgba format\n\n#if defined(USE_PARTICLE_VELOCITY_SCALE)\n  // We repeat all of the displacement calculations at motionAge + a small amount (velocityScaleDelta).\n  // We convert the current position and the future position in screen space and determine\n  // the screen space velocity. VelocityScaleDelta is reasonably small to give better\n  // results for the angular and orbital displacement, and when drag is applied the effective\n  // velocity will tend to 0 as the vOverTimeRatio increases\n\n  float velocityScaleDelta = .02;\n\n#if defined(USE_PARTICLE_DRAG)\n  float futureT = motionAge + velocityScaleDelta*mix(1., 1. - drag, vOverTimeRatio);\n#else\n  float futureT = motionAge + velocityScaleDelta;\n#endif\n\n  vec4 pos2D = projectionMatrix * modelViewMatrix * vec4( transformed, 1. );\n\n  // use min(1) to ensure the particle stops at the destination position\n  vec3 transformedFuture = particleMotion( p, v, a, av, aa, axis, ov, oa, dest, min( 1., futureT/particleLifeTime )*destWeight, futureT );\n\n  vec4 pos2DFuture = projectionMatrix * modelViewMatrix * vec4( transformedFuture, 1. );\n\n  vec2 screen = pos2DFuture.xy / pos2DFuture.z - pos2D.xy / pos2D.z; // TODO divide by 0?\n  screen /= velocityScaleDelta; // gives screen units per second\n\n  float lenScreen = length( screen );\n  vec2 sinCos = vec2(screen.x, screen.y)/max( EPSILON, lenScreen); // 0 degrees is y == 1, x == 0\n  float c2 = c*sinCos.y + s*sinCos.x; // cos(a-b)\n  float s2 = s*sinCos.y - c*sinCos.x; // sin(a-b)\n\n  // replace rotation with our new rotation\n  c = c2;\n  s = s2;\n\n  // rescale the particle length by the z depth, because perspective will be applied later\n  float screenScale = clamp( lenScreen * pos2D.z * velocityScale.x, velocityScale.y, velocityScale.z );\n\n  particleScale *= screenScale;\n\n#endif // defined(USE_PARTICLE_VELOCITY_SCALE)\n\n  vCosSinRotation = vec2( c, s );\n\n  // #include <color_vertex>\n  // #include <begin_vertex> replaced by code above\n  // #include <morphtarget_vertex>\n  // #include <project_vertex> replaced below\n\n#if defined(USE_RIBBON_3D_TRAILS)\n  float ribbonID = mod( vertexID, VERTS_PER_RIBBON );\n  \n  {\n    float nextT = motionAge + trailInterval;\n    float ribbonWidth = params[4].x * ribbonShape( vOverTimeRatio );\n\n    vec3 nextPosition = particleMotion( p, v, a, av, aa, axis, ov, oa, dest, min( 1., nextT/particleLifeTime )*destWeight, nextT );\n    vec3 dir = nextPosition - transformed;\n    float dirLen = length( dir );\n\n    vec3 normal = dir;\n    vec3 up = vec3( 0., c, -s ); // rotation in YZ\n    if ( dirLen > EPSILON && abs( dot( dir, up ) ) < dirLen * 0.99 ) {\n      normal = normalize( cross( up, dir ) );\n    }\n\n    transformed += ribbonWidth * normal * ( 0.5 - ribbonID );  // +normal for ribbonID 0, -normal for ribbonID 1\n  }\n#endif\n\n  vec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );\n  gl_Position = projectionMatrix * mvPosition;\n\n  float usePerspective = params[2].y;\n\n#if defined(USE_RIBBON_TRAILS)\n  float ribbonID = mod( vertexID, VERTS_PER_RIBBON );\n  \n  {\n    mat4 m = projectionMatrix * modelViewMatrix;\n    vec2 curr = toScreen( gl_Position );\n\n    float nextT = motionAge + trailInterval;\n    vec3 nextPosition = particleMotion( p, v, a, av, aa, axis, ov, oa, dest, min( 1., nextT/particleLifeTime )*destWeight, nextT );\n    vec2 next2D = toScreen( m * vec4( nextPosition, 1. ) ) - curr;\n\n    vec2 dir = normalize( next2D );\n    vec2 normal = vec2( -dir.y, dir.x );\n\n    float ribbonWidth = params[4].x * ribbonShape( vOverTimeRatio );\n    float halfWidth = .5 * ribbonWidth * mix( 1., 1. / - mvPosition.z, usePerspective );\n  \n    gl_Position.xy += halfWidth * normal * ( 1. - ribbonID * 2. ); // +normal for ribbonID 0, -normal for ribbonID 1\n  }\n#endif\n\n#if defined(USE_PARTICLE_SCREEN_DEPTH_OFFSET)\n  float screenDepthOffset = params[3].w;\n\n#if defined(USE_PARTICLE_TRAILS) || defined(USE_RIBBON_TRAILS) || defined(USE_RIBBON_3D_TRAILS)\n  // multiply trailCount by 2 because trailID ranges from [-trailCount, trailCount]\n  gl_Position.z -= (particleID*trailCount*2. + trailID - trailID0)*gl_Position.w*screenDepthOffset/vertexCount;\n#else\n  gl_Position.z -= particleID*gl_Position.w*screenDepthOffset/vertexCount;\n#endif\n\n#endif // defined(USE_PARTICLE_SCREEN_DEPTH_OFFSET)\n\n// vFrame is an int, but we must pass it as a float, so add .5 now and floor() in the\n// fragment shader to ensure there is no rounding error\n#if defined(USE_PARTICLE_RANDOMIZE_FRAMES)\n  vFrame = floor ( random( seed ) * textureFrames.z ) + .5;\n#else\n  float textureCount = textureFrames.z;\n  float textureLoop = textureFrames.w;\n\n  vFrame = floor( mod( vOverTimeRatio * textureCount * textureLoop, textureCount ) ) + .5;\n#endif\n\n#if !defined(USE_RIBBON_TRAILS) && !defined(USE_RIBBON_3D_TRAILS)\n  float particleSize = params[2].x;\n\n  gl_PointSize = particleSize * particleScale * mix( 1., 1. / - mvPosition.z, usePerspective );\n#endif\n\n  // #include <logdepthbuf_vertex>\n  // #include <clipping_planes_vertex>\n  // #include <worldpos_vertex>\n  #include <fog_vertex>\n\n#if defined(USE_RIBBON_TRAILS) || defined(USE_RIBBON_3D_TRAILS)\n  float ribbonUVMultiplier = params[4].y;\n  float ribbonUVType = params[4].z;\n\n  vUv = vec2( mix( 1. - vOverTimeRatio, motionAge/trailInterval, ribbonUVType ) * ribbonUVMultiplier, 1. - ribbonID );\n#endif\n}`\n\n  // based upon https://github.com/mrdoob/three.js/blob/master/src/renderers/shaders/ShaderLib/points_frag.glsl\n  const particleFragmentShader = `\n#include <common>\n#include <packing>\n// #include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n// #include <logdepthbuf_pars_fragment>\n// #include <clipping_planes_pars_fragment>\n\nuniform vec4 textureFrames;\nuniform vec3 emitterColor;\n\nvarying vec4 vParticleColor;\nvarying vec2 vCosSinRotation;\nvarying vec2 vUv;\nvarying float vOverTimeRatio;\nvarying float vFrame;\n\nvoid main() {\n  if ( vOverTimeRatio < 0. || vOverTimeRatio > 1. ) {\n    discard;\n  }\n\n  #include <clipping_planes_fragment>\n\n  vec3 outgoingLight = vec3( 0. );\n  vec4 diffuseColor = vec4( emitterColor, 1. );\n  mat3 uvTransform = mat3( 1. );\n\n#if defined(USE_PARTICLE_ROTATION) || defined(USE_PARTICLE_FRAMES) || defined(USE_PARTICLE_VELOCITY_SCALE)\n  {\n    vec2 invTextureFrame = 1. / textureFrames.xy;\n    float textureCount = textureFrames.z;\n    float textureLoop = textureFrames.w;\n\n    float frame = floor(vFrame);\n    float c = vCosSinRotation.x;\n    float s = vCosSinRotation.y;\n    float tx = mod( frame, textureFrames.x ) * invTextureFrame.x;\n    float ty = (textureFrames.y - 1. - floor( frame * invTextureFrame.x )) * invTextureFrame.y; // assumes textures are flipped on y\n    float sx = invTextureFrame.x;\n    float sy = invTextureFrame.y;\n    float cx = tx + invTextureFrame.x * .5;\n    float cy = ty + invTextureFrame.y * .5;\n  \n    uvTransform[0][0] = sx * c;\n    uvTransform[0][1] = -sx * s;\n    uvTransform[1][0] = sy * s;\n    uvTransform[1][1] = sy * c;\n    uvTransform[2][0] = c * tx + s * ty - ( c * cx + s * cy ) + cx;\n    uvTransform[2][1] = -s * tx + c * ty - ( -s * cx + c * cy ) + cy;\n  }\n#endif // defined(USE_PARTICLE_ROTATION) || defined(USE_PARTICLE_FRAMES) || defined(USE_PARTICLE_VELOCITY_SCALE)\n\n  // #include <logdepthbuf_fragment>\n  // #include <map_particle_fragment>\n  // #include <color_fragment>\n\n#ifdef USE_MAP\n\n#if defined(USE_RIBBON_TRAILS) || defined(USE_RIBBON_3D_TRAILS)\n  vec2 uv = ( uvTransform * vec3( vUv, 1. ) ).xy;\n#else\n  vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1. ) ).xy;\n#endif\n\n  vec4 mapTexel = texture2D( map, uv );\n  diffuseColor *= mapTexelToLinear( mapTexel );\n#endif // USE_MAP\n\n  #include <alphatest_fragment>\n\n  diffuseColor *= vParticleColor;\n  outgoingLight = diffuseColor.rgb;\n\n  gl_FragColor = diffuseColor;\n\n  // #include <premultiplied_alpha_fragment>\n  // #include <tonemapping_fragment>\n  // #include <encodings_fragment>\n  #include <fog_fragment>\n}`\n\n\n\n//# sourceURL=webpack:///./src/aframe-sprite-particles-component.mjs?");

/***/ }),

/***/ "./src/aframe-timer-emit-component.mjs":
/*!*********************************************!*\
  !*** ./src/aframe-timer-emit-component.mjs ***!
  \*********************************************/
/*! no exports provided */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n// Copyright 2018-2019 harlyq\n// MIT license\n\nAFRAME.registerComponent(\"timer-emit\", {\n  schema: {\n    src: { type: \"selector\" },\n    target: { default: \"\" },\n    targetScope: { default: \"document\", oneOf: [\"document\", \"self\", \"parent\"] },\n    stopOnPause: { default: true },\n  },\n  multiple: true,\n\n  init() {\n    this.sendEvents = this.sendEvents.bind(this)\n    this.mediaEl = undefined\n    this.restartMedia = false\n    this.clockStartTime = Date.now()\n    this.targets = []\n  },\n\n  remove() {\n    this.removeListeners()\n  },\n\n  updateSchema(newData) {\n    const originalSchema = AFRAME.components[\"timer-emit\"].schema\n    let newSchema = {}\n\n    for (let key in newData) {\n      if (!(key in originalSchema)) {\n        newSchema[key] = { type: \"string\" } // key is the name of the event to send, and the value is a list of time stamps\n      }\n    }\n\n    if (Object.keys(newSchema).length > 0) {\n      this.extendSchema(newSchema)\n    }\n  },\n\n  pause() {\n    const data = this.data\n\n    this.removeListeners()\n\n    if (data.stopOnPause) {\n      this.pauseTime = Date.now() // used to pause the clock while in the Inspector\n      clearTimeout(this.sendEventsTimer)\n      this.sendEventsTimer = undefined\n\n      if (this.mediaEl && !this.mediaEl.paused) {\n        this.mediaEl.pause()\n        this.restartMedia = true\n      }\n    }\n  },\n\n  play() {\n    if (this.pauseTime) {\n      this.clockStartTime += Date.now() - this.pauseTime\n      delete this.pauseTime\n    }\n\n    if (this.mediaEl) {\n      this.addListeners()\n\n      if (this.restartMedia) {\n        this.mediaEl.play()\n        this.restartMedia = false\n      }\n    }\n\n    this.sendEvents()\n  },\n\n  update(oldData) {\n    const data = this.data\n    const originalSchema = AFRAME.components[\"timer-emit\"].schema\n\n    if (oldData.src !== data.src) {\n      this.removeListeners()\n      this.mediaEl = data.src instanceof HTMLMediaElement ? data.src : undefined\n    }\n\n    if (oldData.target !== data.target) {\n      this.targets = this.querySelectorAll(data.targetScope, data.target)\n    }\n\n    this.events = []\n\n    for (let attr in data) {\n      if (!(attr in originalSchema)) {\n        let times = data[attr].split(\",\").map(a => Number(a))\n        for (let time of times) {\n          if (!isNaN(time)) {\n            this.events.push([time, attr])\n          }\n        }\n      }\n    }\n\n    this.events.sort((a,b) => a[0] - b[0]) // ascending by time\n    this.lastSendEventsTime = -1\n  },\n\n  querySelectorAll(scope, selector) {\n    if (selector == \"\") return [this.el]\n\n    switch (scope) {\n      case \"self\": return this.el.querySelectorAll(selector) || [this.el]\n      case \"parent\": return this.el.parentNode.querySelectorAll(selector) || [this.el]\n      case \"document\": \n      default:\n        return document.querySelectorAll(selector) || [this.el]\n    }\n  },\n\n  addListeners() {\n    if (this.mediaEl) {\n      this.mediaEl.addEventListener(\"play\", this.sendEvents)\n    }\n  },\n\n  removeListeners() {\n    if (this.mediaEl) {\n      this.mediaEl.removeEventListener(\"play\", this.sendEvents)\n    }\n  },\n\n  sendEvents() {\n    if (this.mediaEl && this.mediaEl.paused) {\n      return\n    }\n\n    let time = this.mediaEl ? this.mediaEl.currentTime : (Date.now() - this.clockStartTime)/1000\n    let nextTime\n    let eventsToSend = []\n\n    for (let event of this.events) {\n      if (event[0] <= this.lastSendEventsTime) continue\n\n      if (event[0] <= time) {\n        eventsToSend.push(event[1])\n      } else {\n        nextTime = event[0]\n        break\n      }\n    }\n\n    if (eventsToSend.length > 0) {\n      const data = this.data\n      const source = this.el\n\n      for (let target of this.targets) {\n        const eventData = {source, target}\n        \n        for (let tag of eventsToSend) {\n          target.emit(tag, eventData)\n        }\n      }\n    }\n\n    this.lastSendEventsTime = time\n\n    if (nextTime) {\n      this.sendEventsTimer = setTimeout(this.sendEvents, (nextTime - time)*1000)\n    }\n  }\n})\n\n//# sourceURL=webpack:///./src/aframe-timer-emit-component.mjs?");

/***/ }),

/***/ "./src/aframe-utils.mjs":
/*!******************************!*\
  !*** ./src/aframe-utils.mjs ***!
  \******************************/
/*! exports provided: deepEqual, buildPath, convertToString, setProperty, parseValue */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"deepEqual\", function() { return deepEqual; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"buildPath\", function() { return buildPath; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"convertToString\", function() { return convertToString; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"setProperty\", function() { return setProperty; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"parseValue\", function() { return parseValue; });\n// Copyright 2018-2019 harlyq\n// MIT license\n\n// JSON deepEqual test\nfunction deepEqual(a, b) {\n  if (typeof a === \"object\" && a && b && a.constructor === b.constructor) {\n    if (Array.isArray(a)) {\n      if (a.length !== b.length) {\n        return false\n      }\n      \n      for (let i = 0; i < a.length; a++) {\n        if (!deepEqual(a[i], b[i])) {\n          return false\n        }\n      }\n    } else {\n      for (let k in a) {\n        if (!(k in b) || !deepEqual(a[k], b[k])) {\n          return false\n        }\n      }\n    }\n    return true\n  }\n\n  return a === b\n}\n\n// console.assert(deepEqual(null, null))\n// console.assert(deepEqual(undefined, undefined))\n// console.assert(deepEqual([], []))\n// console.assert(deepEqual([1], [1]))\n// console.assert(deepEqual([1,2,3], [1,2,3]))\n// console.assert(!deepEqual([1,2], [1,2,3]))\n// console.assert(!deepEqual([1,2,3], [1,2]))\n// console.assert(deepEqual({a:1, b:\"c\"}, {a:1, b:\"c\"}))\n// console.assert(!deepEqual({a:1, b:\"c\"}, {a:1, b:\"d\"}))\n// console.assert(!deepEqual({a:1, b:\"c\"}, {a:2, b:\"c\"}))\n// console.assert(!deepEqual({a:1, b:\"c\"}, null))\n// console.assert(deepEqual({a:[1,2], b:{x: 3, y:4}}, {a:[1,2], b:{x: 3, y:4}}))\n\n// builds a value from a 'root' and an array of 'attributes', each attribute is considered as the child of the previous attribute\nfunction buildPath(root, attributes) {\n  let path = root\n  let parts = attributes.slice().reverse()\n  while (path && parts.length > 0) {\n    path = path[parts.pop()]\n  }\n\n  return path\n}\n\nconsole.assert(buildPath({a: 1, b: {c: {x: \"hello\"}, d: 3}}, [\"b\",\"c\",\"x\"]) === \"hello\")\nconsole.assert(buildPath({a: 1, b: {c: {x: \"hello\"}, d: 3}}, [\"b\",\"c\",\"y\"]) === undefined)\nconsole.assert(buildPath({a: 1, b: {c: {x: \"hello\"}, d: 3}}, [\"a\"]) === 1)\nconsole.assert(buildPath({a: 1, b: {c: {x: \"hello\"}, d: 3}}, [\"b\",\"w\"]) === undefined)\n\n\n// stringifies an object, specifically sets colors as hexstrings and coordinates as space separated numbers\nfunction convertToString(thing) {\n  if (typeof thing == \"object\") {\n    if (Array.isArray(thing)) {\n      return thing.map(convertToString)\n    }\n\n    if (thing instanceof THREE.Color) {\n      return \"#\" + thing.getHexString()\n    }\n\n    if (\"x\" in thing || \"y\" in thing || \"z\" in thing || \"w\" in thing) {\n      return AFRAME.utils.coordinates.stringify(thing)\n    }\n  }\n\n  return thing.toString()\n}\n\n\n// *value* can be boolean, string, color or array of numbers\nconst setProperty = (() => {\n  const trim = x => x.trim()\n  const OBJECT3D_FAST_SET = {\n    \"rotation\": x => isNaN(x) ? 0 : THREE.Math.degToRad(x),\n    \"position\": x => isNaN(x) ? 0 : x,\n    \"scale\": x => isNaN(x) ? 1 : x,\n  }\n  \n  return function setProperty(target, prop, value) {\n    let fn = OBJECT3D_FAST_SET[prop]\n    if (fn) {\n      if (Array.isArray(value)) {\n      } else if (typeof value === \"object\") {\n        value = [value.x, value.y, value.z]\n      } else {\n        value = value.split(\" \").map(trim)\n      }\n      value.length = 3\n      target.object3D[prop].set(...value.map(fn))\n      return\n    }\n  \n    const parts = prop.split(\".\")\n    if (parts.length <= 2) {\n      // component or component.property\n      parts[0] = parts[0].replace(/[A-Z]/g, x => \"-\" + x.toLowerCase()) // convert component names from camelCase to kebab-case\n      AFRAME.utils.entity.setComponentProperty(target, parts.join(\".\"), convertToString(value)) // does this work for vectors??\n      return\n    }\n  \n    // e.g. object3dmap.mesh.material.uniforms.color\n    const path = buildPath(target, parts)\n    if (path) {\n      // this only works for boolean, string, color and an array of one element\n      path[part] = Array.isArray(value) && value.length === 1 ? value[0] : value\n    } else {\n      console.warn(`unknown path for setProperty() '${prop}'`)\n    }\n  }   \n  \n})()\n\n\n// Convert a string \"1 2 3\" into a type and value {type: \"numbers\", value: [1,2,3]}\nconst parseValue = (function() {\n  const isTHREE = typeof THREE !== \"undefined\"\n  const COLOR_WHITE = isTHREE ? new THREE.Color() : undefined\n  const COLOR_BLACK = isTHREE ? new THREE.Color(0,0,0) : undefined\n  const toNumber = str => Number(str.trim())\n\n  let tempColor = isTHREE ? new THREE.Color() : undefined\n  \n  return function parseValue(str) {\n    if (str === \"\") return {type: \"any\", value: \"\"}\n\n    let vec = str.split(\" \").filter(x => x !== \"\").map(toNumber)\n    if (!vec.every(isNaN)) return {type: \"numbers\", value: vec}\n  \n    if (isTHREE) {\n      let oldWarn = console.warn; console.warn = () => {} // HACK disable warnings that threejs spams about invalid colors\n      let col = new THREE.Color(str.trim())\n      if (col.equals(COLOR_WHITE) && tempColor.copy(COLOR_BLACK).setStyle(str).equals(COLOR_BLACK)) col = undefined // if input colour is the same as the starting color, then input was invalid\n      console.warn = oldWarn\n      if (col) return {type: \"color\", value: col}\n    }\n  \n    return {type: \"string\", value: str.trim()}\n  }\n})()\n\n// console.assert(deepEqual(parseValue(\"\"), {type: \"any\", value: \"\"}))\n// console.assert(deepEqual(parseValue(\"1\"), {type: \"numbers\", value: [1]}))\n// console.assert(deepEqual(parseValue(\" 2  3  4\"), {type: \"numbers\", value: [2,3,4]}))\n// console.assert(deepEqual(parseValue(\" 2.5 \"), {type: \"numbers\", value: [2.5]}))\n// console.assert(deepEqual(parseValue(\" 2,3 ,4 \"), {type: \"string\", value: \"2,3 ,4\"}))\n// console.assert(parseValue(\"red\").type === \"color\" && parseValue(\"red\").value.getHexString() === \"ff0000\")\n// console.assert(parseValue(\"#123\").type === \"color\" && parseValue(\"#123\").value.getHexString() === \"112233\")\n\n\n//# sourceURL=webpack:///./src/aframe-utils.mjs?");

/***/ }),

/***/ "./src/aframe-wait-add-remove-component.mjs":
/*!**************************************************!*\
  !*** ./src/aframe-wait-add-remove-component.mjs ***!
  \**************************************************/
/*! no exports provided */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _scoped_listener__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./scoped-listener */ \"./src/scoped-listener.mjs\");\n/* harmony import */ var _basic_timer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./basic-timer */ \"./src/basic-timer.mjs\");\n// Copyright 2018-2019 harlyq\n// MIT license\n\n\n\n\n/**\n * Breaks a selector string into {type, id, classes, attrs}\n * \n * @param {string} str - selector in the form type#id.class1.class2[attr1=value1][attr2=value2]\n * @return {object} { type, id, classes[], attrs{} }\n */\nfunction parseSelector(str) {\n  let results = {type: \"\", id: \"\", classes: [], attrs: {}}\n  let token = \"type\"\n  let tokenStart = 0\n  let lastAttr = \"\"\n\n  const setToken = (newToken, i) => {\n    let tokenValue = str.slice(tokenStart, i)\n\n    if (i > tokenStart) {\n      switch (token) {\n        case \"type\":\n        case \"id\":\n          results[token] = tokenValue\n          break\n        case \"class\":\n          results.classes.push(tokenValue)\n          break\n        case \"attr\":\n          lastAttr = tokenValue\n          break\n        case \"value\":\n          if (lastAttr) {\n            results.attrs[lastAttr] = tokenValue\n          }\n          break\n        case \"none\":\n        case \"end\":\n          break\n      }\n    }\n\n    token = newToken\n    tokenStart = i + 1 // ignore the token character\n  }\n\n  for (let i = 0, n = str.length; i < n; i++) {\n    const c = str[i]\n    switch (c) {\n      case \"\\\\\": i++; break // escape the next character\n      case \"#\": if (token !== \"attr\" && token !== \"value\") setToken(\"id\", i); break\n      case \".\": if (token !== \"attr\" && token !== \"value\") setToken(\"class\", i); break\n      case \"[\": if (token !== \"attr\" && token !== \"value\") setToken(\"attr\", i); break\n      case \"]\": if (token === \"attr\" || token === \"value\") setToken(\"none\", i); break\n      case \"=\": if (token === \"attr\") setToken(\"value\", i); break\n    }\n  }\n  setToken(\"end\", str.length)\n\n  return results\n}\n\n// console.assert(AFRAME.utils.deepEqual(parseSelector(\"\"), {type: \"\", id: \"\", classes: [], attrs: {}}))\n// console.assert(AFRAME.utils.deepEqual(parseSelector(\"xyz\"), {type: \"xyz\", id: \"\", classes: [], attrs: {}}))\n// console.assert(AFRAME.utils.deepEqual(parseSelector(\"#xyz\"), {type: \"\", id: \"xyz\", classes: [], attrs: {}}))\n// console.assert(AFRAME.utils.deepEqual(parseSelector(\".xyz\"), {type: \"\", id: \"\", classes: [\"xyz\"], attrs: {}}))\n// console.assert(AFRAME.utils.deepEqual(parseSelector(\"[xyz=1]\"), {type: \"\", id: \"\", classes: [], attrs: {\"xyz\": \"1\"}}))\n// console.assert(AFRAME.utils.deepEqual(parseSelector(\"type.class#id[attr=value]\"), {type: \"type\", id: \"id\", classes: [\"class\"], attrs: {attr: \"value\"}}))\n// console.assert(AFRAME.utils.deepEqual(parseSelector(\".class#id[]\"), {type: \"\", id: \"id\", classes: [\"class\"], attrs: {}}))\n// console.assert(AFRAME.utils.deepEqual(parseSelector(\".class1#id.class2\"), {type: \"\", id: \"id\", classes: [\"class1\", \"class2\"], attrs: {}}))\n// console.assert(AFRAME.utils.deepEqual(parseSelector(\"[foo=bar][one.two=three.four]\"), {type: \"\", id: \"\", classes: [], attrs: {\"foo\": \"bar\", \"one.two\": \"three.four\"}}))\n// console.assert(AFRAME.utils.deepEqual(parseSelector(\"xyz[foo=bar]#abc\"), {type: \"xyz\", id: \"abc\", classes: [], attrs: {\"foo\": \"bar\"}}))\n\n/**\n * Creates an HTML Element that matches a given selector string e.g. div.door#door1[state=open], \n * creates a \"div\" with className \"door\", id \"door1\" and attribute \"state=open\".  If no type is\n * provided then defaults to a-entity.\n * \n * @param {string} str - selector string to create\n * @return {object} returns an HTMLElement matching the selector string\n */\nfunction createElementFromSelector(str) {\n  let info = parseSelector(str)\n  let type = info.type || 'a-entity'\n  let newEl = document.createElement(type)\n  if (newEl) {\n    if (info.id) newEl.id = info.id\n    if (info.classes.length > 0) newEl.classList.add(...info.classes)\n\n    for (let attr in info.attrs) {\n      AFRAME.utils.entity.setComponentProperty(newEl, attr, trimQuotes(info.attrs[attr]))\n    }\n  }\n\n  return newEl\n}\n\n/**\n * Removes the outer-most quotes from around a string\n * \n * @param {string} str - string to remove quotes from\n * @return {string} returns a new string, without the leading and trailing quotes\n */\nfunction trimQuotes(str) {\n  str = str.trim()\n  const start = (str[0] === \"'\" || str[0] === '\"') ? 1 : 0\n  const n = str.length\n  let end = (str[n - 1] === \"'\" || str[n - 1] === '\"') ? n - 1 : n\n  return start === 0 && end === n ? str : str.slice(start, end)\n}\n\n// console.assert(trimQuotes(``) === \"\")\n// console.assert(trimQuotes(`  \"bla h\"`) === \"bla h\")\n// console.assert(trimQuotes(` 'foo''bar'  `) === \"foo''bar\")\n// console.assert(trimQuotes(`keep'\"inside`) === \"keep'\\\"inside\")\n\nAFRAME.registerComponent(\"wait-add-remove\", {\n  schema: {\n    delay: { default: 0 },\n    event: { default: \"\" },\n    source: { default: \"\" },\n    sourceScope: { default: \"document\", oneOf: [\"parent\", \"self\", \"document\"] },\n    add: { type: \"array\" },\n    addRepeat: { type: \"int\", default: 1 },\n    remove: { type: \"array\" },\n  },\n  multiple: true,\n\n  init() {\n    this.addRemoveEntities = this.addRemoveEntities.bind(this)\n    this.startDelay = this.startDelay.bind(this)\n\n    this.waitTimer = Object(_basic_timer__WEBPACK_IMPORTED_MODULE_1__[\"default\"])()\n    this.waitListener = Object(_scoped_listener__WEBPACK_IMPORTED_MODULE_0__[\"default\"])()\n  },\n\n  update(oldData) {\n    const data = this.data\n    if (oldData.event !== data.event || oldData.source !== data.source || oldData.sourceScope !== data.sourceScope) {\n      this.waitListener.set(this.el, data.source, data.sourceScope, data.event, this.startDelay)\n    }\n    \n    if (oldData.delay !== data.delay && (this.timer || data.event === \"\")) {\n      this.startDelay()\n    }\n  },\n\n  pause() {\n    this.waitTimer.pause()\n    this.waitListener.remove()\n  },\n\n  play() {\n    this.waitListener.add()\n    this.waitTimer.resume()\n  },\n\n  startDelay() {\n    this.waitTimer.start(this.data.delay, this.addRemoveEntities)\n  },\n\n  addRemoveEntities() {\n    const data = this.data\n    for (let removeSelector of data.remove) {\n      let descendants = this.el.querySelectorAll(removeSelector)\n      descendants.forEach(el => this.el.removeChild(el))\n    }\n\n    for (let i = 0; i < data.addRepeat; ++i) {\n      for (let addSelector of data.add) {\n        let newEl = createElementFromSelector(addSelector) // TODO should we createElement in the update, and only do the append here?\n        if (newEl) {\n          this.el.appendChild(newEl)\n        }\n      }\n    }\n  }\n})\n\n\n\n//# sourceURL=webpack:///./src/aframe-wait-add-remove-component.mjs?");

/***/ }),

/***/ "./src/aframe-wait-set-component.mjs":
/*!*******************************************!*\
  !*** ./src/aframe-wait-set-component.mjs ***!
  \*******************************************/
/*! no exports provided */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _scoped_listener__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./scoped-listener */ \"./src/scoped-listener.mjs\");\n/* harmony import */ var _basic_timer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./basic-timer */ \"./src/basic-timer.mjs\");\n/* harmony import */ var _basic_random__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./basic-random */ \"./src/basic-random.mjs\");\n/* harmony import */ var _aframe_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./aframe-utils */ \"./src/aframe-utils.mjs\");\n// Copyright 2018-2019 harlyq\n// MIT license\n\n\n\n\n// import {deepEqual} from \"./aframe-utils\"\n\nfunction trim(str) {\n  return str.trim()\n}\n\n// console.assert(deepEqual(parseValue(\"\"), {type: \"any\", value: \"\"}))\n// console.assert(deepEqual(parseValue(\"1\"), {type: \"numbers\", value: [1]}))\n// console.assert(deepEqual(parseValue(\" 2  3  4\"), {type: \"numbers\", value: [2,3,4]}))\n// console.assert(deepEqual(parseValue(\" 2.5 \"), {type: \"numbers\", value: [2.5]}))\n// console.assert(deepEqual(parseValue(\" 2,3 ,4 \"), {type: \"string\", value: \"2,3 ,4\"}))\n// console.assert(parseValue(\"red\").type === \"color\" && parseValue(\"red\").value.getHexString() === \"ff0000\")\n// console.assert(parseValue(\"#123\").type === \"color\" && parseValue(\"#123\").value.getHexString() === \"112233\")\n// console.assert(parseValue(\"  burple \"), {type: \"string\", value: \"burple\"})\n\n// Convert a string \"1..3\" into {type: \"numbers\", range: [[1],[3]]}\n// Convert a string \"1|2|3\" into {type: \"string\", options: [\"1\",\"2\",\"3\"]}\nfunction parseRangeOption(str) {\n  let range = str.split(\"..\")\n  if (range.length > 1) {\n    const start = Object(_aframe_utils__WEBPACK_IMPORTED_MODULE_3__[\"parseValue\"])(range[0])\n    const end = Object(_aframe_utils__WEBPACK_IMPORTED_MODULE_3__[\"parseValue\"])(range[1])\n  \n    if (start.type !== end.type && start.type !== \"any\" && end.type !== \"any\") {\n      console.error(`incompatible types for range ${str}`)\n    } else {\n      return { type: start.type !== \"any\" ? start.type : end.type, range: [start.value, end.value]}\n    }\n  }\n\n  let options = str.split(\"|\")\n  return { type: \"string\", options: options.map(trim) }\n}\n\n// console.assert(deepEqual(parseRangeOption(\"1 2 3\"), { type: \"string\", options: [\"1 2 3\"]}))\n// console.assert(deepEqual(parseRangeOption(\"1 2..3 4 5\"), { type: \"numbers\", range: [[1,2],[3,4,5]]}))\n// console.assert(deepEqual(parseRangeOption(\"a|b|c\"), { type: \"string\", options: [\"a\",\"b\",\"c\"]}))\n// console.assert(deepEqual(parseRangeOption(\"1 2||3\"), { type: \"string\", options: [\"1 2\",\"\",\"3\"]}))\n// console.assert(deepEqual(parseRangeOption(\"..3\"), { type: \"numbers\", range: [\"\",[3]]}))\n// console.assert(deepEqual(parseRangeOption(\"a..b\"), { type: \"string\", range: [\"a\",\"b\"]}))\n\nfunction randomizeOptions(options, randFn) {\n  return options[Math.floor(randFn()*options.length)]\n}\n\nfunction randomizeRange(type, range, randFn) {\n  const min = range[0]\n  const max = range[1]\n  const randomNumber = (min, max) => {\n    if (min === max) return min\n    return randFn()*(max - min) + min\n  }\n\n  if (type === \"numbers\") {\n    const m = Math.min(min.length, max.length) // count the least elements\n    let result = max.length > m ? max.slice() : min.slice() // copy the larger array\n    for (let i = 0; i < m; i++) {\n      result[i] = randomNumber(min[i], max[i]) // randomize the parts where values exist for both min and max\n    }\n    return result\n  }\n  \n  if (type === \"color\") {\n    return new THREE.Color(randomNumber(min.r, max.r), randomNumber(min.g, max.g), randomNumber(min.b, max.b))\n  }\n\n  return randFn() > 0.5 ? min : max\n}\n\n\n// const stringParts = [\"a\",\"ab\",\"bc\"];\n// const vecParts = [[1,2,3],[10,20]]\n// for (let i = 0; i < 50; i++) {\n//   console.assert(randomizeOptions([\"x\"], Math.random) === \"x\")\n//   console.assert(stringParts.includes(randomizeOptions(stringParts, Math.random)))\n//   console.assert([\"a\", \"b\"].includes(randomizeRange(\"string\", [\"a\", \"b\", \"c\"], Math.random)))\n  \n//   const x = randomizeRange(\"numbers\", [[1],[2]], Math.random)\n//   console.assert(x >= 1 && x < 2)\n\n//   const y = randomizeRange(\"numbers\", vecParts, Math.random)\n//   console.assert(y.length === 3 && y[0] >= vecParts[0][0] && y[0] < vecParts[1][0] && y[1] >= vecParts[0][1] && y[1] < vecParts[1][1] && y[2] === vecParts[0][2])\n// }\n\n\n//-----------------------------------------------------------------------------\n// \"wait-set\" component for setting attributes on this or other elements after a delay or event\n// \nAFRAME.registerComponent(\"wait-set\", {\n  schema: {\n    delay: { default: 0 },\n    event: { default: \"\" },\n    source: { default: \"\" },\n    sourceScope: { default: \"document\", oneOf: [\"parent\", \"self\", \"document\"] },\n    target: { default: \"\" },\n    targetScope: { default: \"document\", oneOf: [\"parent\", \"self\", \"document\"] },\n    seed: { type: \"int\", default: -1 },\n  },\n  multiple: true,\n\n  init() {\n    this.setProperties = this.setProperties.bind(this)\n    this.startDelay = this.startDelay.bind(this)\n\n    this.rules = {}\n    this.sources = []\n\n    this.waitListener = Object(_scoped_listener__WEBPACK_IMPORTED_MODULE_0__[\"default\"])()\n    this.waitTimer = Object(_basic_timer__WEBPACK_IMPORTED_MODULE_1__[\"default\"])()\n    this.psuedoRandom = Object(_basic_random__WEBPACK_IMPORTED_MODULE_2__[\"default\"])()\n  },\n\n  remove() {\n    this.waitListener.remove()\n    this.waitTimer.stop()\n  },\n\n  updateSchema(newData) {\n    const originalSchema = AFRAME.components[this.name].schema\n    let newSchema = {}\n\n    for (let prop in newData) {\n      if (!(prop in originalSchema)) {\n        newSchema[prop] = { default: \"\" }\n      }\n    }\n\n    // extend the schema so the new rules appear in the inspector\n    if (Object.keys(newSchema).length > 0) {\n      this.extendSchema(newSchema)\n    }\n  },\n\n  update(oldData) {\n    const originalSchema = AFRAME.components[this.name].schema\n    const data = this.data\n\n    if (data.seed !== oldData.seed) {\n      this.psuedoRandom.setSeed(data.seed)\n    }\n\n    for (let prop in this.rules) {\n      if (!(prop in data)) {\n        delete this.rules[prop] // property is no longer present\n      }\n    }\n\n    for (let prop in data) {\n      if (!(prop in originalSchema) && data[prop] !== oldData[prop]) {\n        this.rules[prop] = parseRangeOption(data[prop])\n      }\n    }\n\n    if (data.event !== oldData.event || data.source !== oldData.source || data.sourceScope !== oldData.sourceScope) {\n      this.waitListener.set(this.el, data.source, data.sourceScope, data.event, this.startDelay)\n    }\n\n    if (data.delay !== oldData.delay && (this.delayTimer || data.event === \"\")) {\n      this.startDelay()\n    }\n  },\n\n  pause() {\n    this.waitListener.remove()\n    this.waitTimer.pause()\n  },\n\n  play() {\n    this.waitTimer.resume()\n    this.waitListener.add()\n  },\n\n  startDelay() {\n    this.waitTimer.start(this.data.delay, this.setProperties)\n  },\n\n  setProperties() {\n    const elements = this.waitListener.getElementsInScope(this.el, this.data.target, this.data.targetScope)\n\n    for (let el of elements) {\n      for (let prop in this.rules) {\n        let rule = this.rules[prop]\n\n        const value = rule.options ? randomizeOptions(rule.options, this.psuedoRandom.random) : randomizeRange(rule.type, rule.range, this.psuedoRandom.random)\n        Object(_aframe_utils__WEBPACK_IMPORTED_MODULE_3__[\"setProperty\"])(el, prop, value)\n      }\n    }\n  },\n})\n\n\n//# sourceURL=webpack:///./src/aframe-wait-set-component.mjs?");

/***/ }),

/***/ "./src/basic-random.mjs":
/*!******************************!*\
  !*** ./src/basic-random.mjs ***!
  \******************************/
/*! exports provided: default */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return BasicRandom; });\n// Copyright 2018-2019 harlyq\n// MIT license\n\nfunction BasicRandom() {\n  const MAX_UINT32 = 0xffffffff\n  let seed = -1\n  \n  function setSeed(s) {\n    seed = s\n  }\n  \n  function random() {\n    if (seed < 0) {\n      return Math.random()\n    }\n  \n    seed = (1664525*seed + 1013904223) % MAX_UINT32\n    return seed/MAX_UINT32\n  }\n  \n  function randomInt(n) {\n    return ~~(random()*n)\n  }\n  \n  function randomNumber(min, max) {\n    if (min === max) { return min }\n    return random()*(max - min) + min\n  }\n  \n  return {\n    setSeed,\n    random,\n    randomInt,\n    randomNumber,\n  }\n}\n\n\n//# sourceURL=webpack:///./src/basic-random.mjs?");

/***/ }),

/***/ "./src/basic-timer.mjs":
/*!*****************************!*\
  !*** ./src/basic-timer.mjs ***!
  \*****************************/
/*! exports provided: default */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return BasicTimer; });\n// Copyright 2018-2019 harlyq\n// MIT license\n\nfunction BasicTimer() {\n  let sendEventTimer\n  let timeOfStart\n  let timeoutCallback\n  let timeRemaining\n\n  function start(delay, callback) {\n    stop()\n    \n    if (delay > 0) {\n      sendEventTimer = setTimeout(callback, delay*1000)\n      timeOfStart = Date.now()\n      timeoutCallback = callback\n    } else {\n      callback()\n    }\n  }\n\n  function stop() {\n    clearTimeout(self.sendEventTimer)\n    sendEventTimer = undefined\n    timeOfStart = undefined\n    timeRemaining = undefined\n    timeoutCallback = undefined\n  }\n\n  function pause() {\n    if (sendEventTimer) {\n      let remaining = Date.now() - timeOfStart\n      stop()\n      timeRemaining = remaining\n    }\n  }\n\n  function resume() {\n    if (timeRemaining) {\n      start(timeRemaining, timeoutCallback)\n      timeRemaining = undefined\n    }\n  }\n\n  return {\n    start,\n    stop,\n    pause,\n    resume\n  }\n}\n\n\n//# sourceURL=webpack:///./src/basic-timer.mjs?");

/***/ }),

/***/ "./src/index.mjs":
/*!***********************!*\
  !*** ./src/index.mjs ***!
  \***********************/
/*! no exports provided */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _aframe_audio_vis_component__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./aframe-audio-vis-component */ \"./src/aframe-audio-vis-component.mjs\");\n/* harmony import */ var _aframe_clone_entity_component__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./aframe-clone-entity-component */ \"./src/aframe-clone-entity-component.mjs\");\n/* harmony import */ var _aframe_clone_geo_component__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./aframe-clone-geo-component */ \"./src/aframe-clone-geo-component.mjs\");\n/* harmony import */ var _aframe_wait_add_remove_component__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./aframe-wait-add-remove-component */ \"./src/aframe-wait-add-remove-component.mjs\");\n/* harmony import */ var _aframe_wait_set_component__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./aframe-wait-set-component */ \"./src/aframe-wait-set-component.mjs\");\n/* harmony import */ var _aframe_keyframe_component__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./aframe-keyframe-component */ \"./src/aframe-keyframe-component.mjs\");\n/* harmony import */ var _aframe_timer_emit_component__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./aframe-timer-emit-component */ \"./src/aframe-timer-emit-component.mjs\");\n/* harmony import */ var _aframe_sprite_particles_component__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./aframe-sprite-particles-component */ \"./src/aframe-sprite-particles-component.mjs\");\n\n\n\n\n\n\n\n\n\n\n//# sourceURL=webpack:///./src/index.mjs?");

/***/ }),

/***/ "./src/scoped-listener.mjs":
/*!*********************************!*\
  !*** ./src/scoped-listener.mjs ***!
  \*********************************/
/*! exports provided: default */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return ScopedListener; });\n// Copyright 2018-2019 harlyq\n// MIT license\n\nfunction ScopedListener() {\n  let elements = []\n  let event\n  let callback\n\n  function set(el, selector, scope, eventName, callbackFn) {\n    remove()\n    elements = getElementsInScope(el, selector, scope)\n    event = eventName\n    callback = callbackFn\n  }\n\n  function add() {\n    if (event && callback) {\n      for (let el of elements) {\n        el.addEventListener(event, callback)\n      }\n    }\n  }\n\n  function remove() {\n    if (event && callback) {\n      for (let el of elements) {\n        el.removeEventListener(event, callback)\n      }\n    }\n  }\n\n  function getElementsInScope(el, selector, scope) {\n    if (selector == \"\") return [el]\n\n    switch (scope) {\n      case \"self\": return el.querySelectorAll(selector) || [el]\n      case \"parent\": return el.parentNode.querySelectorAll(selector) || [el]\n      case \"document\": \n      default:\n        return document.querySelectorAll(selector) || [el]\n    }\n  }\n\n  return {\n    set,\n    add,\n    remove,\n    getElementsInScope,\n  }\n}\n\n\n//# sourceURL=webpack:///./src/scoped-listener.mjs?");

/***/ })

/******/ });