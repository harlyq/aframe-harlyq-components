!function(e){var t={};function n(i){if(t[i])return t[i].exports;var a=t[i]={i:i,l:!1,exports:{}};return e[i].call(a.exports,a,a.exports,n),a.l=!0,a.exports}n.m=e,n.c=t,n.d=function(e,t,i){n.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:i})},n.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},n.t=function(e,t){if(1&t&&(e=n(e)),8&t)return e;if(4&t&&"object"==typeof e&&e&&e.__esModule)return e;var i=Object.create(null);if(n.r(i),Object.defineProperty(i,"default",{enumerable:!0,value:e}),2&t&&"string"!=typeof e)for(var a in e)n.d(i,a,function(t){return e[t]}.bind(null,a));return i},n.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return n.d(t,"a",t),t},n.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},n.p="",n(n.s=5)}([function(e,t){AFRAME.registerSystem("audio-vis",{schema:{src:{type:"selector"},fftSize:{default:32}},init:function(){this.context=new AudioContext,this.analysers={}},getOrCreateAnalyser:function(){const e=this.data.src,t=(e=>{const t=e.className.split(" ");return e.localName.toLowerCase()+(t[0]?"."+t.join("."):"")+"#"+e.id})(e);if(this.analysers[t])return this.analysers[t];const n=this.data.fftSize;let i=this.context.createAnalyser();return this.context.createMediaElementSource(e).connect(i),i.connect(this.context.destination),i.fftSize=n,i.fetchTime=-1,i.frequencyData=new Uint8Array(n),this.analysers[t]=i,i},getByteFrequencyData:function(e,t){return t!==e.fetchTime&&(e.getByteFrequencyData(e.frequencyData),e.fetchTime=t),e.frequencyData}});const n=e=>Number(e),i=e=>e.trim().split(" ").map(n),a=e=>e.includes(".."),r=e=>e.split("..").map(i),o=(e,t)=>{if(e.length<1)return e[0];let n=[];const i=e[0],a=e[1];for(let e=0,r=Math.max(i.length,a.length);e<r;e++)n[e]=THREE.Math.lerp(i[e]||0,a[e]||0,t);return n},s={bins:{type:"array",default:[0],parse:e=>"string"==typeof e?e.split(",").map(n):e},threshold:{default:0,min:0,max:1}};AFRAME.registerComponent("audio-vis",{schema:s,multiple:!0,init:function(){this.ranges={},this.analyser=this.system.getOrCreateAnalyser()},updateSchema:function(e){let t={};for(let n in e)n in this.schema||(t[n]={type:"string"});(e=>{for(let t in e)if(e.hasOwnProperty(t))return!1;return!0})(t)||this.extendSchema(t)},update:function(e){const t=this.data;for(let e in t)e in s||!a(t[e])||(this.ranges[e]=r(t[e]))},tick:function(e,t){const n=this.data,i=this.system.getByteFrequencyData(this.analyser,e),a=n.bins,r=a.length;let s=0;for(let e of a)s+=i[e];let l=s/r/255,c=l>n.threshold?l:0,d=this.el;for(let e in this.ranges){const t=o(this.ranges[e],c);switch(e){case"position":case"scale":d.object3D[e].set(...t);break;case"rotation":d.object3D[e].set(...t.map(THREE.Math.degToRad));break;default:d.setAttribute(e,t.map(e=>e.toFixed(4)).join(" "))}}}})},function(e,t){let n=0;AFRAME.registerComponent("clone-entity",{schema:{type:"selector"},multiple:!0,update(){const e=this.data.template;let t=document.importNode(e instanceof HTMLTemplateElement?e.content:e,!0);var i;(i=t).id&&(i.id+="_clone"+n),i.children.forEach(addUniqueIDs),this.el.appendChild(t),n++}})},function(e,t){AFRAME.registerComponent("clone-geo",{schema:{type:"selector"},init(){this.onObject3DSet=this.onObject3DSet.bind(this)},update(e){if(this.data!==e){e instanceof HTMLElement&&e.removeEventListener("object3dset",this.onObject3DSet);const t=this.data;t instanceof HTMLElement&&t.object3D&&(t.object3D.children.forEach(e=>this.el.object3D.add(e.clone())),this.el.object3DMap=t.object3DMap,t.addEventListener("object3dset",this.onObject3DSet))}},onObject3DSet(e){const t=this.data;e.target===t&&e.detail.type&&this.el.setObject3D(e.detail.type,t.getObject3D(e.detail.type))}})},function(e,t){AFRAME.registerComponent("timer-emit",{schema:{src:{type:"selector"},target:{default:""},targetScope:{default:"document",oneOf:["document","self","parent"]},stopOnPause:{default:!0}},multiple:!0,init(){this.sendEvents=this.sendEvents.bind(this),this.mediaEl=void 0,this.restartMedia=!1,this.clockStartTime=Date.now(),this.targets=[]},remove(){this.removeListeners()},updateSchema(e){const t=AFRAME.components["timer-emit"].schema;let n={};for(let i in e)i in t||(n[i]={type:"string"});Object.keys(n).length>0&&this.extendSchema(n)},pause(){const e=this.data;this.removeListeners(),e.stopOnPause&&(this.pauseTime=Date.now(),clearTimeout(this.sendEventsTimer),this.sendEventsTimer=void 0,this.mediaEl&&!this.mediaEl.paused&&(this.mediaEl.pause(),this.restartMedia=!0))},play(){this.pauseTime&&(this.clockStartTime+=Date.now()-this.pauseTime,delete this.pauseTime),this.mediaEl&&(this.addListeners(),this.restartMedia&&(this.mediaEl.play(),this.restartMedia=!1)),this.sendEvents()},update(e){const t=this.data,n=AFRAME.components["timer-emit"].schema;e.src!==t.src&&(this.removeListeners(),this.mediaEl=t.src instanceof HTMLMediaElement?t.src:void 0),e.target!==t.target&&(this.targets=this.querySelectorAll(t.targetScope,t.target)),this.events=[];for(let e in t)if(!(e in n)){let n=t[e].split(",").map(e=>Number(e));for(let t of n)isNaN(t)||this.events.push([t,e])}this.events.sort((e,t)=>e[0]-t[0]),this.lastSendEventsTime=-1},querySelectorAll(e,t){if(""==t)return[this.el];switch(e){case"self":return this.el.querySelectorAll(t)||[this.el];case"parent":return this.el.parentNode.querySelectorAll(t)||[this.el];case"document":default:return document.querySelectorAll(t)||[this.el]}},addListeners(){this.mediaEl&&this.mediaEl.addEventListener("play",this.sendEvents)},removeListeners(){this.mediaEl&&this.mediaEl.removeEventListener("play",this.sendEvents)},sendEvents(){if(this.mediaEl&&this.mediaEl.paused)return;let e,t=this.mediaEl?this.mediaEl.currentTime:(Date.now()-this.clockStartTime)/1e3,n=[];for(let i of this.events)if(!(i[0]<=this.lastSendEventsTime)){if(!(i[0]<=t)){e=i[0];break}n.push(i[1])}if(n.length>0){this.data;const e=this.el;for(let t of this.targets){const i={source:e,target:t};for(let e of n)t.emit(e,i)}}this.lastSendEventsTime=t,e&&(this.sendEventsTimer=setTimeout(this.sendEvents,1e3*(e-t)))}})},function(e,t){const n=THREE.Math.degToRad,i={acceleration:"USE_PARTICLE_ACCELERATION",angularAcceleration:"USE_PARTICLE_ANGULAR_ACCELERATION",angularVelocity:"USE_PARTICLE_ANGULAR_VELOCITY",color:"USE_PARTICLE_COLOR",textureFrame:"USE_PARTICLE_FRAMES",textureCount:"USE_PARTICLE_FRAMES",textureLoop:"USE_PARTICLE_FRAMES",position:"USE_PARTICLE_OFFSET",opacity:"USE_PARTICLE_OPACITY",radialAcceleration:"USE_PARTICLE_RADIAL_ACCELERATION",radialPosition:"USE_PARTICLE_RADIAL_OFFSET",radialVelocity:"USE_PARTICLE_RADIAL_VELOCITY",scale:"USE_PARTICLE_SCALE",velocity:"USE_PARTICLE_VELOCITY",orbitalVelocity:"USE_PARTICLE_ORBITAL",orbitalAcceleration:"USE_PARTICLE_ORBITAL",drag:"USE_PARTICLE_DRAG",destinationWeight:"USE_PARTICLE_DESTINATION",screenDepthOffset:"USE_PARTICLE_SCREEN_DEPTH_OFFSET",source:"USE_PARTICLE_SOURCE",model:"USE_PARTICLE_SOURCE"},a=["overtime","interval"],r=["newest","oldest","original"],o=["x","y","z"],s=e=>e.reduce((e,t)=>Array.isArray(t)?e.concat(s(t)):e.concat(t),[]),l=(e,t)=>{let n=e.split("..").map(e=>e.trim().split(" ").map(e=>{const t=Number(e);return isNaN(t)?void 0:t}));return 1===n.length&&(n[1]=n[0]),n.length=2,s(n.map(e=>t.map((t,n)=>void 0===e[n]?t:e[n])))},c=(e,t)=>s(e.split(",").map(e=>l(e,t))),d=e=>e.toLowerCase();let u=new THREE.DataTexture(new Uint8Array(3).fill(255),1,1,THREE.RGBFormat);u.needsUpdate=!0;const f={none:THREE.NoBlending,normal:THREE.NormalBlending,additive:THREE.AdditiveBlending,subtractive:THREE.SubtractiveBlending,multiply:THREE.MultiplyBlending},h={double:THREE.DoubleSide,front:THREE.FrontSide,back:THREE.BackSide};AFRAME.registerComponent("sprite-particles",{schema:{enableInEditor:{default:!1},texture:{type:"map"},delay:{default:0},duration:{default:-1},spawnType:{default:"continuous",oneOf:["continuous","burst"],parse:d},spawnRate:{default:10},source:{type:"selector"},textureFrame:{type:"vec2",default:{x:1,y:1}},textureCount:{type:"int",default:0},textureLoop:{default:1},randomizeFrames:{default:!1},trailInterval:{default:0},trailLifeTime:{default:"0"},trailType:{default:"particle",oneOf:["particle","ribbon","ribbon3d"]},ribbonWidth:{default:1},ribbonShape:{default:"flat",oneOf:["flat","taperin","taperout","taper"],parse:d},ribbonUVType:{default:"overtime",oneOf:a,parse:d},emitterColor:{type:"color"},lifeTime:{default:"1"},position:{default:"0 0 0"},velocity:{default:"0 0 0"},acceleration:{default:"0 0 0"},radialType:{default:"circle",oneOf:["circle","sphere","circlexy","circlexz"],parse:d},radialPosition:{default:"0"},radialVelocity:{default:"0"},radialAcceleration:{default:"0"},angularVelocity:{default:"0 0 0"},angularAcceleration:{default:"0 0 0"},orbitalVelocity:{default:"0"},orbitalAcceleration:{default:"0"},scale:{default:"1"},color:{default:"white",parse:d},rotation:{default:"0"},opacity:{default:"1"},velocityScale:{default:0},velocityScaleMinMax:{type:"vec2",default:{x:0,y:3}},drag:{default:0},destination:{type:"selector"},destinationOffset:{default:"0 0 0"},destinationWeight:{default:"0"},enable:{default:!0},emitterTime:{default:0},model:{type:"selector"},modelFill:{default:"triangle",oneOf:["triangle","edge","vertex"],parse:d},direction:{default:"forward",oneOf:["forward","backward"],parse:d},particleOrder:{default:"original",oneOf:r},ribbonUVMultiplier:{default:1},materialSide:{default:"front",oneOf:["double","front","back"],parse:d},screenDepthOffset:{default:0},alphaTest:{default:0},fog:{default:!0},depthWrite:{default:!1},depthTest:{default:!0},blending:{default:"normal",oneOf:["none","normal","additive","subtractive","multiply"],parse:d},transparent:{default:!0},particleSize:{default:100},usePerspective:{default:!0},seed:{type:"number",default:-1},overTimeSlots:{type:"int",default:5},frustumCulled:{default:!0},editorObject:{default:!0}},multiple:!0,help:"https://github.com/harlyq/aframe-sprite-particles-component",init(){this.pauseTick=this.pauseTick.bind(this),this.handleObject3DSet=this.handleObject3DSet.bind(this),this.count=0,this.trailCount=0,this.overTimeArrayLength=0,this.emitterTime=0,this.delayTime=0,this.lifeTime=[1,1],this.trailLifeTime=[0,0],this.textureFrames=new Float32Array(4),this.offset=new Float32Array(8).fill(0),this.velocity=new Float32Array(8).fill(0),this.acceleration=new Float32Array(8).fill(0),this.angularVelocity=new Float32Array(8).fill(0),this.angularAcceleration=new Float32Array(8).fill(0),this.orbital=new Float32Array(4).fill(0),this.colorOverTime,this.rotationScaleOverTime,this.params=new Float32Array(20).fill(0),this.velocityScale=new Float32Array(3).fill(0),this.emitterColor=new THREE.Vector3,this.destination=new Float32Array(8).fill(0),this.destinationOffset,this.destinationWeight,this.nextID=0,this.nextTime=0,this.numDisabled=0,this.numEnabled=0,this.startDisabled=!this.data.enable,this.manageIDs=!1,this.params[1]=-1},remove(){this.mesh&&this.el.removeObject3D(this.mesh.name),data.model&&data.model.removeEventListener("object3dset",this.handleObject3DSet)},update(e){const t=this.data;let n=t.particleSize!==e.particleSize,i=!1;if(t.overTimeSlots===e.overTimeSlots||this.isPlaying||(this.overTimeArrayLength=2*this.data.overTimeSlots+1,this.colorOverTime=new Float32Array(4*this.overTimeArrayLength).fill(0),this.rotationScaleOverTime=new Float32Array(2*this.overTimeArrayLength).fill(0),i=!0),this.params[8]=t.particleSize,this.params[9]=t.usePerspective?1:0,this.params[10]="forward"===t.direction?0:1,this.params[11]=THREE.Math.clamp(t.drag,0,1),this.params[15]=1e-5*t.screenDepthOffset,this.params[16]=t.ribbonWidth,this.params[17]=t.ribbonUVMultiplier,this.textureFrames[0]=t.textureFrame.x,this.textureFrames[1]=t.textureFrame.y,this.textureFrames[2]=t.textureCount>0?t.textureCount:t.textureFrame.x*t.textureFrame.y,this.textureFrames[3]=t.textureLoop,this.velocityScale[0]=t.velocityScale,this.velocityScale[1]=t.velocityScaleMinMax.x,this.velocityScale[2]=t.velocityScaleMinMax.y,this.material&&(this.material.alphaTest=t.alphaTest,this.material.depthTest=t.depthTest,this.material.depthWrite=t.depthWrite,this.material.blending=f[t.blending],this.material.fog=t.fog),t.seed!==e.seed&&(this.seed=t.seed,this.params[6]=t.seed>=0?t.seed:Math.random()),t.ribbonUVType!==e.ribbonUVType&&(this.params[18]=-1===a.indexOf(t.ribbonUVType)?0:a.indexOf(t.ribbonUVType)),t.radialType!==e.radialType&&(this.params[2]=["sphere","circlexy","circle"].includes(t.radialType)?1:0,this.params[19]=["sphere","circlexz"].includes(t.radialType)?1:0),this.mesh&&t.frustumCulled!==e.frustumCulled&&(this.mesh.frustumCulled=t.frustumCulled),t.emitterColor!==e.emitterColor){const e=new THREE.Color(t.emitterColor);this.emitterColor.set(e.r,e.g,e.b)}if(t.position===e.position&&t.radialPosition===e.radialPosition||(this.updateVec4XYZRange(t.position,"offset"),this.updateVec4WRange(t.radialPosition,[0],"offset"),n=!0),t.velocity===e.velocity&&t.radialVelocity===e.radialVelocity||(this.updateVec4XYZRange(t.velocity,"velocity"),this.updateVec4WRange(t.radialVelocity,[0],"velocity"),n=!0),t.acceleration===e.acceleration&&t.radialAcceleration===e.radialAcceleration||(this.updateVec4XYZRange(t.acceleration,"acceleration"),this.updateVec4WRange(t.radialAcceleration,[0],"acceleration"),n=!0),(t.rotation!==e.rotation||t.scale!==e.scale||i)&&(this.updateRotationScaleOverTime(),n=!0),(t.color!==e.color||t.opacity!==e.opacity||i)&&this.updateColorOverTime(),t.lifeTime!==e.lifeTime&&(this.lifeTime=this.updateVec4WRange(t.lifeTime,[1],"angularVelocity")),t.angularVelocity!==e.angularVelocity&&this.updateAngularVec4XYZRange(t.angularVelocity,"angularVelocity"),t.trailLifeTime!==e.trailLifeTime&&(this.trailLifeTime=l(t.trailLifeTime,[0]).map((e,t)=>e>0?e:this.lifeTime[t]),this.angularAcceleration[3]=this.trailLifeTime[0],this.angularAcceleration[7]=this.trailLifeTime[1]),t.angularAcceleration!==e.angularAcceleration&&this.updateAngularVec4XYZRange(t.angularAcceleration,"angularAcceleration"),t.orbitalVelocity!==e.orbitalVelocity&&this.updateAngularVec2PartRange(t.orbitalVelocity,[0],"orbital",0),t.orbitalAcceleration!==e.orbitalAcceleration&&this.updateAngularVec2PartRange(t.orbitalAcceleration,[0],"orbital",1),t.destinationOffset!==e.destinationOffset&&(this.destinationOffset=this.updateVec4XYZRange(t.destinationOffset,"destination")),t.destinationWeight!==e.destinationWeight&&(this.destinationWeight=this.updateVec4WRange(t.destinationWeight,[0],"destination")),t.duration===e.duration&&t.delay===e.delay&&t.emitterTime===e.emitterTime||(this.params[3]=t.duration,this.emitterTime=t.emitterTime,this.delayTime=t.delay),t.spawnType!==e.spawnType||t.spawnRate!==e.spawnRate||t.lifeTime!==e.lifeTime||t.trailInterval!==e.trailInterval){const e=this.lifeTime[1],n=t.trailInterval>0?this.trailLifeTime[1]:0,i=e+n,a=Math.max(1,Math.ceil(i*t.spawnRate));this.trailCount=1+(t.trailInterval>0?Math.ceil(Math.min(n,e)/t.trailInterval):0),this.isRibbon()?(this.trailCount++,this.count=a*this.trailCount*2):this.count=a*this.trailCount,this.params[4]="burst"===t.spawnType?0:1,this.params[5]=t.spawnRate,this.params[7]=this.count,this.params[13]=a,this.params[12]=t.trailInterval,this.params[14]=this.trailCount,this.updateAttributes()}t.enableInEditor!==e.enableInEditor&&this.enablePauseTick(t.enableInEditor),t.enable&&this.startDisabled&&(this.startDisabled=!1),t.model!==e.model&&t.model&&"getObject3D"in t.model&&(e.model&&e.model.removeEventListener("object3dset",this.handleObject3DSet),this.updateModelMesh(t.model.getObject3D("mesh")),t.model&&t.model.addEventListener("object3dset",this.handleObject3DSet)),"original"!==t.particleOrder&&t.source&&console.warn(`changing particleOrder to 'original' (was '${t.particleOrder}'), because particles use a source`),this.mesh?this.updateDefines():this.createMesh(),t.materialSide!==e.materialSide&&(this.material.side=h[t.materialSide]),n&&this.updateBounds(),this.paused&&t.editorObject!==e.editorObject&&this.enableEditorObject(t.editorObject),this.manageIDs=this.manageIDs||!t.enable||t.source||void 0!==this.el.getDOMAttribute(this.attrName).enable||t.model||t.delay>0,t.texture!==e.texture&&this.loadTexture(t.texture)},tick(e,t){const n=this.data;if(this.startDisabled)return;t>100&&(t=100);const i=t/1e3;n.enable&&(this.delayTime-=i),this.delayTime>=0||n.model&&!this.modelVertices||(this.emitterTime+=i,this.params[0]=this.emitterTime,this.geometry&&this.manageIDs?this.updateWorldTransform(this.emitterTime):this.params[1]=-1,n.destination&&n.destination.object3D&&(this.destinationWeight[0]>0||this.destinationWeight[1]>0)&&this.updateDestinationEntity())},pause(){this.paused=!0,this.enablePauseTick(this.data.enableInEditor),this.enableEditorObject(this.data.editorObject)},play(){this.paused=!1,this.enableEditorObject(!1),this.enablePauseTick(!1)},enablePauseTick(e){e?this.pauseRAF=requestAnimationFrame(this.pauseTick):cancelAnimationFrame(this.pauseRAF)},pauseTick(){this.tick(0,16),this.enablePauseTick(!0)},handleObject3DSet(e){e.target===this.data.model&&"mesh"===e.detail.type&&this.updateModelMesh(this.data.model.getObject3D("mesh"))},loadTexture(e){if(e){this.el.sceneEl.systems.material.loadTexture(e,{src:e},e=>{this.isRibbon()&&(e.wrapS=THREE.RepeatWrapping),this.material.uniforms.map.value=e})}else this.material.uniforms.map.value=u},isRibbon(){return this.data.trailInterval>0&&"particle"!==this.data.trailType},createMesh(){const e=this.data;this.geometry=new THREE.BufferGeometry,this.updateAttributes(),this.material=new THREE.ShaderMaterial({uniforms:{map:{type:"t",value:u},textureFrames:{value:this.textureFrames},params:{value:this.params},offset:{value:this.offset},velocity:{value:this.velocity},acceleration:{value:this.acceleration},angularVelocity:{value:this.angularVelocity},angularAcceleration:{value:this.angularAcceleration},orbital:{value:this.orbital},colorOverTime:{value:this.colorOverTime},rotationScaleOverTime:{value:this.rotationScaleOverTime},velocityScale:{value:this.velocityScale},emitterColor:{value:this.emitterColor},destination:{value:this.destination},fogDensity:{value:25e-5},fogNear:{value:1},fogFar:{value:2e3},fogColor:{value:new THREE.Color(16777215)}},fragmentShader:y,vertexShader:g,transparent:e.transparent,alphaTest:e.alphaTest,blending:f[e.blending],fog:e.fog,depthWrite:e.depthWrite,depthTest:e.depthTest,defines:{}}),this.updateDefines(),this.isRibbon()?(this.mesh=new THREE.Mesh(this.geometry,[this.material]),this.mesh.drawMode=THREE.TriangleStripDrawMode):this.mesh=new THREE.Points(this.geometry,this.material),this.mesh.frustumCulled=e.frustumCulled,this.mesh.name=this.attrName,this.material.name=this.mesh.name,this.el.setObject3D(this.mesh.name,this.mesh)},updateColorOverTime(){let e=(e=>s(e.split(",").map(e=>{let t=e.split("..");return 1===t.length&&(t[1]=t[0]),t.length=2,t.map(e=>new THREE.Color(e.trim()))})))(this.data.color),t=c(this.data.opacity,[1]);const n=this.data.overTimeSlots;e.length>2*n&&(e.length=2*n),t.length>2*n&&(t.length=2*n),this.colorOverTime.fill(0),this.colorOverTime[0]=e.length/2,this.colorOverTime[1]=t.length/2;let i=e.length;for(let t=0,n=4;t<i;t++,n+=4){let i=e[t];this.colorOverTime[n]=i.r,this.colorOverTime[n+1]=i.g,this.colorOverTime[n+2]=i.b}i=t.length;for(let e=0,n=4;e<i;e++,n+=4){let i=t[e];this.colorOverTime[n+3]=i}},updateRotationScaleOverTime(){const e=this.data.overTimeSlots;let t=c(this.data.rotation,[0]),i=c(this.data.scale,[1]);t.length>2*e&&(t.length=2*e),i.length>2*e&&(i.length=2*e),this.rotationScaleOverTime.fill(0),this.rotationScaleOverTime[0]=t.length/2,this.rotationScaleOverTime[1]=i.length/2;let a=t.length;for(let e=0,i=2;e<a;e++,i+=2)this.rotationScaleOverTime[i]=n(t[e]);a=i.length;for(let e=0,t=2;e<a;e++,t+=2)this.rotationScaleOverTime[t+1]=i[e]},updateVec4XYZRange(e,t){const n=l(e,[0,0,0]);for(let e=0,i=0;e<n.length;)this[t][i++]=n[e++],this[t][i++]=n[e++],this[t][i++]=n[e++],i++;return n},updateAngularVec4XYZRange(e,t){const i=l(e,[0,0,0]);for(let e=0,a=0;e<i.length;)this[t][a++]=n(i[e++]),this[t][a++]=n(i[e++]),this[t][a++]=n(i[e++]),a++},updateAngularVec2PartRange(e,t,i,a){const r=l(e,t);this[i][a]=n(r[0]),this[i][a+2]=n(r[1])},updateVec4WRange(e,t,n){let i=l(e,t);return this[n][3]=i[0],this[n][7]=i[1],i},updateBounds(){const e=this.data;let t=Math.max(this.lifeTime[0],this.lifeTime[1]);let n=[new Array(4),new Array(4)];e.drag>0&&(t*=1-.5*e.drag);for(let e=0;e<2;e++){const i=0===e?Math.min:Math.max;for(let a=0;a<4;a++){const r=i(this.offset[a],this.offset[a+4]),o=i(this.velocity[a],this.velocity[a+4]),s=i(this.acceleration[a],this.acceleration[a+4]);n[e][a]=r+(o+.5*s*t)*t,n[e][a]=i(n[e][a],r);const l=-o/s;l>0&&l<t&&(n[e][a]=i(n[e][a],r-.5*o*o/s))}}this.modelBounds&&(n[0][0]+=this.modelBounds.min.x,n[0][1]+=this.modelBounds.min.y,n[0][2]+=this.modelBounds.min.z,n[1][0]+=this.modelBounds.max.x,n[1][1]+=this.modelBounds.max.y,n[1][2]+=this.modelBounds.max.z);const i=this.el.getDOMAttribute(this.attrName),a=this.rotationScaleOverTime.reduce((e,t,n)=>1&n?Math.max(e,t):e,0),r=Math.max(Math.abs(n[0][3]),Math.abs(n[1][3]))+45e-5*e.particleSize*a,o="sphere"===e.radialType||i.angularVelocity||i.angularAcceleration||i.orbitalVelocity||i.orbitalAcceleration;n[0][0]-=r,n[0][1]-=r,n[0][2]-=o?r:0,n[1][0]+=r,n[1][1]+=r,n[1][2]+=o?r:0,n[0].length=3,n[0].length=3;const s=Math.max(...n[0].map(Math.abs),...n[1].map(Math.abs));this.geometry.boundingSphere||(this.geometry.boundingSphere=new THREE.Sphere),this.geometry.boundingSphere.radius=s,this.geometry.boundingBox||(this.geometry.boundingBox=new THREE.Box3),this.geometry.boundingBox.min.set(...n[0]),this.geometry.boundingBox.max.set(...n[1]);const l=this.el.getObject3D("mesh");l&&l.isParticlesEditorObject&&this.enableEditorObject(!0)},updateDestinationEntity:function(){let e=new THREE.Vector3,t=new THREE.Vector3;return function(){this.data.destination.object3D.getWorldPosition(e),this.el.object3D.getWorldPosition(t),e.sub(t);for(let t=0,n=o.length;t<n;t++)this.destination[t]=e[o[t]]+this.destinationOffset[t],this.destination[t+4]=e[o[t]]+this.destinationOffset[t+3]}}(),enableEditorObject(e){const t=this.el.getObject3D("mesh");if(!e||t&&!t.isParticlesEditorObject)!e&&t&&t.isParticlesEditorObject&&this.el.removeObject3D("mesh");else{const e=.25,t=new THREE.Vector3(e,e,e).max(this.geometry.boundingBox.max),n=new THREE.Vector3(-e,-e,-e).min(this.geometry.boundingBox.min);let i=new THREE.Box3(n,t),a=new THREE.Box3Helper(i,8421376);a.isParticlesEditorObject=!0,a.visible=!1,this.el.setObject3D("mesh",a)}},updateAttributes(){if(this.geometry){const e=this.count;let t=new Float32Array(e);if(this.startDisabled||this.data.delay>0||this.data.model)t.fill(-1),this.numEnabled=0,this.numDisabled=e;else{for(let n=0;n<e;n++)t[n]=n;this.numEnabled=e,this.numDisabled=0}if(this.geometry.addAttribute("vertexID",new THREE.Float32BufferAttribute(t,1)),this.geometry.addAttribute("position",new THREE.Float32BufferAttribute(new Float32Array(3*e).fill(0),3)),this.data.source&&this.geometry.addAttribute("quaternion",new THREE.Float32BufferAttribute(new Float32Array(4*e).fill(0),4)),this.isRibbon()){this.geometry.clearGroups();const t=2*this.trailCount;for(let n=0;n<e;n+=t)this.geometry.addGroup(n,t,0)}}},updateDefines(){const e=this.data,t=Object.keys(this.el.getDOMAttribute(this.attrName)),n=t.map(e=>i[e]).filter(e=>e);let a={PARAMS_LENGTH:5,OVER_TIME_ARRAY_LENGTH:this.overTimeArrayLength,RANDOM_REPEAT_COUNT:131072,USE_MAP:!0};for(key of n)a[key]=!0;e.velocityScale>0&&(a.USE_PARTICLE_VELOCITY_SCALE=!0),e.trailInterval>0&&(this.isRibbon()?"ribbon"===e.trailType?a.USE_RIBBON_TRAILS=!0:a.USE_RIBBON_3D_TRAILS=!0:a.USE_PARTICLE_TRAILS=!0),e.randomizeFrames&&(a.USE_PARTICLE_RANDOMIZE_FRAMES=!0),t.includes("rotation")&&(this.isRibbon()?a.USE_RIBBON_ROTATION=!0:a.USE_PARTICLE_ROTATION=!0);let o="1.";if("taperout"===e.ribbonShape?o="1. - p":"taperin"===e.ribbonShape?o="p":"taper"===e.ribbonShape?o="2. * ( p < .5 ? p : 1. - p )":"="===e.ribbonShape[0]&&(o=e.ribbonShape.slice(1)),a.RIBBON_SHAPE_FUNCTION=o,e.source?a.PARTICLE_ORDER=2:a.PARTICLE_ORDER=r.indexOf(e.particleOrder),a.PARTICLE_TRAIL_ORDER=r.indexOf(e.particleOrder),Object.keys(a).filter(e=>this.material.defines[e]!==a[e]).length>0)if(this.isPlaying){const e=t.filter(e=>{const t=i[e];return t&&!this.material.defines[t]});console.error(`cannot add attributes (${e.join(",")}) at run-time`)}else this.material.defines=a,this.material.needsUpdate=!0},updateModelMesh(e){if(!e)return;this.modelBounds=new THREE.Box3,this.modelVertices;let t=0,n=0,i=0;const a=e=>{if(!e.geometry)return;let a=e.geometry.getAttribute("position");a&&3!==a.itemSize||(0==i?n+=a.array.length:(this.modelVertices.set(a.array,t),t+=a.array.length))};i=0,e.traverse(a),n>0&&(i=1,this.modelVertices=new Float32Array(n),e.traverse(a),m(this.modelVertices,e.el.object3D.scale),this.modelBounds.setFromArray(this.modelVertices),this.updateBounds())},updateWorldTransform:function(){let e=new THREE.Vector3,t=new THREE.Quaternion,n=new THREE.Vector3,i=new THREE.Vector3,a=new THREE.Matrix4;return function(r){const o=this.data,s=this.count,l=this.data.spawnRate,c="burst"===o.spawnType,d=c?0:1/l,u=o.enable?this.numEnabled<s:this.numDisabled<s,f=o.source&&null!=o.source.object3D,h=this.modelVertices&&this.modelVertices.length,m=this.isRibbon(),g=h||f;let y=this.geometry.getAttribute("vertexID"),E=this.geometry.getAttribute("position"),b=this.geometry.getAttribute("quaternion");f&&(this.el.object3D.updateMatrixWorld(),o.source.object3D.updateMatrixWorld(),a.getInverse(this.el.object3D.matrixWorld),a.multiply(o.source.object3D.matrixWorld),a.decompose(e,t,n),this.geometry.boundingSphere.center.copy(e));let R=this.nextID%s,A=0,I=R,S=this.nextID;switch(modelFillFn=p,o.modelFill){case"edge":modelFillFn=v;break;case"vertex":modelFillFn=T}for(;this.nextTime<r&&A<this.count;){h&&modelFillFn(this.modelVertices,i);for(let n=0,a=m?2:1;n<a;n++)for(let n=0;n<this.trailCount;n++)S=this.nextID,h&&E.setXYZ(I,i.x,i.y,i.z),f&&(E.setXYZ(I,e.x,e.y,e.z),b.setXYZW(I,t.x,t.y,t.z,t.w)),y.setX(I,o.enable?S:-1),u&&(this.numEnabled=o.enable?this.numEnabled+1:0,this.numDisabled=o.enable?0:this.numDisabled+1),I=(I+1)%s,A++,g?this.nextID++:this.nextID=I;this.nextTime+=d}if(A>0){const e=this.trailCount*(m?2:1);this.params[1]=Math.floor(S/e),c&&(this.nextTime+=this.lifeTime[1],o.trailInterval>0&&(this.nextTime+=this.trailLifeTime[1])),I<R&&(R=0,A=this.count),(f||h)&&(E.updateRange.offset=R,E.updateRange.count=A,E.needsUpdate=!0),f&&(b.updateRange.offset=R,b.updateRange.count=A,b.needsUpdate=!0),y.updateRange.offset=R,y.updateRange.count=A,y.needsUpdate=!0,this.nextID=this.nextID%131072}}}()});const m=(e,t)=>{if(1!==t.x&&1!==t.y&&1!==t.z)for(let n=0,i=e.length;n<i;n+=3)e[n]*=t.x,e[n+1]*=t.y,e[n+2]*=t.z},p=function(){let e=new THREE.Vector3,t=new THREE.Vector3;return function(n,i){let a,r,o=9*Math.floor(Math.random()*n.length/9);e.fromArray(n,o),t.fromArray(n,o+3),i.fromArray(n,o+6);do{a=Math.random(),r=Math.random()}while(a+r>1);t.sub(e).multiplyScalar(a),i.sub(e).multiplyScalar(r).add(t).add(e)}}(),v=function(){let e=new THREE.Vector3,t=new THREE.Vector3,n=new THREE.Vector3;return function(i,a){let r=9*Math.floor(Math.random()*i.length/9);e.fromArray(i,r),t.fromArray(i,r+3),n.fromArray(i,r+6),r1=Math.random(),r1>2/3?a.copy(e).sub(n).multiplyScalar(3*r1-2).add(n):r1>1/3?a.copy(n).sub(t).multiplyScalar(3*r1-1).add(t):a.copy(t).sub(e).multiplyScalar(3*r1).add(e)}}();function T(e,t){let n=3*Math.floor(Math.random()*e.length/3);t.fromArray(e,n)}const g="\n#include <common>\n// #include <color_pars_vertex>\n#include <fog_pars_vertex>\n// #include <morphtarget_pars_vertex>\n// #include <logdepthbuf_pars_vertex>\n// #include <clipping_planes_pars_vertex>\n\nattribute float vertexID;\n\n#if defined(USE_PARTICLE_SOURCE)\nattribute vec4 quaternion;\n#endif\n\nuniform vec4 params[PARAMS_LENGTH];\nuniform vec4 offset[2];\nuniform vec4 velocity[2];\nuniform vec4 acceleration[2];\nuniform vec4 angularVelocity[2];\nuniform vec4 angularAcceleration[2];\nuniform vec2 orbital[2];\nuniform vec4 colorOverTime[OVER_TIME_ARRAY_LENGTH];\nuniform vec2 rotationScaleOverTime[OVER_TIME_ARRAY_LENGTH];\nuniform vec4 textureFrames;\nuniform vec3 velocityScale;\nuniform vec4 destination[2];\n\nvarying vec4 vParticleColor;\nvarying vec2 vCosSinRotation;\nvarying vec2 vUv;\nvarying float vOverTimeRatio;\nvarying float vFrame;\n\nfloat VERTS_PER_RIBBON = 2.;\n\n// alternative random algorithm, used for the initial seed.  Provides a better\n// result than using rand()\nfloat pseudoRandom( const float seed )\n{\n  return mod( 1664525.*seed + 1013904223., 4294967296. )/4294967296.; // we don't have enough precision in 32-bit float, but results look ok\n}\n\n// each call to random will produce a different result by varying randI\nfloat randI = 0.;\nfloat random( const float seed )\n{\n  randI += 0.001;\n  return rand( vec2( seed, randI ));\n}\n\nvec3 randVec3Range( const vec3 range0, const vec3 range1, const float seed )\n{\n  vec3 lerps = vec3( random( seed ), random( seed ), random( seed ) );\n  return mix( range0, range1, lerps );\n}\n\nvec2 randVec2Range( const vec2 range0, const vec2 range1, const float seed )\n{\n  vec2 lerps = vec2( random( seed ), random( seed ) );\n  return mix( range0, range1, lerps );\n}\n\nfloat randFloatRange( const float range0, const float range1, const float seed )\n{\n  float lerps = random( seed );\n  return mix( range0, range1, lerps );\n}\n\n// theta.x is the angle in XY, theta.y is the angle in XZ\nvec3 radialToVec3( const float r, const vec2 theta )\n{\n  vec2 cosTheta = cos(theta);\n  vec2 sinTheta = sin(theta);\n  float rc = r * cosTheta.x;\n  float x = rc * cosTheta.y;\n  float y = r * sinTheta.x;\n  float z = rc * sinTheta.y;\n  return vec3( x, y, z );\n}\n\n// array lengths are stored in the first slot, followed by actual values from slot 1 onwards\n// colors are packed min,max,min,max,min,max,...\n// color is packed in xyz and opacity in w, and they may have different length arrays\n\nvec4 calcColorOverTime( const float r, const float seed )\n{\n  vec3 color = vec3(1.);\n  float opacity = 1.;\n\n#if defined(USE_PARTICLE_COLOR)\n  int colorN = int( colorOverTime[0].x );\n  if ( colorN == 1 )\n  {\n    color = randVec3Range( colorOverTime[1].xyz, colorOverTime[2].xyz, seed );\n  }\n  else if ( colorN > 1 )\n  {\n    float ck = r * ( float( colorN ) - 1. );\n    float ci = floor( ck );\n    int i = int( ci )*2 + 1;\n    vec3 sColor = randVec3Range( colorOverTime[i].xyz, colorOverTime[i + 1].xyz, seed );\n    vec3 eColor = randVec3Range( colorOverTime[i + 2].xyz, colorOverTime[i + 3].xyz, seed );\n    color = mix( sColor, eColor, ck - ci );\n  }\n#endif\n\n#if defined(USE_PARTICLE_OPACITY)\n  int opacityN = int( colorOverTime[0].y );\n  if ( opacityN == 1 )\n  {\n    opacity = randFloatRange( colorOverTime[1].w, colorOverTime[2].w, seed );\n  }\n  else if ( opacityN > 1 )\n  {\n    float ok = r * ( float( opacityN ) - 1. );\n    float oi = floor( ok );\n    int j = int( oi )*2 + 1;\n    float sOpacity = randFloatRange( colorOverTime[j].w, colorOverTime[j + 1].w, seed );\n    float eOpacity = randFloatRange( colorOverTime[j + 2].w, colorOverTime[j + 3].w, seed );\n    opacity = mix( sOpacity, eOpacity, ok - oi );\n  }\n#endif\n\n  return vec4( color, opacity );\n}\n\n// as per calcColorOverTime but euler rotation is packed in xyz and scale in w\n\nvec2 calcRotationScaleOverTime( const float r, const float seed )\n{\n  float rotation = 0.;\n  float scale = 1.;\n\n#if defined(USE_PARTICLE_ROTATION) || defined(USE_RIBBON_ROTATION)\n  int rotationN = int( rotationScaleOverTime[0].x );\n  if ( rotationN == 1 )\n  {\n    rotation = randFloatRange( rotationScaleOverTime[1].x, rotationScaleOverTime[2].x, seed );\n  }\n  else if ( rotationN > 1 )\n  {\n    float rk = r * ( float( rotationN ) - 1. );\n    float ri = floor( rk );\n    int i = int( ri )*2 + 1; // *2 because each range is 2 vectors, and +1 because the first vector is for the length info\n    float sRotation = randFloatRange( rotationScaleOverTime[i].x, rotationScaleOverTime[i + 1].x, seed );\n    float eRotation = randFloatRange( rotationScaleOverTime[i + 2].x, rotationScaleOverTime[i + 3].x, seed );\n    rotation = mix( sRotation, eRotation, rk - ri );\n  }\n#endif\n\n#if defined(USE_PARTICLE_SCALE)\n  int scaleN = int( rotationScaleOverTime[0].y );\n  if ( scaleN == 1 )\n  {\n    scale = randFloatRange( rotationScaleOverTime[1].y, rotationScaleOverTime[2].y, seed );\n  }\n  else if ( scaleN > 1 )\n  {\n    float sk = r * ( float( scaleN ) - 1. );\n    float si = floor( sk );\n    int j = int( si )*2 + 1; // *2 because each range is 2 vectors, and +1 because the first vector is for the length info\n    float sScale = randFloatRange( rotationScaleOverTime[j].y, rotationScaleOverTime[j + 1].y, seed );\n    float eScale = randFloatRange( rotationScaleOverTime[j + 2].y, rotationScaleOverTime[j + 3].y, seed );\n    scale = mix( sScale, eScale, sk - si );\n  }\n#endif\n\n  return vec2( rotation, scale );\n}\n\n// assumes euler order is YXZ (standard convention for AFrame)\nvec4 eulerToQuaternion( const vec3 euler )\n{\n  // from https://github.com/mrdoob/three.js/blob/master/src/math/Quaternion.js\n\n  vec3 c = cos( euler * .5 );\n  vec3 s = sin( euler * .5 );\n\n  return vec4(\n    s.x * c.y * c.z + c.x * s.y * s.z,\n    c.x * s.y * c.z - s.x * c.y * s.z,\n    c.x * c.y * s.z - s.x * s.y * c.z,\n    c.x * c.y * c.z + s.x * s.y * s.z\n  );\n}\n\n// from http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm\nvec4 axisAngleToQuaternion( const vec3 axis, const float angle ) \n{\n  return vec4( axis * sin( angle*.5 ), cos( angle*.5 ) );\n}\n\nvec3 applyQuaternion( const vec3 v, const vec4 q )\n{\n  return v + 2. * cross( q.xyz, cross( q.xyz, v ) + q.w * v );\n}\n\nvec3 displacement( const vec3 v, const vec3 a, const float t )\n{\n  return (v + 0.5 * a * t) * t;\n}\n\nfloat displacement1D( const float v, const float a, const float t )\n{\n  return (v + 0.5 * a * t) * t;\n}\n\nfloat ribbonShape( const float p )\n{\n  return RIBBON_SHAPE_FUNCTION;\n}\n\nvec3 particleMotion( const vec3 p, const vec3 v, const vec3 a, const vec3 av, const vec3 aa, const vec3 axis, const float ov, const float oa, const vec3 dest, const float weight, const float t )\n{\n  vec3 pos = p + displacement(v, a, t);\n\n#if defined(USE_PARTICLE_ANGULAR_VELOCITY) || defined(USE_PARTICLE_ANGULAR_ACCELERATION)\n  pos = applyQuaternion( pos, eulerToQuaternion( displacement(av, aa, t) ) );\n#endif\n\n#if defined(USE_PARTICLE_ORBITAL)\n  pos = applyQuaternion( pos, axisAngleToQuaternion( axis, displacement1D(ov, oa, t) ) );\n#endif\n\n#if defined(USE_PARTICLE_SOURCE)\n  pos = applyQuaternion( pos, quaternion );\n#endif\n\npos += position;\n\n#if defined(USE_PARTICLE_DESTINATION)\n  pos = mix( pos, dest, weight );\n#endif\n\n  return pos;\n}\n\nvec2 toScreen( const vec4 clipSpacePos )\n{\n  return clipSpacePos.xy / clipSpacePos.w;\n}\n\nvoid main() {\n\n  float time = params[0].x;\n  float cpuID = params[0].y;\n  float radialTypeX = params[0].z;\n  float radialTypeY = params[4].w;\n  float duration = params[0].w;\n  float spawnType = params[1].x;\n  float spawnRate = params[1].y;\n  float baseSeed = params[1].z;\n  float vertexCount = params[1].w;\n  float direction = params[2].z; // 0 is forward, 1 is backward  \n  float trailInterval = params[3].x;\n  float particleCount = params[3].y;\n  float trailCount = params[3].z;\n  float maxParticleLifeTime = angularVelocity[1].w; // lifeTime packed into w component of angularVelocity\n  float maxTrailLifeTime = angularAcceleration[1].w; // trailLifeTime packed into angularAcceleration.w\n  float particleLoopTime = particleCount / spawnRate;\n  float motionAge = -1.; // used to determine the age for particle movement\n\n#if defined(USE_PARTICLE_TRAILS) || defined(USE_RIBBON_TRAILS) || defined(USE_RIBBON_3D_TRAILS)\n  float maxAge = maxParticleLifeTime + maxTrailLifeTime;\n#else\n  float maxAge = maxParticleLifeTime;\n#endif\n\n  // the CPU manages IDs if it sets the position or disables particles, otherwise cpuID is -1\n  float particleID0 = cpuID > -EPSILON ? cpuID : floor( mod( time, particleLoopTime ) * spawnRate ); // this will lose precision eventually\n\n  vOverTimeRatio = -1.; // the vOverTimeRatio will be used for the lerps on over-time attributes\n\n  // particles are either emitted in a burst (spawnType == 0) or spread evenly\n  // throughout 0..particleLoopTime (spawnType == 1).  We calculate the ID of the last spawned particle particleID0 \n  // for this frame, any vertex IDs after particleID0 are assumed to belong to the previous loop\n\n  // vertex 0 = trail0 of particle0, vertex 1 = trail1 of particle0, ..., vertex k = trail0 of particle1, ...\n#if defined(USE_RIBBON_TRAILS) || defined(USE_RIBBON_3D_TRAILS)\n  float rawParticleID = floor( vertexID / VERTS_PER_RIBBON / trailCount );\n#else\n  float rawParticleID = floor( vertexID / trailCount );\n#endif\n\n  float particleLoop = floor( time / particleLoopTime );\n\n#if defined(USE_PARTICLE_SOURCE)\n  // find particleID relative to the last loop\n  float particleID = rawParticleID - floor( particleID0 / particleCount ) * particleCount;\n#else // defined(USE_PARTICLE_SOURCE)\n\n#if PARTICLE_ORDER == 0\n  float particleID = particleID0 - (particleCount - 1. - rawParticleID); // newest last\n#elif PARTICLE_ORDER == 1\n  float particleID = particleID0 - rawParticleID; // oldest last\n#else\n  float particleID = rawParticleID > particleID0 ? rawParticleID - particleCount : rawParticleID; // cyclic (original)\n#endif\n\n#endif // defined(USE_PARTICLE_SOURCE)\n\n  // for burst mode we use the rawParticleID, because the concept of particleID0 is irrelevant\n  particleID = mix( rawParticleID, particleID, spawnType ); \n\n  float particleStartTime = particleLoop * particleLoopTime + particleID / spawnRate * spawnType;\n\n  // we use the id as a seed for the randomizer, but because the IDs are fixed in \n  // the range 0..particleCount we calculate a virtual ID by taking into account\n  // the number of loops that have occurred (note, particles from the previous \n  // loop will have a negative particleID). We use the modoulo of the RANDOM_REPEAT_COUNT \n  // to ensure that the virtualID doesn't exceed the floating point precision\n\n  float virtualID = mod( particleID + particleLoop * particleCount, float( RANDOM_REPEAT_COUNT ) );\n  float seed = pseudoRandom( virtualID*baseSeed*110. );\n\n  float particleLifeTime = randFloatRange( angularVelocity[0].w, angularVelocity[1].w, seed );\n\n  float particleAge = time - particleStartTime;\n  particleAge = particleAge + direction * ( particleLoopTime - 2. * particleAge );\n\n  // don't show particles that would be emitted after the duration\n  if ( duration > 0. && time - particleAge >= duration ) \n  {\n    particleAge = -1.;\n  } \n\n  // always calculate the trailLifeTime, even if we don't use it, so the particles\n  // with the same seed give consistent results\n  float trailLifeTime = randFloatRange( angularAcceleration[0].w, angularAcceleration[1].w, seed );\n\n#if defined(USE_PARTICLE_TRAILS)\n\n  // +1 beceause we show both the lead particle and the first trail at the start\n  // we cap the particleAge to ensure it never goes past the particleLifeTime\n  float cappedParticleAge = min( particleLifeTime - trailInterval, particleAge );\n  float trailID0 = floor( cappedParticleAge / trailInterval ) + 1.;\n  float rawTrailID = mod( vertexID, trailCount );\n\n#if PARTICLE_TRAIL_ORDER == 0\n  float trailID = trailID0 - ( trailCount - 1. - rawTrailID ); // newest last\n#elif PARTICLE_TRAIL_ORDER == 1\n  float trailID = trailID0 - rawTrailID; // oldest last\n#else\n  float trailID = floor( trailID0 / trailCount ) * trailCount;\n  trailID += rawTrailID > mod( trailID0, trailCount ) ? rawTrailID - trailCount : rawTrailID; // cyclic (original)\n#endif\n\n  float trailStartAge = trailID * trailInterval;\n  \n  if (particleAge > -EPSILON && trailStartAge > -EPSILON && trailStartAge < particleLifeTime + EPSILON)\n  {\n    if (particleAge < trailStartAge)\n    {\n      motionAge = particleAge;\n      vOverTimeRatio = 0.;\n    }\n    else if (particleAge < trailStartAge + trailLifeTime)\n    {\n      motionAge = trailStartAge;\n      vOverTimeRatio = (particleAge - trailStartAge)/trailLifeTime;\n    }\n  }\n\n#elif defined(USE_RIBBON_TRAILS) || defined(USE_RIBBON_3D_TRAILS)\n\n  // +1 to the trailID0 because the ribbon needs two elements to start\n  // we cap the particleAge to ensure it never goes past the particleLifeTime\n  float cappedParticleAge = min( particleLifeTime - trailInterval, particleAge );\n  float trailID0 = floor( cappedParticleAge / trailInterval ) + 1.;\n  float rawTrailID = floor( mod( vertexID / VERTS_PER_RIBBON, trailCount ) );\n  float trailID = max( 0., trailID0 - ( trailCount - 1. - rawTrailID ) ); // newest last\n\n  float trailStartAge = trailID * trailInterval;\n\n  if (particleAge > -EPSILON && trailStartAge > -EPSILON && trailStartAge < particleLifeTime + EPSILON)\n  {\n    // motionAge will typically be the trailStartAge, but the lead particle will be the \n    // cappedParticleAge, and the last particle will be the particleAge - trailLifeTime\n\n    motionAge = min( cappedParticleAge, max( particleAge - trailLifeTime, trailStartAge ) );\n    vOverTimeRatio = ( particleAge - motionAge ) / trailLifeTime;\n  }\n  else\n  {\n    motionAge = particleLifeTime;\n    vOverTimeRatio = 1.0;\n  }\n\n#else // defined(USE_PARTICLE_TRAILS) || defined(USE_RIBBON_TRAILS) || defined(USE_RIBBON_3D_TRAILS)\n\n  motionAge = particleAge;\n  vOverTimeRatio = particleAge/particleLifeTime;\n\n#endif // defined(USE_PARTICLE_TRAILS) || defined(USE_RIBBON_TRAILS) || defined(USE_RIBBON_3D_TRAILS)\n\n  // these checks were around large blocks of code above, but this caused instability\n  // in some of the particle systems, so instead we do all of the work, then cancel \n  // it out here\n  if ( particleStartTime < 0. || vertexID < 0. )\n  {\n    vOverTimeRatio = -1.;\n  }\n\n#if defined(USE_PARTICLE_DRAG)\n  // simulate drag by blending the motionAge to (1-.5*drag)*particleLifeTime\n  float drag = params[2].w;\n  motionAge = mix( .5*drag*vOverTimeRatio, 1. - .5*drag, vOverTimeRatio ) * particleLifeTime;\n#endif\n\n  vec3 p = vec3(0.); // position\n  vec3 v = vec3(0.); // velocity\n  vec3 a = vec3(0.); // acceleration\n  vec3 av = vec3(0.); // angular velocity\n  vec3 aa = vec3(0.); // angular acceleration\n  vec3 axis = vec3( 1., 0., 0. ); // axis of orbital motion\n  float ov = 0.; // orbital velocity\n  float oa = 0.; // orbital acceleration\n  vec3 dest = vec3(0.); // destination position\n  float destWeight = 0.; // destination weighting\n\n#if defined(USE_PARTICLE_OFFSET)\n  p = randVec3Range( offset[0].xyz, offset[1].xyz, seed );\n#endif\n\n#if defined(USE_PARTICLE_VELOCITY)\n  v = randVec3Range( velocity[0].xyz, velocity[1].xyz, seed );\n#endif\n\n#if defined(USE_PARTICLE_ACCELERATION)\n  a = randVec3Range( acceleration[0].xyz, acceleration[1].xyz, seed );\n#endif\n\n#if defined(USE_PARTICLE_RADIAL_OFFSET) || defined(USE_PARTICLE_RADIAL_VELOCITY) || defined(USE_PARTICLE_RADIAL_ACCELERATION)\n  vec2 ANGLE_RANGE[2];\n  vec2 radialDir = vec2( radialTypeX, radialTypeY );\n  ANGLE_RANGE[0] = vec2( 0., 0. ) * radialDir;\n  ANGLE_RANGE[1] = vec2( 2.*PI, 2.*PI ) * radialDir;\n\n  vec2 theta = randVec2Range( ANGLE_RANGE[0], ANGLE_RANGE[1], seed );\n#endif\n\n#if defined(USE_PARTICLE_RADIAL_OFFSET)\n  float pr = randFloatRange( offset[0].w, offset[1].w, seed );\n  vec3 p2 = radialToVec3( pr, theta );\n  p += p2;\n#endif\n\n#if defined(USE_PARTICLE_RADIAL_VELOCITY)\n  float vr = randFloatRange( velocity[0].w, velocity[1].w, seed );\n  vec3 v2 = radialToVec3( vr, theta );\n  v += v2;\n#endif\n\n#if defined(USE_PARTICLE_RADIAL_ACCELERATION)\n  float ar = randFloatRange( acceleration[0].w, acceleration[1].w, seed );\n  vec3 a2 = radialToVec3( ar, theta );\n  a += a2;\n#endif\n\n#if defined(USE_PARTICLE_ANGULAR_VELOCITY)\n  av = randVec3Range( angularVelocity[0].xyz, angularVelocity[1].xyz, seed );\n#endif\n\n#if defined(USE_PARTICLE_ANGULAR_ACCELERATION)\n  aa = randVec3Range( angularAcceleration[0].xyz, angularAcceleration[1].xyz, seed );\n#endif\n\n#if defined(USE_PARTICLE_ORBITAL)\n  if ( length(p) > EPSILON ) {\n    ov = randFloatRange( orbital[0].x, orbital[1].x, seed );\n    float oa = randFloatRange( orbital[0].y, orbital[1].y, seed );\n    float angle = displacement1D(ov, oa, motionAge);\n\n    vec3 randomOribit = vec3( random( seed ), random( seed ), random( seed ) ); // should never equal p or 0,0,0\n    axis = normalize( cross( normalize( p ), normalize( randomOribit ) ) );\n  }\n#endif\n\n#if defined(USE_PARTICLE_DESTINATION)\n  destWeight = randFloatRange( destination[0].w, destination[1].w, seed );\n  dest = randVec3Range( destination[0].xyz, destination[1].xyz, seed );\n#endif\n\n  vec3 transformed = particleMotion( p, v, a, av, aa, axis, ov, oa, dest, motionAge/particleLifeTime*destWeight, motionAge );\n\n  vec2 rotScale = calcRotationScaleOverTime( vOverTimeRatio, seed );\n  float particleScale = rotScale.y;\n  float c = cos( rotScale.x );\n  float s = sin( rotScale.x );\n\n  vParticleColor = calcColorOverTime( vOverTimeRatio, seed ); // rgba format\n\n#if defined(USE_PARTICLE_VELOCITY_SCALE)\n  // We repeat all of the displacement calculations at motionAge + a small amount (velocityScaleDelta).\n  // We convert the current position and the future position in screen space and determine\n  // the screen space velocity. VelocityScaleDelta is reasonably small to give better\n  // results for the angular and orbital displacement, and when drag is applied the effective\n  // velocity will tend to 0 as the vOverTimeRatio increases\n\n  float velocityScaleDelta = .02;\n\n#if defined(USE_PARTICLE_DRAG)\n  float futureT = motionAge + velocityScaleDelta*mix(1., 1. - drag, vOverTimeRatio);\n#else\n  float futureT = motionAge + velocityScaleDelta;\n#endif\n\n  vec4 pos2D = projectionMatrix * modelViewMatrix * vec4( transformed, 1. );\n\n  // use min(1) to ensure the particle stops at the destination position\n  vec3 transformedFuture = particleMotion( p, v, a, av, aa, axis, ov, oa, dest, min( 1., futureT/particleLifeTime )*destWeight, futureT );\n\n  vec4 pos2DFuture = projectionMatrix * modelViewMatrix * vec4( transformedFuture, 1. );\n\n  vec2 screen = pos2DFuture.xy / pos2DFuture.z - pos2D.xy / pos2D.z; // TODO divide by 0?\n  screen /= velocityScaleDelta; // gives screen units per second\n\n  float lenScreen = length( screen );\n  vec2 sinCos = vec2(screen.x, screen.y)/max( EPSILON, lenScreen); // 0 degrees is y == 1, x == 0\n  float c2 = c*sinCos.y + s*sinCos.x; // cos(a-b)\n  float s2 = s*sinCos.y - c*sinCos.x; // sin(a-b)\n\n  // replace rotation with our new rotation\n  c = c2;\n  s = s2;\n\n  // rescale the particle length by the z depth, because perspective will be applied later\n  float screenScale = clamp( lenScreen * pos2D.z * velocityScale.x, velocityScale.y, velocityScale.z );\n\n  particleScale *= screenScale;\n\n#endif // defined(USE_PARTICLE_VELOCITY_SCALE)\n\n  vCosSinRotation = vec2( c, s );\n\n  // #include <color_vertex>\n  // #include <begin_vertex> replaced by code above\n  // #include <morphtarget_vertex>\n  // #include <project_vertex> replaced below\n\n#if defined(USE_RIBBON_3D_TRAILS)\n  float ribbonID = mod( vertexID, VERTS_PER_RIBBON );\n  \n  {\n    float nextT = motionAge + trailInterval;\n    float ribbonWidth = params[4].x * ribbonShape( vOverTimeRatio );\n\n    vec3 nextPosition = particleMotion( p, v, a, av, aa, axis, ov, oa, dest, min( 1., nextT/particleLifeTime )*destWeight, nextT );\n    vec3 dir = nextPosition - transformed;\n    float dirLen = length( dir );\n\n    vec3 normal = dir;\n    vec3 up = vec3( 0., c, -s ); // rotation in YZ\n    if ( dirLen > EPSILON && abs( dot( dir, up ) ) < dirLen * 0.99 ) {\n      normal = normalize( cross( up, dir ) );\n    }\n\n    transformed += ribbonWidth * normal * ( 0.5 - ribbonID );  // +normal for ribbonID 0, -normal for ribbonID 1\n  }\n#endif\n\n  vec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );\n  gl_Position = projectionMatrix * mvPosition;\n\n  float usePerspective = params[2].y;\n\n#if defined(USE_RIBBON_TRAILS)\n  float ribbonID = mod( vertexID, VERTS_PER_RIBBON );\n  \n  {\n    mat4 m = projectionMatrix * modelViewMatrix;\n    vec2 curr = toScreen( gl_Position );\n\n    float nextT = motionAge + trailInterval;\n    vec3 nextPosition = particleMotion( p, v, a, av, aa, axis, ov, oa, dest, min( 1., nextT/particleLifeTime )*destWeight, nextT );\n    vec2 next2D = toScreen( m * vec4( nextPosition, 1. ) ) - curr;\n\n    vec2 dir = normalize( next2D );\n    vec2 normal = vec2( -dir.y, dir.x );\n\n    float ribbonWidth = params[4].x * ribbonShape( vOverTimeRatio );\n    float halfWidth = .5 * ribbonWidth * mix( 1., 1. / - mvPosition.z, usePerspective );\n  \n    gl_Position.xy += halfWidth * normal * ( 1. - ribbonID * 2. ); // +normal for ribbonID 0, -normal for ribbonID 1\n  }\n#endif\n\n#if defined(USE_PARTICLE_SCREEN_DEPTH_OFFSET)\n  float screenDepthOffset = params[3].w;\n\n#if defined(USE_PARTICLE_TRAILS) || defined(USE_RIBBON_TRAILS) || defined(USE_RIBBON_3D_TRAILS)\n  // multiply trailCount by 2 because trailID ranges from [-trailCount, trailCount]\n  gl_Position.z -= (particleID*trailCount*2. + trailID - trailID0)*gl_Position.w*screenDepthOffset/vertexCount;\n#else\n  gl_Position.z -= particleID*gl_Position.w*screenDepthOffset/vertexCount;\n#endif\n\n#endif // defined(USE_PARTICLE_SCREEN_DEPTH_OFFSET)\n\n// vFrame is an int, but we must pass it as a float, so add .5 now and floor() in the\n// fragment shader to ensure there is no rounding error\n#if defined(USE_PARTICLE_RANDOMIZE_FRAMES)\n  vFrame = floor ( random( seed ) * textureFrames.z ) + .5;\n#else\n  float textureCount = textureFrames.z;\n  float textureLoop = textureFrames.w;\n\n  vFrame = floor( mod( vOverTimeRatio * textureCount * textureLoop, textureCount ) ) + .5;\n#endif\n\n#if !defined(USE_RIBBON_TRAILS) && !defined(USE_RIBBON_3D_TRAILS)\n  float particleSize = params[2].x;\n\n  gl_PointSize = particleSize * particleScale * mix( 1., 1. / - mvPosition.z, usePerspective );\n#endif\n\n  // #include <logdepthbuf_vertex>\n  // #include <clipping_planes_vertex>\n  // #include <worldpos_vertex>\n  #include <fog_vertex>\n\n#if defined(USE_RIBBON_TRAILS) || defined(USE_RIBBON_3D_TRAILS)\n  float ribbonUVMultiplier = params[4].y;\n  float ribbonUVType = params[4].z;\n\n  vUv = vec2( mix( 1. - vOverTimeRatio, motionAge/trailInterval, ribbonUVType ) * ribbonUVMultiplier, 1. - ribbonID );\n#endif\n}",y="\n#include <common>\n#include <packing>\n// #include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n// #include <logdepthbuf_pars_fragment>\n// #include <clipping_planes_pars_fragment>\n\nuniform vec4 textureFrames;\nuniform vec3 emitterColor;\n\nvarying vec4 vParticleColor;\nvarying vec2 vCosSinRotation;\nvarying vec2 vUv;\nvarying float vOverTimeRatio;\nvarying float vFrame;\n\nvoid main() {\n  if ( vOverTimeRatio < 0. || vOverTimeRatio > 1. ) {\n    discard;\n  }\n\n  #include <clipping_planes_fragment>\n\n  vec3 outgoingLight = vec3( 0. );\n  vec4 diffuseColor = vec4( emitterColor, 1. );\n  mat3 uvTransform = mat3( 1. );\n\n#if defined(USE_PARTICLE_ROTATION) || defined(USE_PARTICLE_FRAMES) || defined(USE_PARTICLE_VELOCITY_SCALE)\n  {\n    vec2 invTextureFrame = 1. / textureFrames.xy;\n    float textureCount = textureFrames.z;\n    float textureLoop = textureFrames.w;\n\n    float frame = floor(vFrame);\n    float c = vCosSinRotation.x;\n    float s = vCosSinRotation.y;\n    float tx = mod( frame, textureFrames.x ) * invTextureFrame.x;\n    float ty = (textureFrames.y - 1. - floor( frame * invTextureFrame.x )) * invTextureFrame.y; // assumes textures are flipped on y\n    float sx = invTextureFrame.x;\n    float sy = invTextureFrame.y;\n    float cx = tx + invTextureFrame.x * .5;\n    float cy = ty + invTextureFrame.y * .5;\n  \n    uvTransform[0][0] = sx * c;\n    uvTransform[0][1] = -sx * s;\n    uvTransform[1][0] = sy * s;\n    uvTransform[1][1] = sy * c;\n    uvTransform[2][0] = c * tx + s * ty - ( c * cx + s * cy ) + cx;\n    uvTransform[2][1] = -s * tx + c * ty - ( -s * cx + c * cy ) + cy;\n  }\n#endif // defined(USE_PARTICLE_ROTATION) || defined(USE_PARTICLE_FRAMES) || defined(USE_PARTICLE_VELOCITY_SCALE)\n\n  // #include <logdepthbuf_fragment>\n  // #include <map_particle_fragment>\n  // #include <color_fragment>\n\n#ifdef USE_MAP\n\n#if defined(USE_RIBBON_TRAILS) || defined(USE_RIBBON_3D_TRAILS)\n  vec2 uv = ( uvTransform * vec3( vUv, 1. ) ).xy;\n#else\n  vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1. ) ).xy;\n#endif\n\n  vec4 mapTexel = texture2D( map, uv );\n  diffuseColor *= mapTexelToLinear( mapTexel );\n#endif // USE_MAP\n\n  #include <alphatest_fragment>\n\n  diffuseColor *= vParticleColor;\n  outgoingLight = diffuseColor.rgb;\n\n  gl_FragColor = diffuseColor;\n\n  // #include <premultiplied_alpha_fragment>\n  // #include <tonemapping_fragment>\n  // #include <encodings_fragment>\n  #include <fog_fragment>\n}"},function(e,t,n){"use strict";n.r(t);n(0),n(1),n(2);function i(){let e,t,n=[];function i(){if(e&&t)for(let i of n)i.removeEventListener(e,t)}function a(e,t,n){if(""==t)return[e];switch(n){case"self":return e.querySelectorAll(t)||[e];case"parent":return e.parentNode.querySelectorAll(t)||[e];case"document":default:return document.querySelectorAll(t)||[e]}}return{set:function(r,o,s,l,c){i(),n=a(r,o,s),e=l,t=c},add:function(){if(e&&t)for(let i of n)i.addEventListener(e,t)},remove:i,getElementsInScope:a}}function a(){let e,t,n,i;function a(i,a){r(),i>0?(e=setTimeout(a,1e3*i),t=Date.now(),n=a):a()}function r(){clearTimeout(self.sendEventTimer),e=void 0,t=void 0,i=void 0,n=void 0}return{start:a,stop:r,pause:function(){if(e){let e=Date.now()-t;r(),i=e}},resume:function(){i&&(a(i,n),i=void 0)}}}function r(e){let t=function(e){let t={type:"",id:"",classes:[],attrs:{}},n="type",i=0,a="";const r=(r,o)=>{let s=e.slice(i,o);if(o>i)switch(n){case"type":case"id":t[n]=s;break;case"class":t.classes.push(s);break;case"attr":a=s;break;case"value":a&&(t.attrs[a]=s)}n=r,i=o+1};for(let t=0,i=e.length;t<i;t++)switch(e[t]){case"\\":t++;break;case"#":"attr"!==n&&"value"!==n&&r("id",t);break;case".":"attr"!==n&&"value"!==n&&r("class",t);break;case"[":"attr"!==n&&"value"!==n&&r("attr",t);break;case"]":"attr"!==n&&"value"!==n||r("none",t);break;case"=":"attr"===n&&r("value",t)}return r("end",e.length),t}(e),n=t.type||"a-entity",i=document.createElement(n);if(i){t.id&&(i.id=t.id),t.classes.length>0&&i.classList.add(...t.classes);for(let e in t.attrs)AFRAME.utils.entity.setComponentProperty(i,e,o(t.attrs[e]))}return i}function o(e){const t="'"===(e=e.trim())[0]||'"'===e[0]?1:0,n=e.length;let i="'"===e[n-1]||'"'===e[n-1]?n-1:n;return 0===t&&i===n?e:e.slice(t,i)}function s(){const e=4294967295;let t=-1;function n(){return t<0?Math.random():(t=(1664525*t+1013904223)%e)/e}return{setSeed:function(e){t=e},random:n,randomInt:function(e){return~~(n()*e)},randomNumber:function(e,t){return e===t?e:n()*(t-e)+e}}}function l(e,t){let n=e,i=t.slice().reverse();for(;n&&i.length>0;)n=n[i.pop()];return n}function c(e){if("object"==typeof e){if(Array.isArray(e))return e.map(c);if(e instanceof THREE.Color)return"#"+e.getHexString();if("x"in e||"y"in e||"z"in e||"w"in e)return AFRAME.utils.coordinates.stringify(e)}return e.toString()}AFRAME.registerComponent("wait-add-remove",{schema:{delay:{default:0},event:{default:""},source:{default:""},sourceScope:{default:"document",oneOf:["parent","self","document"]},add:{type:"array"},addRepeat:{type:"int",default:1},remove:{type:"array"}},multiple:!0,init(){this.addRemoveEntities=this.addRemoveEntities.bind(this),this.startDelay=this.startDelay.bind(this),this.waitTimer=a(),this.waitListener=i()},update(e){const t=this.data;e.event===t.event&&e.source===t.source&&e.sourceScope===t.sourceScope||this.waitListener.set(this.el,t.source,t.sourceScope,t.event,this.startDelay),e.delay===t.delay||!this.timer&&""!==t.event||this.startDelay()},pause(){this.waitTimer.pause(),this.waitListener.remove()},play(){this.waitListener.add(),this.waitTimer.resume()},startDelay(){this.waitTimer.start(this.data.delay,this.addRemoveEntities)},addRemoveEntities(){const e=this.data;for(let t of e.remove){this.el.querySelectorAll(t).forEach(e=>this.el.removeChild(e))}for(let t=0;t<e.addRepeat;++t)for(let t of e.add){let e=r(t);e&&this.el.appendChild(e)}}}),console.assert("hello"===l({a:1,b:{c:{x:"hello"},d:3}},["b","c","x"])),console.assert(void 0===l({a:1,b:{c:{x:"hello"},d:3}},["b","c","y"])),console.assert(1===l({a:1,b:{c:{x:"hello"},d:3}},["a"])),console.assert(void 0===l({a:1,b:{c:{x:"hello"},d:3}},["b","w"]));const d=(()=>{const e=e=>e.trim(),t={rotation:e=>isNaN(e)?0:THREE.Math.degToRad(e),position:e=>isNaN(e)?0:e,scale:e=>isNaN(e)?1:e};return function(n,i,a){let r=t[i];if(r)return Array.isArray(a)||(a="object"==typeof a?[a.x,a.y,a.z]:a.split(" ").map(e)),a.length=3,void n.object3D[i].set(...a.map(r));const o=i.split(".");if(o.length<=2)return o[0]=o[0].replace(/[A-Z]/g,e=>"-"+e.toLowerCase()),void AFRAME.utils.entity.setComponentProperty(n,o.join("."),c(a));const s=l(n,o);s?s[part]=Array.isArray(a)&&1===a.length?a[0]:a:console.warn(`unknown path for setProperty() '${i}'`)}})(),u=function(){const e="undefined"!=typeof THREE,t=e?new THREE.Color:void 0,n=e?new THREE.Color(0,0,0):void 0,i=e=>Number(e.trim());let a=e?new THREE.Color:void 0;return function(r){if(""===r)return{type:"any",value:""};let o=r.split(" ").filter(e=>""!==e).map(i);if(!o.every(isNaN))return{type:"numbers",value:o};if(e){let e=console.warn;console.warn=(()=>{});let i=new THREE.Color(r.trim());if(i.equals(t)&&a.copy(n).setStyle(r).equals(n)&&(i=void 0),console.warn=e,i)return{type:"color",value:i}}return{type:"string",value:r.trim()}}}();function f(e){return e.trim()}function h(e){let t=e.split("..");if(t.length>1){const n=u(t[0]),i=u(t[1]);if(n.type===i.type||"any"===n.type||"any"===i.type)return{type:"any"!==n.type?n.type:i.type,range:[n.value,i.value]};console.error(`incompatible types for range ${e}`)}return{type:"string",options:e.split("|").map(f)}}function m(e,t,n){const i=t[0],a=t[1],r=(e,t)=>e===t?e:n()*(t-e)+e;if("numbers"===e){const e=Math.min(i.length,a.length);let t=a.length>e?a.slice():i.slice();for(let n=0;n<e;n++)t[n]=r(i[n],a[n]);return t}return"color"===e?new THREE.Color(r(i.r,a.r),r(i.g,a.g),r(i.b,a.b)):n()>.5?i:a}AFRAME.registerComponent("wait-set",{schema:{delay:{default:0},event:{default:""},source:{default:""},sourceScope:{default:"document",oneOf:["parent","self","document"]},target:{default:""},targetScope:{default:"document",oneOf:["parent","self","document"]},seed:{type:"int",default:-1}},multiple:!0,init(){this.setProperties=this.setProperties.bind(this),this.startDelay=this.startDelay.bind(this),this.rules={},this.sources=[],this.waitListener=i(),this.waitTimer=a(),this.psuedoRandom=s()},remove(){this.waitListener.remove(),this.waitTimer.stop()},updateSchema(e){const t=AFRAME.components[this.name].schema;let n={};for(let i in e)i in t||(n[i]={default:""});Object.keys(n).length>0&&this.extendSchema(n)},update(e){const t=AFRAME.components[this.name].schema,n=this.data;n.seed!==e.seed&&this.psuedoRandom.setSeed(n.seed);for(let e in this.rules)e in n||delete this.rules[e];for(let i in n)i in t||n[i]===e[i]||(this.rules[i]=h(n[i]));n.event===e.event&&n.source===e.source&&n.sourceScope===e.sourceScope||this.waitListener.set(this.el,n.source,n.sourceScope,n.event,this.startDelay),n.delay===e.delay||!this.delayTimer&&""!==n.event||this.startDelay()},pause(){this.waitListener.remove(),this.waitTimer.pause()},play(){this.waitTimer.resume(),this.waitListener.add()},startDelay(){this.waitTimer.start(this.data.delay,this.setProperties)},setProperties(){const e=this.waitListener.getElementsInScope(this.el,this.data.target,this.data.targetScope);for(let i of e)for(let e in this.rules){let a=this.rules[e];const r=a.options?(t=a.options,n=this.psuedoRandom.random,t[Math.floor(n()*t.length)]):m(a.type,a.range,this.psuedoRandom.random);d(i,e,r)}var t,n}});const p={Linear:{None:function(e){return e}},Quadratic:{In:function(e){return e*e},Out:function(e){return e*(2-e)},InOut:function(e){return(e*=2)<1?.5*e*e:-.5*(--e*(e-2)-1)}},Cubic:{In:function(e){return e*e*e},Out:function(e){return--e*e*e+1},InOut:function(e){return(e*=2)<1?.5*e*e*e:.5*((e-=2)*e*e+2)}},Quartic:{In:function(e){return e*e*e*e},Out:function(e){return 1- --e*e*e*e},InOut:function(e){return(e*=2)<1?.5*e*e*e*e:-.5*((e-=2)*e*e*e-2)}},Quintic:{In:function(e){return e*e*e*e*e},Out:function(e){return--e*e*e*e*e+1},InOut:function(e){return(e*=2)<1?.5*e*e*e*e*e:.5*((e-=2)*e*e*e*e+2)}},Sinusoidal:{In:function(e){return 1-Math.cos(e*Math.PI/2)},Out:function(e){return Math.sin(e*Math.PI/2)},InOut:function(e){return.5*(1-Math.cos(Math.PI*e))}},Exponential:{In:function(e){return 0===e?0:Math.pow(1024,e-1)},Out:function(e){return 1===e?1:1-Math.pow(2,-10*e)},InOut:function(e){return 0===e?0:1===e?1:(e*=2)<1?.5*Math.pow(1024,e-1):.5*(2-Math.pow(2,-10*(e-1)))}},Circular:{In:function(e){return 1-Math.sqrt(1-e*e)},Out:function(e){return Math.sqrt(1- --e*e)},InOut:function(e){return(e*=2)<1?-.5*(Math.sqrt(1-e*e)-1):.5*(Math.sqrt(1-(e-=2)*e)+1)}},Elastic:{In:function(e){return 0===e?0:1===e?1:-Math.pow(2,10*(e-1))*Math.sin(5*(e-1.1)*Math.PI)},Out:function(e){return 0===e?0:1===e?1:Math.pow(2,-10*e)*Math.sin(5*(e-.1)*Math.PI)+1},InOut:function(e){return 0===e?0:1===e?1:(e*=2)<1?-.5*Math.pow(2,10*(e-1))*Math.sin(5*(e-1.1)*Math.PI):.5*Math.pow(2,-10*(e-1))*Math.sin(5*(e-1.1)*Math.PI)+1}},Back:{In:function(e){var t=1.70158;return e*e*((t+1)*e-t)},Out:function(e){var t=1.70158;return--e*e*((t+1)*e+t)+1},InOut:function(e){var t=2.5949095;return(e*=2)<1?e*e*((t+1)*e-t)*.5:.5*((e-=2)*e*((t+1)*e+t)+2)}},Bounce:{In:function(e){return 1-p.Bounce.Out(1-e)},Out:function(e){return e<1/2.75?7.5625*e*e:e<2/2.75?7.5625*(e-=1.5/2.75)*e+.75:e<2.5/2.75?7.5625*(e-=2.25/2.75)*e+.9375:7.5625*(e-=2.625/2.75)*e+.984375},InOut:function(e){return e<.5?.5*p.Bounce.In(2*e):.5*p.Bounce.Out(2*e-1)+.5}}},v={linear:p.Linear.None,ease:p.Cubic.InOut,"ease-in":p.Cubic.In,"ease-out":p.Cubic.Out,"ease-in-out":p.Cubic.InOut,"ease-cubic":p.Cubic.In,"ease-in-cubic":p.Cubic.In,"ease-out-cubic":p.Cubic.Out,"ease-in-out-cubic":p.Cubic.InOut,"ease-quad":p.Quadratic.InOut,"ease-in-quad":p.Quadratic.In,"ease-out-quad":p.Quadratic.Out,"ease-in-out-quad":p.Quadratic.InOut,"ease-quart":p.Quartic.InOut,"ease-in-quart":p.Quartic.In,"ease-out-quart":p.Quartic.Out,"ease-in-out-quart":p.Quartic.InOut,"ease-quint":p.Quintic.InOut,"ease-in-quint":p.Quintic.In,"ease-out-quint":p.Quintic.Out,"ease-in-out-quint":p.Quintic.InOut,"ease-sine":p.Sinusoidal.InOut,"ease-in-sine":p.Sinusoidal.In,"ease-out-sine":p.Sinusoidal.Out,"ease-in-out-sine":p.Sinusoidal.InOut,"ease-expo":p.Exponential.InOut,"ease-in-expo":p.Exponential.In,"ease-out-expo":p.Exponential.Out,"ease-in-out-expo":p.Exponential.InOut,"ease-circ":p.Circular.InOut,"ease-in-circ":p.Circular.In,"ease-out-circ":p.Circular.Out,"ease-in-out-circ":p.Circular.InOut,"ease-elastic":p.Elastic.InOut,"ease-in-elastic":p.Elastic.In,"ease-out-elastic":p.Elastic.Out,"ease-in-out-elastic":p.Elastic.InOut,"ease-back":p.Back.InOut,"ease-in-back":p.Back.In,"ease-out-back":p.Back.Out,"ease-in-out-back":p.Back.InOut,"ease-bounce":p.Bounce.InOut,"ease-in-bounce":p.Bounce.In,"ease-out-bounce":p.Bounce.Out,"ease-in-out-bounce":p.Bounce.InOut};function T(e){let t="any";for(let n of e)"any"!==n.type&&n.type!==t&&("any"===t?t=n.type:console.warn(`incompatible type found '${n.type}', expecting '${t}'`));return t}function g(e){const t=e.split("|");if(t.length>1){const e=t.map(u);return{options:e.map(e=>e.value),type:T(e)}}const n=e.split("..");if(n.length>1){const e=n.map(u);return{range:e.map(e=>e.value),type:T(e)}}const i=u(e);return{value:i.value,type:i.type}}function y(e){let t=e.split(",").map(g);return{type:T(t),slots:t.map(e=>"range"in e?{range:e.range}:"options"in e?{options:e.options}:"value"in e?{value:e.value}:void 0)}}const E={value:(e,t,n)=>t,options:(e,t,n)=>t[~~(n()*t.length)],range:function(e,t,n){const i=t[0],a=t[1],r=(e,t)=>e===t?e:n()*(t-e)+e;if("numbers"===e){const e=Math.min(i.length,a.length);let t=a.length>e?a.slice():i.slice();for(let n=0;n<e;n++)t[n]=r(i[n],a[n]);return t}return"color"===e?new THREE.Color(r(i.r,a.r),r(i.g,a.g),r(i.b,a.b)):n()>.5?i:a}};function b(e,t){let n;return e.slots.map(i=>{const a=Object.keys(i)[0];let r=i[a];return Array.isArray(r)&&r.includes("")?(console.assert(void 0!==n),r=r.map(e=>""===e?n:e)):""===r&&(console.assert(void 0!==n),r=n),n=E[a](e.type,r,t)})}function R(e,t,n,i){return e}const A={numbers:function(e,t,n,i){const a=Math.min(e.length,t.length);i.length=Math.max(e.length,t.length);for(let r=0;r<a;r++)i[r]=THREE.Math.lerp(e[r],t[r],n);for(let t=a;t<e.length;t++)i[t]=e[t];for(let e=a;e<t.length;e++)i[e]=t[e];return i},color:function(e,t,n,i){return i.setRGB(e.r,e.g,e.b).lerp(t,n)},string:R,boolean:R,any:R};let I={numbers:[],color:new THREE.Color,string:"",boolean:!1,any:""};function S(e,t,n,i){const a=t.length;if(n<=0||a<=1)return t[0];if(n>=1)return t[a-1];const r=n*(a-1),o=~~r,s=i(r-o);return A[e](t[o],t[o+1],s,I[e])}AFRAME.registerComponent("keyframe",{schema:{enableInEditor:{default:!1},duration:{default:1},direction:{default:"forward",oneOf:["forward","backward","alternate"]},loops:{default:-1},seed:{default:-1,type:"int"},easing:{default:"linear",oneOf:Object.keys(v)},randomizeEachLoop:{default:!0}},multiple:!0,init(){this.pauseTick=this.pauseTick.bind(this),this.pseudoRandom=s(),this.loopTime=0,this.loops=0,this.keys={},this.rules={}},updateSchema(e){const t=AFRAME.components[this.name].schema;let n={};for(let i in e)i in t||(n[i]={type:"string"});Object.keys(n).length>0&&this.extendSchema(n)},update(e){const t=this.data,n=AFRAME.components[this.name].schema;e.seed!==t.seed&&this.pseudoRandom.setSeed(t.seed);for(let e in this.rules)e in t||(delete this.rules[e],delete this.keys[e]);for(let i in t)e[i]===t[i]||i in n||(this.rules[i]=y(t[i]),this.guessMissingFirstValue(i,this.rules[i]),this.keys[i]=b(this.rules[i],this.pseudoRandom.random));e.duration===t.duration&&e.loops===t.loops||(this.loopTime=0,this.loops=0),e.direction!==t.direction&&(this.forward="backward"!==t.direction,this.loopTime=this.forward?0:t.duration),t.enableInEditor!==e.enableInEditor&&this.enablePauseTick(t.enableInEditor)},tick(e,t){const n=Math.min(t,100)/1e3;this.step(n)},pause(){this.enablePauseTick(this.data.enableInEditor)},play(){this.enablePauseTick(!1)},enablePauseTick(e){e?this.pauseRAF=requestAnimationFrame(this.pauseTick):cancelAnimationFrame(this.pauseRAF)},pauseTick(){this.step(.016),this.enablePauseTick(!0)},step(e){const t=this.data;if((t.loops<0||this.loops<t.loops)&&t.duration>0){let n=!1;if(this.loopTime=this.loopTime+(this.forward?e:-e),(this.loopTime>t.duration||this.loopTime<0)&&(this.loops++,n=!0),n&&(t.loops<0||this.loops<t.loops)&&("alternate"===t.direction?(this.forward=!this.forward,this.loopTime=this.loopTime<0?-this.loopTime:2*t.duration-this.loopTime):this.loopTime=this.loopTime+(this.forward?-t.duration:t.duration),t.randomizeEachLoop))for(let e in this.keys)this.rules[e].slots.some(e=>!("value"in e))&&(this.keys[e]=b(this.rules[e],this.pseudoRandom.random));const i=v[t.easing]||v.linear;for(let e in this.keys){let n=THREE.Math.clamp(this.loopTime/t.duration,0,1);const a=S(this.rules[e].type,this.keys[e],n,i);d(this.el,e,a)}}},guessMissingFirstValue(e,t){if(t.slots.length>0){let n=t.slots[0];const i=""===n.value,a=n.range&&n.range.includes(""),r=n.options&&n.options.includes("");if(i||a||r){let t=u(function(e,t){const n=t.split(".");if(n.length<=2)return c(AFRAME.utils.entity.getComponentProperty(e,t));const i=l(e,n);if(i)return c(i[part]);console.warn(`unknown path for getProperty() '${t}'`)}(this.el,e));i&&(n.value=t.value),a&&(n.range=n.range.map(e=>""===e?t.value:e)),r&&(n.options=n.options.map(e=>""===e?t.value:e))}}}});n(3),n(4)}]);