!function(e){"function"==typeof define&&define.amd?define(e):e()}(function(){"use strict";AFRAME.registerSystem("audio-vis",{schema:{src:{type:"selector"},fftSize:{default:32}},init:function(){this.context=new AudioContext,this.analysers={}},getOrCreateAnalyser:function(){const e=this.data.src,t=(e=>{const t=e.className.split(" ");return e.localName.toLowerCase()+(t[0]?"."+t.join("."):"")+"#"+e.id})(e);if(this.analysers[t])return this.analysers[t];const n=this.data.fftSize;let i=this.context.createAnalyser();return this.context.createMediaElementSource(e).connect(i),i.connect(this.context.destination),i.fftSize=n,i.fetchTime=-1,i.frequencyData=new Uint8Array(n),this.analysers[t]=i,i},getByteFrequencyData:function(e,t){return t!==e.fetchTime&&(e.getByteFrequencyData(e.frequencyData),e.fetchTime=t),e.frequencyData}});const e=e=>Number(e),t=t=>t.trim().split(" ").map(e),n=e=>e.includes(".."),i=e=>e.split("..").map(t),a=(e,t)=>{if(e.length<1)return e[0];let n=[];const i=e[0],a=e[1];for(let e=0,r=Math.max(i.length,a.length);e<r;e++)n[e]=THREE.Math.lerp(i[e]||0,a[e]||0,t);return n},r={bins:{type:"array",default:[0],parse:t=>"string"==typeof t?t.split(",").map(e):t},threshold:{default:0,min:0,max:1}};AFRAME.registerComponent("audio-vis",{schema:r,multiple:!0,init:function(){this.ranges={},this.analyser=this.system.getOrCreateAnalyser()},updateSchema:function(e){let t={};for(let n in e)n in this.schema||(t[n]={type:"string"});(e=>{for(let t in e)if(e.hasOwnProperty(t))return!1;return!0})(t)||this.extendSchema(t)},update:function(e){const t=this.data;for(let e in t)e in r||!n(t[e])||(this.ranges[e]=i(t[e]))},tick:function(e,t){const n=this.data,i=this.system.getByteFrequencyData(this.analyser,e),r=n.bins,o=r.length;let s=0;for(let e of r)s+=i[e];let l=s/o/255,c=l>n.threshold?l:0,d=this.el;for(let e in this.ranges){const t=a(this.ranges[e],c);switch(e){case"position":case"scale":d.object3D[e].set(...t);break;case"rotation":d.object3D[e].set(...t.map(THREE.Math.degToRad));break;default:d.setAttribute(e,t.map(e=>e.toFixed(4)).join(" "))}}}});let o=0;AFRAME.registerComponent("clone-entity",{schema:{type:"selector"},multiple:!0,update(){const e=this.data;let t=document.importNode(e instanceof HTMLTemplateElement?e.content:e,!0);const n=e=>{e.id&&(e.id+="_clone"+o),e.children.forEach(n)};n(t),this.el.appendChild(t),o++}}),AFRAME.registerComponent("clone-geo",{schema:{type:"selector"},init(){this.onObject3DSet=this.onObject3DSet.bind(this)},update(e){if(this.data!==e){e instanceof HTMLElement&&e.removeEventListener("object3dset",this.onObject3DSet);const t=this.data;t instanceof HTMLElement&&t.object3D&&(t.object3D.children.forEach(e=>this.el.object3D.add(e.clone())),this.el.object3DMap=t.object3DMap,t.addEventListener("object3dset",this.onObject3DSet))}},onObject3DSet(e){const t=this.data;e.target===t&&e.detail.type&&this.el.setObject3D(e.detail.type,t.getObject3D(e.detail.type))}});var s={},l={};AFRAME.registerComponent("gltf-part",{schema:{part:{type:"string"},src:{type:"asset"}},update:function(){var e=this.el;!this.data.part&&this.data.src||this.getModel(function(t){t&&e.setObject3D("mesh",t)})},getModel:function(e){var t=this;if(!l[this.data.src])return s[this.data.src]?s[this.data.src].then(function(n){e(t.selectFromModel(n))}):void(s[this.data.src]=new Promise(function(n){(new THREE.GLTFLoader).load(t.data.src,function(i){var a=i.scene||i.scenes[0];l[t.data.src]=a,delete s[t.data.src],e(t.selectFromModel(a)),n(a)},function(){},console.error)}));e(this.selectFromModel(l[this.data.src]))},selectFromModel:function(e){var t;if(t=e.getObjectByName(this.data.part))return t.clone();console.error("[gltf-part] `"+this.data.part+"` not found in model.")}});Object.freeze({x:0,y:0,z:0}),Object.freeze({x:1,y:0,z:0}),Object.freeze({x:0,y:1,z:0}),Object.freeze({x:0,y:0,z:1});const c=Math.sqrt(.5);Object.freeze({x:0,y:0,z:0,w:1}),Object.freeze({x:1,y:0,z:0,w:0}),Object.freeze({x:0,y:1,z:0,w:0}),Object.freeze({x:0,y:0,z:1,w:0}),Object.freeze({x:c,y:0,z:0,w:c}),Object.freeze({x:0,y:c,z:0,w:c}),Object.freeze({x:0,y:0,z:c,w:c});const d=function(){let e=new Float32Array(16);return function(t,n,i,a){if(n&&(n.x=t[12],n.y=t[13],n.z=t[14]),a||i){const n=Math.hypot(t[0],t[1],t[2]),r=Math.hypot(t[4],t[5],t[6]),o=Math.hypot(t[8],t[9],t[10]);if(a&&(a.x=n,a.y=r,a.z=o),i){const a=function(e){const t=e[0],n=e[1],i=e[2],a=e[4],r=e[5],o=e[6],s=e[8],l=e[9],c=e[10];return t*(c*r-o*l)+n*(o*s-c*a)+i*(l*a-r*s)}(t)<0?-1/n:1/n,s=1/r,l=1/o;e.set(t),e[0]*=a,e[1]*=a,e[2]*=a,e[4]*=s,e[5]*=s,e[6]*=s,e[8]*=l,e[9]*=l,e[10]*=l,function(e,t){const n=t[0],i=t[4],a=t[8],r=t[1],o=t[5],s=t[9],l=t[2],c=t[6],d=t[10],u=n+o+d;let h;u>0?(h=.5/Math.sqrt(u+1),e.w=.25/h,e.x=(c-s)*h,e.y=(a-l)*h,e.z=(r-i)*h):n>o&&n>d?(h=2*Math.sqrt(1+n-o-d),e.w=(c-s)/h,e.x=.25*h,e.y=(i+r)/h,e.z=(a+l)/h):o>d?(h=2*Math.sqrt(1+o-n-d),e.w=(a-l)/h,e.x=(i+r)/h,e.y=.25*h,e.z=(s+c)/h):(h=2*Math.sqrt(1+d-n-o),e.w=(r-i)/h,e.x=(a+l)/h,e.y=(s+c)/h,e.z=.25*h)}(i,e)}}return t}}();function u(e,t=Math.random){return e[function(e,t=Math.random){return~~(t()*e)}(e.length,t)]}function h(e,t,n=Math.random){return t===e?e:n()*(t-e)+e}function f(){let e=-1;return{setSeed:function(t){e=t},random:function(){return e<0?Math.random():(e=(1664525*e+1013904223)%4294967296)/4294967296}}}function m(e,t,n){return e<t?t:e>n?n:e}function p(e,t){let n=e,i=t.slice().reverse();for(;n&&i.length>0;)n=n[i.pop()];return n}function v(e){return"r"in e&&"g"in e&&"b"in e}const g=function(){function e(e,t,n){return n<0&&(n+=1),n>1&&(n-=1),n<1/6?e+6*(t-e)*n:n<.5?t:n<2/3?e+6*(t-e)*(2/3-n):e}return function(t,n,i,a){var r;if(n=(n%(r=1)+r)%r,i=m(i,0,1),a=m(a,0,1),0===i)t.r=t.g=t.b=a;else{let r=a<=.5?a*(1+i):a+i-a*i,o=2*a-r;t.r=e(o,r,n+1/3),t.g=e(o,r,n),t.b=e(o,r,n-1/3)}return t}}();const y={aliceblue:15792383,antiquewhite:16444375,aqua:65535,aquamarine:8388564,azure:15794175,beige:16119260,bisque:16770244,black:0,blanchedalmond:16772045,blue:255,blueviolet:9055202,brown:10824234,burlywood:14596231,cadetblue:6266528,chartreuse:8388352,chocolate:13789470,coral:16744272,cornflowerblue:6591981,cornsilk:16775388,crimson:14423100,cyan:65535,darkblue:139,darkcyan:35723,darkgoldenrod:12092939,darkgray:11119017,darkgreen:25600,darkgrey:11119017,darkkhaki:12433259,darkmagenta:9109643,darkolivegreen:5597999,darkorange:16747520,darkorchid:10040012,darkred:9109504,darksalmon:15308410,darkseagreen:9419919,darkslateblue:4734347,darkslategray:3100495,darkslategrey:3100495,darkturquoise:52945,darkviolet:9699539,deeppink:16716947,deepskyblue:49151,dimgray:6908265,dimgrey:6908265,dodgerblue:2003199,firebrick:11674146,floralwhite:16775920,forestgreen:2263842,fuchsia:16711935,gainsboro:14474460,ghostwhite:16316671,gold:16766720,goldenrod:14329120,gray:8421504,green:32768,greenyellow:11403055,grey:8421504,honeydew:15794160,hotpink:16738740,indianred:13458524,indigo:4915330,ivory:16777200,khaki:15787660,lavender:15132410,lavenderblush:16773365,lawngreen:8190976,lemonchiffon:16775885,lightblue:11393254,lightcoral:15761536,lightcyan:14745599,lightgoldenrodyellow:16448210,lightgray:13882323,lightgreen:9498256,lightgrey:13882323,lightpink:16758465,lightsalmon:16752762,lightseagreen:2142890,lightskyblue:8900346,lightslategray:7833753,lightslategrey:7833753,lightsteelblue:11584734,lightyellow:16777184,lime:65280,limegreen:3329330,linen:16445670,magenta:16711935,maroon:8388608,mediumaquamarine:6737322,mediumblue:205,mediumorchid:12211667,mediumpurple:9662683,mediumseagreen:3978097,mediumslateblue:8087790,mediumspringgreen:64154,mediumturquoise:4772300,mediumvioletred:13047173,midnightblue:1644912,mintcream:16121850,mistyrose:16770273,moccasin:16770229,navajowhite:16768685,navy:128,oldlace:16643558,olive:8421376,olivedrab:7048739,orange:16753920,orangered:16729344,orchid:14315734,palegoldenrod:15657130,palegreen:10025880,paleturquoise:11529966,palevioletred:14381203,papayawhip:16773077,peachpuff:16767673,peru:13468991,pink:16761035,plum:14524637,powderblue:11591910,purple:8388736,rebeccapurple:6697881,red:16711680,rosybrown:12357519,royalblue:4286945,saddlebrown:9127187,salmon:16416882,sandybrown:16032864,seagreen:3050327,seashell:16774638,sienna:10506797,silver:12632256,skyblue:8900331,slateblue:6970061,slategray:7372944,slategrey:7372944,snow:16775930,springgreen:65407,steelblue:4620980,tan:13808780,teal:32896,thistle:14204888,tomato:16737095,turquoise:4251856,violet:15631086,wheat:16113331,white:16777215,whitesmoke:16119285,yellow:16776960,yellowgreen:10145074},T=/^((?:rgb|hsl)a?)\(\s*([^\)]*)\)/;function b(e){let t;if(t=T.exec(e)){let e;const n=t[1],i=t[2];switch(n){case"rgb":case"rgba":if(e=/^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(i))return{r:Math.min(255,parseInt(e[1],10))/255,g:Math.min(255,parseInt(e[2],10))/255,b:Math.min(255,parseInt(e[3],10))/255,a:e[5]?parseFloat(e[5]):void 0};if(e=/^(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(i))return{r:Math.min(100,parseInt(e[1],10))/100,g:Math.min(100,parseInt(e[2],10))/100,b:Math.min(100,parseInt(e[3],10))/100,a:e[5]?parseFloat(e[5]):void 0};break;case"hsl":case"hsla":if(e=/^([0-9]*\.?[0-9]+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(i)){const t=g({r:0,g:0,b:0,a:0},parseFloat(e[1])/360,parseInt(e[2],10)/100,parseInt(e[3],10)/100);return t.a=e[5]?parseFloat(e[5]):void 0,t}}}else if(t=/^\#([A-Fa-f0-9]+)$/.exec(e)){const e=t[1],n=e.length;if(3===n)return{r:parseInt(e.charAt(0)+e.charAt(0),16)/255,g:parseInt(e.charAt(1)+e.charAt(1),16)/255,b:parseInt(e.charAt(2)+e.charAt(2),16)/255};if(6===n)return{r:parseInt(e.charAt(0)+e.charAt(1),16)/255,g:parseInt(e.charAt(2)+e.charAt(3),16)/255,b:parseInt(e.charAt(4)+e.charAt(5),16)/255}}if(e&&e.length>0){const t=y[e];if(void 0!==t)return(n={r:0,g:0,b:0}).r=((t=t)>>16&255)/255,n.g=(t>>8&255)/255,n.b=(255&t)/255,n}var n,i}function E(e){const t=function(e){const t=e.split("|");if(t.length>1)return{options:t};const n=e.split("..");if(n.length>1)return{range:[n[0],n[1]]};return{options:t}}(e);return t.range?{range:t.range.map(e=>x(e))}:{options:t.options.map(e=>x(e))}}const x=function(){const e=e=>Number(e.trim());return function(t){if(""===t)return"";let n=t.split(" ").filter(e=>""!==e).map(e);if(!n.some(isNaN))return n;let i=b(t.trim());return i||t.trim()}}();const A=function(){let e={r:0,g:0,b:0},t=[];return function(n,i=Math.random){if(n.range){const i=n.range[0],a=n.range[1];return v(i)?function(e,t,n,i=Math.random){return e.r=h(t.r,n.r,i),e.g=h(t.g,n.g,i),e.b=h(t.b,n.b,i),e}(e,i,a):Array.isArray(i)&&i.length>0&&"number"==typeof i[0]?function(e,t,n,i=Math.random){const a=t.length,r=n.length,o=Math.min(a,r);e.length=Math.max(a,r);for(let a=0;a<o;a++)e[a]=h(t[a],n[a],i);if(r>a)for(let t=o;t<r;t++)e[t]=n[t];else for(let n=o;n<a;n++)e[n]=t[n];return e}(t,i,a):i}if(n.options)return u(n.options,i)}}();function R(e){if("object"==typeof e){if(e.range)return R(e.range[0])+".."+R(e.range[1]);if(e.options)return e.options.map(e=>R(e)).join("|");if(v(e))return"#"+function(e){return 255*e.r<<16^255*e.g<<8^255*e.b<<0}(e).toString(16).padStart(6,"0");if("x"in e&&"y"in e)return e.x+" "+e.y+("z"in e?" "+e.z:"");if(e.length&&"0"in e)return"number"==typeof e[0]?e.join(" "):e.join(",")}return e.toString()}function S(e,t=",",n=["''",'""',"{}","[]","()"]){let i=[],a=[],r=0,o=0;for(let s=0,l=e.length;s<l;s++){const l=e[s];if(a.length>0&&l===a[a.length-1][1])a.pop();else for(let e of n)l===e[0]&&a.push(e);0===a.length&&l===t[o]?++o===t.length&&(i.push(e.substring(r,s-o+1)),r=s+1,o=0):o=0}return i.push(e.substring(r,e.length)),i}const I=(()=>{const e=e=>e.trim(),t={rotation:e=>isNaN(e)?0:THREE.Math.degToRad(e),position:e=>isNaN(e)?0:e,scale:e=>isNaN(e)?1:e};return function(n,i,a){let r=t[i];if(r)return Array.isArray(a)||(a="object"==typeof a?[a.x,a.y,a.z]:a.split(" ").map(e)),a.length=3,void n.object3D[i].set(...a.map(r));const o=i.split(".");if(o.length<=2)return o[0]=o[0].replace(/[A-Z]/g,e=>"-"+e.toLowerCase()),void(a?AFRAME.utils.entity.setComponentProperty(n,o.join("."),R(a)):n.removeAttribute(o.join(".")));const s=p(n,o);s?s[i]=Array.isArray(a)&&1===a.length?a[0]:a:console.warn(`unknown path for setProperty() '${i}'`)}})();function O(e,t,n){return e+(t-e)*n}function w(e){return e}const _={In:function(e){return e*e},Out:function(e){return e*(2-e)},InOut:function(e){return(e*=2)<1?.5*e*e:-.5*(--e*(e-2)-1)}},L={In:function(e){return e*e*e},Out:function(e){return--e*e*e+1},InOut:function(e){return(e*=2)<1?.5*e*e*e:.5*((e-=2)*e*e+2)}},C={In:function(e){return e*e*e*e},Out:function(e){return 1- --e*e*e*e},InOut:function(e){return(e*=2)<1?.5*e*e*e*e:-.5*((e-=2)*e*e*e-2)}},D={In:function(e){return e*e*e*e*e},Out:function(e){return--e*e*e*e*e+1},InOut:function(e){return(e*=2)<1?.5*e*e*e*e*e:.5*((e-=2)*e*e*e*e+2)}},M={In:function(e){return 1-Math.cos(e*Math.PI/2)},Out:function(e){return Math.sin(e*Math.PI/2)},InOut:function(e){return.5*(1-Math.cos(Math.PI*e))}},P={In:function(e){return 0===e?0:Math.pow(1024,e-1)},Out:function(e){return 1===e?1:1-Math.pow(2,-10*e)},InOut:function(e){return 0===e?0:1===e?1:(e*=2)<1?.5*Math.pow(1024,e-1):.5*(2-Math.pow(2,-10*(e-1)))}},k={In:function(e){return 1-Math.sqrt(1-e*e)},Out:function(e){return Math.sqrt(1- --e*e)},InOut:function(e){return(e*=2)<1?-.5*(Math.sqrt(1-e*e)-1):.5*(Math.sqrt(1-(e-=2)*e)+1)}},F={In:function(e){return 0===e?0:1===e?1:-Math.pow(2,10*(e-1))*Math.sin(5*(e-1.1)*Math.PI)},Out:function(e){return 0===e?0:1===e?1:Math.pow(2,-10*e)*Math.sin(5*(e-.1)*Math.PI)+1},InOut:function(e){return 0===e?0:1===e?1:(e*=2)<1?-.5*Math.pow(2,10*(e-1))*Math.sin(5*(e-1.1)*Math.PI):.5*Math.pow(2,-10*(e-1))*Math.sin(5*(e-1.1)*Math.PI)+1}},U={In:function(e){var t=1.70158;return e*e*((t+1)*e-t)},Out:function(e){var t=1.70158;return--e*e*((t+1)*e+t)+1},InOut:function(e){var t=2.5949095;return(e*=2)<1?e*e*((t+1)*e-t)*.5:.5*((e-=2)*e*((t+1)*e+t)+2)}},j={In:function(e){return 1-j.Out(1-e)},Out:function(e){return e<1/2.75?7.5625*e*e:e<2/2.75?7.5625*(e-=1.5/2.75)*e+.75:e<2.5/2.75?7.5625*(e-=2.25/2.75)*e+.9375:7.5625*(e-=2.625/2.75)*e+.984375},InOut:function(e){return e<.5?.5*j.In(2*e):.5*j.Out(2*e-1)+.5}},B={linear:w,ease:L.InOut,"ease-in":L.In,"ease-out":L.Out,"ease-in-out":L.InOut,"ease-cubic":L.In,"ease-in-cubic":L.In,"ease-out-cubic":L.Out,"ease-in-out-cubic":L.InOut,"ease-quad":_.InOut,"ease-in-quad":_.In,"ease-out-quad":_.Out,"ease-in-out-quad":_.InOut,"ease-quart":C.InOut,"ease-in-quart":C.In,"ease-out-quart":C.Out,"ease-in-out-quart":C.InOut,"ease-quint":D.InOut,"ease-in-quint":D.In,"ease-out-quint":D.Out,"ease-in-out-quint":D.InOut,"ease-sine":M.InOut,"ease-in-sine":M.In,"ease-out-sine":M.Out,"ease-in-out-sine":M.InOut,"ease-expo":P.InOut,"ease-in-expo":P.In,"ease-out-expo":P.Out,"ease-in-out-expo":P.InOut,"ease-circ":k.InOut,"ease-in-circ":k.In,"ease-out-circ":k.Out,"ease-in-out-circ":k.InOut,"ease-elastic":F.InOut,"ease-in-elastic":F.In,"ease-out-elastic":F.Out,"ease-in-out-elastic":F.InOut,"ease-back":U.InOut,"ease-in-back":U.In,"ease-out-back":U.Out,"ease-in-out-back":U.InOut,"ease-bounce":j.InOut,"ease-in-bounce":j.In,"ease-out-bounce":j.Out,"ease-in-out-bounce":j.InOut},z=function(){let e={x:0,y:0,z:0},t={x:1,y:1,z:1};return function(n,i,a,r){d(r,void 0,void 0,t),function(e,t,n){const i=t[0],a=t[1],r=t[2],o=t[4],s=t[5],l=t[6],c=t[8],d=t[9],u=t[10],h=t[12],f=t[13],m=t[14],p=u*s-l*d,v=l*c-u*o,g=d*o-s*c,y=1/(i*p+a*v+r*g),T=p*y,b=(r*d-u*a)*y,E=(l*a-r*s)*y,x=v*y,A=(u*i-r*c)*y,R=(r*o-l*i)*y,S=g*y,I=(a*c-d*i)*y,O=(s*i-a*o)*y,w=n.x-h,_=n.y-f,L=n.z-m;e.x=T*w+x*_+S*L,e.y=b*w+A*_+I*L,e.z=E*w+R*_+O*L}(e,r,n);const o=e.x,s=e.y,l=e.z,c=i.x-o,u=i.y-s,h=i.z-l,f=o-a.x,m=s-a.y,p=l-a.z,v=Math.max(f,c)*t.x,g=Math.max(m,u)*t.y,y=Math.max(p,h)*t.z;return v<=0&&g<=0&&y<=0?Math.max(v,g,y):Math.hypot(Math.max(0,v),Math.max(0,g),Math.max(0,y))}}();function N(e,t){for(let n of["map","alphaMap","aoMap","bumpMap","displacementMap","emissiveMap","envMap","lighMap","metalnessMap","normalMap","roughnessMap"])e[n]&&e[n].image===t&&(e[n].needsUpdate=!0)}function V(e,t){e.uniforms&&e.uniforms.map&&e.uniforms.map.value&&"object"==typeof e.uniforms.map.value&&e.uniforms.map.value.image===t&&(e.uniforms.map.value.needsUpdate=!0)}const H=function(){let e=new THREE.Vector3,t=new THREE.Quaternion,n=new THREE.Vector3,i=new THREE.Box3;return function(a,r){return 0===r.children.length?a:(e.copy(r.position),t.copy(r.quaternion),n.copy(r.scale),r.position.set(0,0,0),r.quaternion.set(0,0,0,1),r.scale.set(1,1,1),i.setFromObject(r),r.position.copy(e),r.quaternion.copy(t),r.scale.copy(n),r.updateMatrixWorld(!0),a.min.x=i.min.x,a.min.y=i.min.y,a.min.z=i.min.z,a.max.x=i.max.x,a.max.y=i.max.y,a.max.z=i.max.z,a)}}();function q(e,t,n,i=w){const a=t.length;if(n<=0||a<=1)return t[0];if(n>=1)return t[a-1];const r=n*(a-1),o=~~r,s=i(r-o);switch(e){case"object":return function(e,t,n){let i=Object.assign({},e);for(let a in t)i[a]=void 0!==e[a]?O(e[a],t[a],n):t[a];return i}(t[o],t[o+1],s);case"vector":return function(e,t,n){let i=Array.from(e);for(let a=0;a<t.length;a++)i[a]=void 0!==e[a]?O(e[a],t[a],n):t[a];return i}(t[o],t[o+1],s);case"number":return O(t[o],t[o+1],s);default:return t[o]}}function W(e,t){const n=t.split(".");if(n.length<=2)return R(AFRAME.utils.entity.getComponentProperty(e,t));const i=p(e,n);if(i)return R(i[t]);console.warn(`unknown path for getProperty() '${t}'`)}AFRAME.registerComponent("keyframe",{schema:{duration:{default:1},direction:{default:"forward",oneOf:["forward","backward","alternate"]},loops:{default:-1},seed:{default:-1,type:"int"},easing:{default:"linear",oneOf:Object.keys(B)},randomizeEachLoop:{default:!0}},multiple:!0,init(){this.lcg=f(),this.loopTime=0,this.loops=0,this.keys={},this.rules={}},updateSchema(e){const t=AFRAME.components[this.name].schema;let n={};for(let i in e)i in t||(n[i]={type:"string"});Object.keys(n).length>0&&this.extendSchema(n)},update(e){const t=this.data,n=AFRAME.components[this.name].schema;e.seed!==t.seed&&this.lcg.setSeed(t.seed);for(let e in this.rules)e in t||(delete this.rules[e],delete this.keys[e]);for(let i in t)if(e[i]!==t[i]&&!(i in n)){const e=t[i];this.rules[i]=e.split(",").map(e=>E(e))}e.duration===t.duration&&e.loops===t.loops||(this.loopTime=0,this.loops=0),e.direction!==t.direction&&(this.forward="backward"!==t.direction,this.loopTime=this.forward?0:t.duration),this.generateKeys(!0)},tick(e,t){const n=Math.min(t,100)/1e3;this.step(n)},step(e){const t=this.data;if((t.loops<0||this.loops<t.loops)&&t.duration>0){let n=!1;this.loopTime=this.loopTime+(this.forward?e:-e),(this.loopTime>t.duration||this.loopTime<0)&&(this.loops++,n=!0),n&&(t.loops<0||this.loops<t.loops)&&("alternate"===t.direction?(this.forward=!this.forward,this.loopTime=this.loopTime<0?-this.loopTime:2*t.duration-this.loopTime):this.loopTime=this.loopTime+(this.forward?-t.duration:t.duration),t.randomizeEachLoop&&this.generateKeys(!1));const i=B[t.easing]||B.linear;for(let e in this.keys){let n=THREE.Math.clamp(this.loopTime/t.duration,0,1);const a=q(this.keyTypes[e],this.keys[e],n,i);I(this.el,e,a)}}},generateKeys(e){let t;this.keys={},this.keyTypes={};for(let i in this.rules){this.keys[i]=[];for(let a=0,r=this.rules[i].length;a<r;a++){const o=this.forward?a:r-1-a,s=this.rules[i][o];if(e){const e=s.range&&s.range.includes(""),n=s.options&&s.options.includes("");if(e||n){let r=0==a?x(W(this.el,i)):t;e&&(s.range=s.range.map(e=>""===e?r:e)),n&&(s.options=s.options.map(e=>""===e?r:e))}}t=A(s,this.lcg.random),this.keys[i][o]=t,this.keyTypes[i]=this.keyTypes[i]||("object"==typeof(n=t)?n.length&&"number"==typeof n[0]?"vector":"object":typeof n)}}var n}}),function(){var e=AFRAME.utils.debug("components:materialx:error"),t=AFRAME.shaders;function n(e,t){e.dispose(),t.unregisterMaterial(e)}function i(e,t,n,i){var a=!1;if(i.length=0,0===n.length)return!0;if(""===t){(r=e.getObject3D("mesh"))&&r.material&&(i.push(r.material),r.material=n[0],a=!0)}else{var r=e.object3D,o=t.replace(/[\.\{\}\(\)\^\[\]\$]/g,"\\$&").replace(/[\*\?]/g,".$&"),s=new RegExp("^"+o+"$"),l=0;r&&r.traverse(function(e){if(e&&e.material)if(a=!0,Array.isArray(e.material))for(var t=0,r=e.material.length;t<r;t++)s.test(e.material[t].name)&&(i.push(e.material[t]),e.material[t]=n[l],l=(l+1)%n.length);else s.test(e.material.name)&&(i.push(e.material),e.material=n[l],l=(l+1)%n.length)})}return a}AFRAME.registerComponent("materialx",{schema:{alphaTest:{default:0,min:0,max:1},depthTest:{default:!0},depthWrite:{default:!0},flatShading:{default:!1},name:{default:""},npot:{default:!1},offset:{type:"vec2",default:{x:0,y:0}},opacity:{default:1,min:0,max:1},remap:{default:""},repeat:{type:"vec2",default:{x:1,y:1}},shader:{default:"standard",oneOf:Object.keys(AFRAME.shaders),schemaChange:!0},side:{default:"front",oneOf:["front","back","double"]},transparent:{default:!1},vertexColors:{type:"string",default:"none",oneOf:["face","vertex"]},visible:{default:!0},blending:{default:"normal",oneOf:["none","normal","additive","subtractive","multiply"]}},multiple:!0,init:function(){this.system=this.el.sceneEl.systems.material,this.material=null,this.oldMaterials=[]},update:function(e){var t=this.data;this.shader&&t.shader===e.shader||(i(this.el,e.remap,this.oldMaterials,[]),this.updateShader(t.shader)),this.shader.update(this.data),this.updateMaterial(e)},updateSchema:function(n){var i,a,r,o;a=n&&n.shader,i=this.oldData&&this.oldData.shader,(r=t[o=a||i]&&t[o].schema)||e("Unknown shader schema "+o),i&&a===i||(this.extendSchema(r),this.updateBehavior())},updateBehavior:function(){var e,t,n=this.el.sceneEl,i=this.schema,a=this;function r(e,n){var i;for(i in t)t[i]=e;a.shader.update(t)}for(e in this.tick=void 0,t={},i)"time"===i[e].type&&(this.tick=r,t[e]=!0);n&&(this.tick?n.addBehavior(this):n.removeBehavior(this))},updateShader:function(e){var n,i=this.data,a=t[e]&&t[e].Shader;if(!a)throw new Error("Unknown shader "+e);(n=this.shader=new a).el=this.el,n.init(i),this.setMaterial(n.material),this.updateSchema(i)},updateMaterial:function(e){var t,n=this.data,i=this.material;for(t in i.alphaTest=n.alphaTest,i.depthTest=!1!==n.depthTest,i.depthWrite=!1!==n.depthWrite,i.name=n.name,i.opacity=n.opacity,i.flatShading=n.flatShading,i.side=function(e){switch(e){case"back":return THREE.BackSide;case"double":return THREE.DoubleSide;default:return THREE.FrontSide}}(n.side),i.transparent=!1!==n.transparent||n.opacity<1,i.vertexColors=function(e){switch(e){case"face":return THREE.FaceColors;case"vertex":return THREE.VertexColors;default:return THREE.NoColors}}(n.vertexColors),i.visible=n.visible,i.blending=function(e){switch(e){case"none":return THREE.NoBlending;case"additive":return THREE.AdditiveBlending;case"subtractive":return THREE.SubtractiveBlending;case"multiply":return THREE.MultiplyBlending;default:return THREE.NormalBlending}}(n.blending),e)break;!t||e.alphaTest===n.alphaTest&&e.side===n.side&&e.vertexColors===n.vertexColors||(i.needsUpdate=!0)},remove:function(){var e=this.material;i(this.el,this.data.remap,this.oldMaterials,[]),this.oldMaterials.length=0,n(e,this.system)},setMaterial:function(e){var t=this.el,a=this.system,r=this.data.remap,o=this.oldMaterials;this.material&&n(this.material,a),this.material=e,a.registerMaterial(e),i(t,r,[e],o)||t.addEventListener("object3dset",function n(a){"mesh"===a.detail.type&&a.target===t&&(i(t,r,[e],o),t.removeEventListener("object3dset",n))})}})}(),AFRAME.registerSystem("procedural-texture",{init(){this.renderer=new THREE.WebGLRenderer({alpha:!0}),this.renderer.setPixelRatio(window.devicePixelRatio),this.renderer.autoClear=!0,this.proceduralTextureComponents=[]},registerComponent(e){this.proceduralTextureComponents.push(e)},unregisterComponent(e){const t=this.proceduralTextureComponents.indexOf(e);-1!==t&&this.proceduralTextureComponents.slice(t,1)},updateProceduralTexturesUsingThisCanvas(e,t){for(let n of this.proceduralTextureComponents)t!==n&&Object.keys(n.uniforms).some(t=>{const i=n.uniforms[t];return"texture"===i.type&&(Array.isArray(i.value)?i.value.any(t=>t.image===e):i.value.image===e)})&&n.update(n.data)}}),AFRAME.registerComponent("procedural-texture",{dependencies:["geometry"],schema:{shader:{type:"string"},dest:{type:"selector"}},multiple:!0,init(){this.dest=void 0,this.system.registerComponent(this)},remove(){this.system.unregisterComponent(this)},updateSchema(e){if((!this.data||this.data.shader!==e.shader)&&(this.shaderProgram="",this.uniforms={},e.shader)){let t=document.querySelector(e.shader);t?this.shaderProgram=t.textContent:/main\(/.test(e.shader)?this.shaderProgram=e.shader:console.warn(`unknown shader: ${e.shader}`),this.uniforms=this.parseShaderUniforms(this.shaderProgram)}let t=this.uniformsToSchema(this.uniforms);e.dest||(t.width={type:"int",value:256},t.height={type:"int",value:256}),Object.keys(t).length>0&&this.extendSchema(t)},update(e){const t=this.data;if(t.dest!==e.dest&&(this.dest=t.dest&&t.dest instanceof HTMLCanvasElement?t.dest:void 0),!t.dest&&!this.dest){this.dest=document.createElement("canvas"),this.dest.width=t.width||256,this.dest.height=t.height||256;const e=this.el.getObject3D("mesh");e&&e.material&&(e.material.map=new THREE.CanvasTexture(this.dest))}var n,i;this.dest&&this.shaderProgram&&(this.scene||this.setupScene(this.dest,this.shaderProgram),this.renderScene(t),n=this.el.sceneEl.object3D,i=this.dest,n.traverse(e=>{if(e.material)if(Array.isArray(e.material))for(let t of e.material)N(t,i),V(t,i);else N(e.material,i),V(e.material,i)}),this.system.updateProceduralTexturesUsingThisCanvas(this.dest))},setupScene(e,t){this.scene=new THREE.Scene,this.camera=new THREE.Camera,this.camera.position.z=1,this.uniforms=this.parseShaderUniforms(t);const n=G+t;var i=new THREE.ShaderMaterial({uniforms:this.uniforms,vertexShader:Y,fragmentShader:n});const a=new THREE.Mesh(new THREE.PlaneBufferGeometry(2,2),i);this.scene.add(a),this.ctx=e.getContext("2d")},renderScene(e){this.updateUniforms(this.uniforms,e);const t=this.ctx.canvas,n=t.width,i=t.height;this.system.renderer.setSize(n,i),this.system.renderer.render(this.scene,this.camera),this.ctx.drawImage(this.system.renderer.domElement,0,0)},parseShaderUniforms(e){const t=/uniform (vec2|vec3|vec4|float|int|uint|bool|sampler2D) ([a-zA-Z0-9_]+)(\[(\d+)\])?;/;let n={};return e.split("\n").forEach(e=>{const i=t.exec(e);if(i){const e=i[1],t=i[2],a=void 0!==i[4]?parseInt(i[4],10):0;if(t){const i=n[t]||this.allocateUniform(e,a);n[t]=i}}}),n},uniformsToSchema(e){let t=[];for(let n in e){const i=e[n];switch(i.type){case"texture":t[n]={type:"string"};break;case"float32array":case"int32array":t[n]={type:"string"};break;default:t[n]={type:i.count>1?"string":i.type}}}return t},updateUniforms:function(){let e=new Array(4);const t=e=>Number(e),n=e=>!isNaN(e);function i(i,a,r,o){switch(i){case"texture":const c=o.sceneEl.systems.material,d=document.querySelector(a),u=d||a;c.loadTexture(u,{src:u},e=>{r(e)});break;case"number":r(parseFloat(a));break;case"boolean":r(!!a);break;case"float32array":case"int32array":let h=a.split(" ").map(t).filter(n);if(0==h.length){let t=b(a);t&&(e.fill(1),l=t,(s=e)[0]=l.r,s[1]=l.g,s[2]=l.b,void 0!==l.a&&(s[3]=l.a),h=s)}h.length>0&&r(h)}var s,l}return function(e,t){for(let n in e){const a=t[n],r=e[n];if(void 0===a)console.warn(`no attribute for uniform: ${n}`);else{const e=("string"==typeof a?S(a):[a.toString()]).map(e=>e.trim());if(r.arrayCount>0)for(let t=0;t<e.length;t++){const n=e[t];switch(r.type){case"texture":i(r.type,n,e=>r.value[t]=e,this.el);break;case"number":case"boolean":i(r.type,n,e=>r.value[t]=e,this.el);break;case"float32array":case"in32array":i(r.type,n,e=>r.value.set(e.slice(0,r.size),t*r.size))}}else switch(r.type){case"texture":case"number":case"boolean":i(r.type,e[0],e=>r.value=e,this.el);break;case"float32array":case"in32array":i(r.type,e[0],e=>r.value.set(e.slice(0,r.size)))}}}}}(),allocateUniform(e,t){const n=Math.max(1,t);switch(e){case"sampler2D":return{type:"texture",value:t>0?new Array(t).fill(void 0):void 0,arrayCount:t};case"float":case"int":return{type:"number",value:t>0?new Array(t).fill(0):0,arrayCount:t};case"bool":return{type:"boolean",value:t>0&&new Array(t).fill(!1),arrayCount:t};case"ivec2":case"bvec2":case"vec2":return{type:"float32array",value:new Float32Array(2*n),size:2,arrayCount:t};case"vec3":return{type:"float32array",value:new Float32Array(3*n),size:3,arrayCount:t};case"vec4":return{type:"float32array",value:new Float32Array(4*n),size:4,arrayCount:t};case"ivec3":case"bvec3":return{type:"int32array",value:new Int32Array(3*n),size:3,arrayCount:t};case"ivec4":case"bvec4":return{type:"int32array",value:new Int32Array(4*n),size:4,arrayCount:t};default:console.warn(`unknown uniform type ${e}`)}}});const Y="\nvarying vec2 vUv;\nvoid main()\n{\n  vUv = uv;\n  gl_Position = vec4( position, 1.0 );\n}",G="\nprecision highp float;\n\n// could use levels low, high, mid, black, white (mid maps to (black + white)/2)\nfloat remap(float v, float amin, float amax, float bmin, float bmax)\n{\n  return (v - amin)*(bmax - bmin)/(amax - amin) + bmin;\n}\n\nfloat rand(const vec2 n)\n{\n  return fract(cos(dot(n,vec2(12.9898,4.1414)))*43758.5453);\n}\n\nfloat noise(const vec2 n)\n{\n  const vec2 d=vec2(0.0,1.0);\n  vec2 b=floor(n), f=smoothstep(vec2(0.0), vec2(1.0), fract(n));\n  return mix( mix( rand(b), rand(b+d.yx), f.x ), mix( rand(b+d.xy), rand(b+d.yy), f.x ), f.y );\n}\n\nfloat fbm(vec2 n) {\n  float total=0.0,amplitude=1.0;\n\n  for (int i=0; i<4; i++)\n  {\n    total+=noise(n)*amplitude;\n    n+=n;\n    amplitude*=0.5;\n  }\n\n  return total;\n}\n\nfloat turbulence(const vec2 P)\n{\n  float val=0.0;\n  float freq=1.0;\n\n  for (int i=0; i<4; i++)\n  {\n    val+=abs(noise(P*freq)/freq);\n    freq*=2.07;\n  }\n\n  return val;\n}\n\nfloat roundF(const float number)\n{\n  return sign(number)*floor(abs(number)+0.5);\n}\n\nvec2 uvBrick(const vec2 uv, const float numberOfBricksWidth, const float numberOfBricksHeight)\n{\n  float yi=uv.y*numberOfBricksHeight;\n  float nyi=roundF(yi);\n  float xi=uv.x*numberOfBricksWidth;\n  if (mod(floor(yi),2.0) == 0.0)\n  {\n    xi=xi-0.5;\n  }\n  float nxi=roundF(xi);\n\n  return vec2((xi-floor(xi))*numberOfBricksHeight,(yi-floor(yi))*numberOfBricksWidth);\n}\n\nfloat brick(const vec2 uv, const float numberOfBricksWidth, const float numberOfBricksHeight, const float jointWidthPercentage, const float jointHeightPercentage)\n{\n  float yi=uv.y*numberOfBricksHeight;\n  float nyi=roundF(yi);\n  float xi=uv.x*numberOfBricksWidth;\n  if (mod(floor(yi),2.0) == 0.0) { xi = xi - 0.5; } // offset every second brick\n  float nxi=roundF(xi);\n  xi = abs(xi - nxi);\n  yi = abs(yi - nyi);\n\n  return 1. - clamp( min(yi/jointHeightPercentage, xi/jointWidthPercentage) + 0.2, 0., 1. );\n}\n\nfloat marble(const vec2 uv, float amplitude, float k)\n{\n  k = 6.28*uv.x/k;\n  k += amplitude*turbulence(uv.xy);\n  k = sin(k);\n  k = .5*(k + 1.);\n  k = sqrt( sqrt( sqrt(k) ) ); \n  return .2 + .75*k;\n}\n\nfloat checkerboard(const vec2 uv, const float numCheckers)\n{\n  float cx = floor(numCheckers * uv.x);\n  float cy = floor(numCheckers * uv.y);\n  return sign( mod(cx + cy, 2.) );\n}\n\nfloat gaussian(const vec2 uv)\n{\n  vec2 xy = (mod(uv, vec2(1.,1.)) - .5)*2.;\n  float exponent = dot(xy,xy)/0.31831;\n  return exp(-exponent);\n}\n\nvec2 uvTransform(const vec2 uv, const vec2 center, const vec2 scale, const float rad, const vec2 translate) \n{\n  float c = cos(-rad);\n  float s = sin(-rad);\n  float x = (uv.x - translate.x - center.x);\n  float y = (uv.y - translate.y - center.y);\n  float x2 = (x*c + y*s)/scale.x + center.x;\n  float y2 = (-x*s + y*c)/scale.y + center.y;\n  return vec2(x2, y2);\n}\n\nvec2 uvCrop(const vec2 uv, const vec2 uvMin, const vec2 uvMax) \n{\n  vec2 scale = 1./(uvMax - uvMin);\n  return uvTransform(uv, vec2(0.), scale, 0., -uvMin*scale);\n}\n\nfloat normpdf(const float x, const float sigma)\n{\n  return .39894*exp(-.5*x*x/(sigma*sigma))/sigma;\n}\n\nvec4 blur13(const sampler2D image, const vec2 uv, const vec2 resolution, const float sigma)\n{\n  const int kernelWidth = 13;\n  const int kSize = (kernelWidth)/2 - 1;\n  float kernel[kernelWidth];\n\n  float Z = 0.;\n\n  for (int j = 0; j <= kSize; j++)\n  {\n    kernel[kSize + j] = kernel[kSize - j] = normpdf(float(j), sigma);\n  }\n  for (int j = 0; j < kernelWidth; j++)\n  {\n    Z += kernel[j];\n  }\n\n  vec4 color = vec4(0.);\n  for (int i = -kSize; i <= kSize; i++)\n  {\n    for (int j = -kSize; j <= kSize; j++)\n    {\n      color += kernel[kSize + j]*kernel[kSize + i]*texture2D( image, uv + vec2(float(i), float(j))/resolution );\n    }\n  }\n\n  return color/(Z*Z);\n}\n\n// from glsl-voronoi-noise\nconst mat2 myt = mat2(.12121212, .13131313, -.13131313, .12121212);\nconst vec2 mys = vec2(1e4, 1e6);\n\nvec2 rhash(vec2 uv) {\n  uv *= myt;\n  uv *= mys;\n  return fract(fract(uv / mys) * uv);\n}\n\nvec3 hash(vec3 p) {\n  return fract(sin(vec3(dot(p, vec3(1.0, 57.0, 113.0)),\n    dot(p, vec3(57.0, 113.0, 1.0)),\n    dot(p, vec3(113.0, 1.0, 57.0)))) *\n  43758.5453);\n}\n\nfloat voronoi2d(const in vec2 point) {\n  vec2 p = floor(point);\n  vec2 f = fract(point);\n  float res = 0.0;\n  for (int j = -1; j <= 1; j++) {\n    for (int i = -1; i <= 1; i++) {\n      vec2 b = vec2(i, j);\n      vec2 r = vec2(b) - f + rhash(p + b);\n      res += 1. / pow(dot(r, r), 8.);\n    }\n  }\n  return pow(1. / res, 0.0625);\n}\n";AFRAME.registerComponent("simple-hands",{schema:{objects:{default:""},offset:{type:"vec3"},radius:{default:.05},watch:{default:!0},bubble:{default:!0},debug:{default:!1}},init(){this.observer=null,this.els=[],this.hoverEl=void 0,this.grabEl=void 0,this.sphereDebug=void 0,this.onTriggerUp=this.onTriggerUp.bind(this),this.onTriggerDown=this.onTriggerDown.bind(this)},remove(){this.pause()},play(){const e=this.el.sceneEl;this.data.watch&&(this.observer=new MutationObserver(this.update.bind(this,null)),this.observer.observe(e,{childList:!0,subtree:!0})),this.el.addEventListener("triggerdown",this.onTriggerDown),this.el.addEventListener("triggerup",this.onTriggerUp)},pause(){this.el.removeEventListener("triggerdown",this.onTriggerDown),this.el.removeEventListener("triggerup",this.onTriggerUp),this.observer&&(this.observer.disconnect(),this.observer=null)},update(e){const t=this.data;let n;if(n=t.objects?this.el.sceneEl.querySelectorAll(t.objects):this.el.sceneEl.children,(!AFRAME.utils.deepEqual(t.offset,e.offset)||t.radius!==e.radius)&&t.debug){this.sphereDebug&&this.el.object3D.remove(this.sphereDebug);let e=new THREE.SphereBufferGeometry(t.radius,6,6);e.translate(t.offset.x,t.offset.y,t.offset.z);let n=new THREE.WireframeGeometry(e);this.sphereDebug=new THREE.LineSegments(n,new THREE.LineBasicMaterial({color:16776960})),this.el.object3D.add(this.sphereDebug)}this.els=Array.prototype.slice.call(n)},tick:function(){let e=new THREE.Vector3,t=new THREE.Vector3;return function(){const n=this.data,i=this.el.object3D,a=n.radius;let r=void 0;if(!this.grabEl){let s=Number.MAX_VALUE;t.copy(n.offset).applyMatrix4(i.matrixWorld);for(let n of this.els){if(!n.isEntity||!n.object3D)continue;let i=n.object3D;if(i.boundingSphere&&i.boundingBox&&!i.boundingBox.isEmpty()||this.generateBoundingBox(i),i.boundingBox.isEmpty())continue;e.copy(i.boundingSphere.center).applyMatrix4(i.matrixWorld);const l=i.boundingSphere.radius*Math.max(i.scale.x,i.scale.y,i.scale.z);if(t.distanceTo(e)<l+a){if(z(t,i.boundingBox.min,i.boundingBox.max,i.matrixWorld.elements)<a){const e=((o=i.boundingBox).max.x-o.min.x)*(o.max.y-o.min.y)*(o.max.z-o.min.z);e<s&&(s=e,r=n)}}}}var o;this.hoverEl&&this.hoverEl!==r&&this.sendEvent(this.hoverEl,"hoverend"),r&&r!==this.hoverEl&&this.sendEvent(r,"hoverstart"),this.hoverEl=r}}(),generateBoundingBox(e){if(e.boundingBox=e.boundingBox||new THREE.Box3,e.boundingSphere=e.boundingSphere||new THREE.Sphere,H(e.boundingBox,e),!e.boundingBox.isEmpty()&&(e.boundingBox.getBoundingSphere(e.boundingSphere),this.data.debug)){let t=new THREE.Box3;t.copy(e.boundingBox),e.boundingBoxDebug=new THREE.Box3Helper(t),e.boundingBoxDebug.name="simpleHandsDebug",e.add(e.boundingBoxDebug)}},sendEvent(e,t){const n=this.data.bubble;e.emit(t,{hand:this.el},n),this.el.emit(t,{target:e},n)},onTriggerDown(e){this.hoverEl&&(this.grabEl=this.hoverEl,this.sendEvent(this.grabEl,"grabstart"))},onTriggerUp(e){this.grabEl&&(this.sendEvent(this.grabEl,"grabend"),this.grabEl=void 0)}});const Z=THREE.Math.degToRad,X={acceleration:"USE_PARTICLE_ACCELERATION",angularAcceleration:"USE_PARTICLE_ANGULAR_ACCELERATION",angularVelocity:"USE_PARTICLE_ANGULAR_VELOCITY",color:"USE_PARTICLE_COLOR",textureFrame:"USE_PARTICLE_FRAMES",textureCount:"USE_PARTICLE_FRAMES",textureLoop:"USE_PARTICLE_FRAMES",position:"USE_PARTICLE_OFFSET",opacity:"USE_PARTICLE_OPACITY",radialAcceleration:"USE_PARTICLE_RADIAL_ACCELERATION",radialPosition:"USE_PARTICLE_RADIAL_OFFSET",radialVelocity:"USE_PARTICLE_RADIAL_VELOCITY",scale:"USE_PARTICLE_SCALE",velocity:"USE_PARTICLE_VELOCITY",orbitalVelocity:"USE_PARTICLE_ORBITAL",orbitalAcceleration:"USE_PARTICLE_ORBITAL",drag:"USE_PARTICLE_DRAG",destinationWeight:"USE_PARTICLE_DESTINATION",screenDepthOffset:"USE_PARTICLE_SCREEN_DEPTH_OFFSET",source:"USE_PARTICLE_SOURCE",model:"USE_PARTICLE_SOURCE"},$=["overtime","interval"],Q=["newest","oldest","original"],K=["x","y","z"],J=e=>e.reduce((e,t)=>Array.isArray(t)?e.concat(J(t)):e.concat(t),[]),ee=(e,t)=>{let n=e.split("..").map(e=>e.trim().split(" ").map(e=>{const t=Number(e);return isNaN(t)?void 0:t}));return 1===n.length&&(n[1]=n[0]),n.length=2,J(n.map(e=>t.map((t,n)=>void 0===e[n]?t:e[n])))},te=(e,t)=>J(e.split(",").map(e=>ee(e,t))),ne=e=>e.toLowerCase();let ie=new THREE.DataTexture(new Uint8Array(3).fill(255),1,1,THREE.RGBFormat);ie.needsUpdate=!0;const ae={none:THREE.NoBlending,normal:THREE.NormalBlending,additive:THREE.AdditiveBlending,subtractive:THREE.SubtractiveBlending,multiply:THREE.MultiplyBlending},re={double:THREE.DoubleSide,front:THREE.FrontSide,back:THREE.BackSide};AFRAME.registerComponent("sprite-particles",{schema:{texture:{type:"map"},delay:{default:0},duration:{default:-1},spawnType:{default:"continuous",oneOf:["continuous","burst"],parse:ne},spawnRate:{default:10},source:{type:"selector"},textureFrame:{type:"vec2",default:{x:1,y:1}},textureCount:{type:"int",default:0},textureLoop:{default:1},randomizeFrames:{default:!1},trailInterval:{default:0},trailLifeTime:{default:"0"},trailType:{default:"particle",oneOf:["particle","ribbon","ribbon3d"]},ribbonWidth:{default:1},ribbonShape:{default:"flat",oneOf:["flat","taperin","taperout","taper"],parse:ne},ribbonUVType:{default:"overtime",oneOf:$,parse:ne},emitterColor:{type:"color"},lifeTime:{default:"1"},position:{default:"0 0 0"},velocity:{default:"0 0 0"},acceleration:{default:"0 0 0"},radialType:{default:"circle",oneOf:["circle","sphere","circlexy","circlexz"],parse:ne},radialPosition:{default:"0"},radialVelocity:{default:"0"},radialAcceleration:{default:"0"},angularVelocity:{default:"0 0 0"},angularAcceleration:{default:"0 0 0"},orbitalVelocity:{default:"0"},orbitalAcceleration:{default:"0"},scale:{default:"1"},color:{default:"white",parse:ne},rotation:{default:"0"},opacity:{default:"1"},velocityScale:{default:0},velocityScaleMinMax:{type:"vec2",default:{x:0,y:3}},drag:{default:0},destination:{type:"selector"},destinationOffset:{default:"0 0 0"},destinationWeight:{default:"0"},enable:{default:!0},emitterTime:{default:0},model:{type:"selector"},modelFill:{default:"triangle",oneOf:["triangle","edge","vertex"],parse:ne},direction:{default:"forward",oneOf:["forward","backward"],parse:ne},particleOrder:{default:"original",oneOf:Q},ribbonUVMultiplier:{default:1},materialSide:{default:"front",oneOf:["double","front","back"],parse:ne},screenDepthOffset:{default:0},alphaTest:{default:0},fog:{default:!0},depthWrite:{default:!1},depthTest:{default:!0},blending:{default:"normal",oneOf:["none","normal","additive","subtractive","multiply"],parse:ne},transparent:{default:!0},particleSize:{default:100},usePerspective:{default:!0},seed:{type:"number",default:-1},overTimeSlots:{type:"int",default:5},frustumCulled:{default:!0},editorObject:{default:!0}},multiple:!0,help:"https://github.com/harlyq/aframe-sprite-particles-component",init(){this.handleObject3DSet=this.handleObject3DSet.bind(this),this.count=0,this.trailCount=0,this.overTimeArrayLength=0,this.emitterTime=0,this.delayTime=0,this.lifeTime=[1,1],this.trailLifeTime=[0,0],this.textureFrames=new Float32Array(4),this.offset=new Float32Array(8).fill(0),this.velocity=new Float32Array(8).fill(0),this.acceleration=new Float32Array(8).fill(0),this.angularVelocity=new Float32Array(8).fill(0),this.angularAcceleration=new Float32Array(8).fill(0),this.orbital=new Float32Array(4).fill(0),this.colorOverTime,this.rotationScaleOverTime,this.params=new Float32Array(20).fill(0),this.velocityScale=new Float32Array(3).fill(0),this.emitterColor=new THREE.Vector3,this.destination=new Float32Array(8).fill(0),this.destinationOffset,this.destinationWeight,this.nextID=0,this.nextTime=0,this.numDisabled=0,this.numEnabled=0,this.startDisabled=!this.data.enable,this.manageIDs=!1,this.params[1]=-1},remove(){this.mesh&&this.el.removeObject3D(this.mesh.name),this.data.model&&this.data.model.removeEventListener("object3dset",this.handleObject3DSet)},update(e){const t=this.data;let n=t.particleSize!==e.particleSize,i=!1;if(t.overTimeSlots===e.overTimeSlots||this.isPlaying||(this.overTimeArrayLength=2*this.data.overTimeSlots+1,this.colorOverTime=new Float32Array(4*this.overTimeArrayLength).fill(0),this.rotationScaleOverTime=new Float32Array(2*this.overTimeArrayLength).fill(0),i=!0),this.params[8]=t.particleSize,this.params[9]=t.usePerspective?1:0,this.params[10]="forward"===t.direction?0:1,this.params[11]=THREE.Math.clamp(t.drag,0,1),this.params[15]=1e-5*t.screenDepthOffset,this.params[16]=t.ribbonWidth,this.params[17]=t.ribbonUVMultiplier,this.textureFrames[0]=t.textureFrame.x,this.textureFrames[1]=t.textureFrame.y,this.textureFrames[2]=t.textureCount>0?t.textureCount:t.textureFrame.x*t.textureFrame.y,this.textureFrames[3]=t.textureLoop,this.velocityScale[0]=t.velocityScale,this.velocityScale[1]=t.velocityScaleMinMax.x,this.velocityScale[2]=t.velocityScaleMinMax.y,this.material&&(this.material.alphaTest=t.alphaTest,this.material.depthTest=t.depthTest,this.material.depthWrite=t.depthWrite,this.material.blending=ae[t.blending],this.material.fog=t.fog),t.seed!==e.seed&&(this.seed=t.seed,this.params[6]=t.seed>=0?t.seed:Math.random()),t.ribbonUVType!==e.ribbonUVType&&(this.params[18]=-1===$.indexOf(t.ribbonUVType)?0:$.indexOf(t.ribbonUVType)),t.radialType!==e.radialType&&(this.params[2]=["sphere","circlexy","circle"].includes(t.radialType)?1:0,this.params[19]=["sphere","circlexz"].includes(t.radialType)?1:0),this.mesh&&t.frustumCulled!==e.frustumCulled&&(this.mesh.frustumCulled=t.frustumCulled),t.emitterColor!==e.emitterColor){const e=new THREE.Color(t.emitterColor);this.emitterColor.set(e.r,e.g,e.b)}if(t.position===e.position&&t.radialPosition===e.radialPosition||(this.updateVec4XYZRange(t.position,"offset"),this.updateVec4WRange(t.radialPosition,[0],"offset"),n=!0),t.velocity===e.velocity&&t.radialVelocity===e.radialVelocity||(this.updateVec4XYZRange(t.velocity,"velocity"),this.updateVec4WRange(t.radialVelocity,[0],"velocity"),n=!0),t.acceleration===e.acceleration&&t.radialAcceleration===e.radialAcceleration||(this.updateVec4XYZRange(t.acceleration,"acceleration"),this.updateVec4WRange(t.radialAcceleration,[0],"acceleration"),n=!0),(t.rotation!==e.rotation||t.scale!==e.scale||i)&&(this.updateRotationScaleOverTime(),n=!0),(t.color!==e.color||t.opacity!==e.opacity||i)&&this.updateColorOverTime(),t.lifeTime!==e.lifeTime&&(this.lifeTime=this.updateVec4WRange(t.lifeTime,[1],"angularVelocity")),t.angularVelocity!==e.angularVelocity&&this.updateAngularVec4XYZRange(t.angularVelocity,"angularVelocity"),t.trailLifeTime!==e.trailLifeTime&&(this.trailLifeTime=ee(t.trailLifeTime,[0]).map((e,t)=>e>0?e:this.lifeTime[t]),this.angularAcceleration[3]=this.trailLifeTime[0],this.angularAcceleration[7]=this.trailLifeTime[1]),t.angularAcceleration!==e.angularAcceleration&&this.updateAngularVec4XYZRange(t.angularAcceleration,"angularAcceleration"),t.orbitalVelocity!==e.orbitalVelocity&&this.updateAngularVec2PartRange(t.orbitalVelocity,[0],"orbital",0),t.orbitalAcceleration!==e.orbitalAcceleration&&this.updateAngularVec2PartRange(t.orbitalAcceleration,[0],"orbital",1),t.destinationOffset!==e.destinationOffset&&(this.destinationOffset=this.updateVec4XYZRange(t.destinationOffset,"destination")),t.destinationWeight!==e.destinationWeight&&(this.destinationWeight=this.updateVec4WRange(t.destinationWeight,[0],"destination")),t.duration===e.duration&&t.delay===e.delay&&t.emitterTime===e.emitterTime||(this.params[3]=t.duration,this.emitterTime=t.emitterTime,this.delayTime=t.delay),t.spawnType!==e.spawnType||t.spawnRate!==e.spawnRate||t.lifeTime!==e.lifeTime||t.trailInterval!==e.trailInterval){const e=this.lifeTime[1],n=t.trailInterval>0?this.trailLifeTime[1]:0,i=e+n,a=Math.max(1,Math.ceil(i*t.spawnRate));this.trailCount=1+(t.trailInterval>0?Math.ceil(Math.min(n,e)/t.trailInterval):0),this.isRibbon()?(this.trailCount++,this.count=a*this.trailCount*2):this.count=a*this.trailCount,this.params[4]="burst"===t.spawnType?0:1,this.params[5]=t.spawnRate,this.params[7]=this.count,this.params[13]=a,this.params[12]=t.trailInterval,this.params[14]=this.trailCount,this.updateAttributes()}t.enable&&this.startDisabled&&(this.startDisabled=!1),t.model!==e.model&&t.model&&"getObject3D"in t.model&&(e.model&&e.model.removeEventListener("object3dset",this.handleObject3DSet),this.updateModelMesh(t.model.getObject3D("mesh")),t.model&&t.model.addEventListener("object3dset",this.handleObject3DSet)),"original"!==t.particleOrder&&t.source&&console.warn(`changing particleOrder to 'original' (was '${t.particleOrder}'), because particles use a source`),this.mesh?this.updateDefines():this.createMesh(),t.materialSide!==e.materialSide&&(this.material.side=re[t.materialSide]),n&&this.updateBounds(),this.paused&&t.editorObject!==e.editorObject&&this.enableEditorObject(t.editorObject),this.manageIDs=this.manageIDs||!t.enable||t.source||void 0!==this.el.getDOMAttribute(this.attrName).enable||t.model||t.delay>0,t.texture!==e.texture&&this.loadTexture(t.texture)},tick(e,t){const n=this.data;if(this.startDisabled)return;t>100&&(t=100);const i=t/1e3;n.enable&&(this.delayTime-=i),this.delayTime>=0||n.model&&!this.modelVertices||(this.emitterTime+=i,this.params[0]=this.emitterTime,this.geometry&&this.manageIDs?this.updateWorldTransform(this.emitterTime):this.params[1]=-1,n.destination&&n.destination.object3D&&(this.destinationWeight[0]>0||this.destinationWeight[1]>0)&&this.updateDestinationEntity())},pause(){this.paused=!0,this.enableEditorObject(this.data.editorObject)},play(){this.paused=!1,this.enableEditorObject(!1)},handleObject3DSet(e){e.target===this.data.model&&"mesh"===e.detail.type&&this.updateModelMesh(this.data.model.getObject3D("mesh"))},loadTexture(e){if(e){this.el.sceneEl.systems.material.loadTexture(e,{src:e},e=>{this.isRibbon()&&(e.wrapS=THREE.RepeatWrapping),this.material.uniforms.map.value=e})}else this.material.uniforms.map.value=ie},isRibbon(){return this.data.trailInterval>0&&"particle"!==this.data.trailType},createMesh(){const e=this.data;this.geometry=new THREE.BufferGeometry,this.updateAttributes(),this.material=new THREE.ShaderMaterial({uniforms:{map:{type:"t",value:ie},textureFrames:{value:this.textureFrames},params:{value:this.params},offset:{value:this.offset},velocity:{value:this.velocity},acceleration:{value:this.acceleration},angularVelocity:{value:this.angularVelocity},angularAcceleration:{value:this.angularAcceleration},orbital:{value:this.orbital},colorOverTime:{value:this.colorOverTime},rotationScaleOverTime:{value:this.rotationScaleOverTime},velocityScale:{value:this.velocityScale},emitterColor:{value:this.emitterColor},destination:{value:this.destination},fogDensity:{value:25e-5},fogNear:{value:1},fogFar:{value:2e3},fogColor:{value:new THREE.Color(16777215)}},fragmentShader:ue,vertexShader:de,transparent:e.transparent,alphaTest:e.alphaTest,blending:ae[e.blending],fog:e.fog,depthWrite:e.depthWrite,depthTest:e.depthTest,defines:{}}),this.updateDefines(),this.isRibbon()?(this.mesh=new THREE.Mesh(this.geometry,[this.material]),this.mesh.drawMode=THREE.TriangleStripDrawMode):this.mesh=new THREE.Points(this.geometry,this.material),this.mesh.frustumCulled=e.frustumCulled,this.mesh.name=this.attrName,this.material.name=this.mesh.name,this.el.setObject3D(this.mesh.name,this.mesh)},updateColorOverTime(){let e=(e=>J(e.split(",").map(e=>{let t=e.split("..");return 1===t.length&&(t[1]=t[0]),t.length=2,t.map(e=>new THREE.Color(e.trim()))})))(this.data.color),t=te(this.data.opacity,[1]);const n=this.data.overTimeSlots;e.length>2*n&&(e.length=2*n),t.length>2*n&&(t.length=2*n),this.colorOverTime.fill(0),this.colorOverTime[0]=e.length/2,this.colorOverTime[1]=t.length/2;let i=e.length;for(let t=0,n=4;t<i;t++,n+=4){let i=e[t];this.colorOverTime[n]=i.r,this.colorOverTime[n+1]=i.g,this.colorOverTime[n+2]=i.b}i=t.length;for(let e=0,n=4;e<i;e++,n+=4){let i=t[e];this.colorOverTime[n+3]=i}},updateRotationScaleOverTime(){const e=this.data.overTimeSlots;let t=te(this.data.rotation,[0]),n=te(this.data.scale,[1]);t.length>2*e&&(t.length=2*e),n.length>2*e&&(n.length=2*e),this.rotationScaleOverTime.fill(0),this.rotationScaleOverTime[0]=t.length/2,this.rotationScaleOverTime[1]=n.length/2;let i=t.length;for(let e=0,n=2;e<i;e++,n+=2)this.rotationScaleOverTime[n]=Z(t[e]);i=n.length;for(let e=0,t=2;e<i;e++,t+=2)this.rotationScaleOverTime[t+1]=n[e]},updateVec4XYZRange(e,t){const n=ee(e,[0,0,0]);for(let e=0,i=0;e<n.length;)this[t][i++]=n[e++],this[t][i++]=n[e++],this[t][i++]=n[e++],i++;return n},updateAngularVec4XYZRange(e,t){const n=ee(e,[0,0,0]);for(let e=0,i=0;e<n.length;)this[t][i++]=Z(n[e++]),this[t][i++]=Z(n[e++]),this[t][i++]=Z(n[e++]),i++},updateAngularVec2PartRange(e,t,n,i){const a=ee(e,t);this[n][i]=Z(a[0]),this[n][i+2]=Z(a[1])},updateVec4WRange(e,t,n){let i=ee(e,t);return this[n][3]=i[0],this[n][7]=i[1],i},updateBounds(){const e=this.data;let t=Math.max(this.lifeTime[0],this.lifeTime[1]);let n=[new Array(4),new Array(4)];e.drag>0&&(t*=1-.5*e.drag);for(let e=0;e<2;e++){const i=0===e?Math.min:Math.max;for(let a=0;a<4;a++){const r=i(this.offset[a],this.offset[a+4]),o=i(this.velocity[a],this.velocity[a+4]),s=i(this.acceleration[a],this.acceleration[a+4]);n[e][a]=r+(o+.5*s*t)*t,n[e][a]=i(n[e][a],r);const l=-o/s;l>0&&l<t&&(n[e][a]=i(n[e][a],r-.5*o*o/s))}}this.modelBounds&&(n[0][0]+=this.modelBounds.min.x,n[0][1]+=this.modelBounds.min.y,n[0][2]+=this.modelBounds.min.z,n[1][0]+=this.modelBounds.max.x,n[1][1]+=this.modelBounds.max.y,n[1][2]+=this.modelBounds.max.z);const i=this.el.getDOMAttribute(this.attrName),a=this.rotationScaleOverTime.reduce((e,t,n)=>1&n?Math.max(e,t):e,0),r=Math.max(Math.abs(n[0][3]),Math.abs(n[1][3]))+45e-5*e.particleSize*a,o="sphere"===e.radialType||i.angularVelocity||i.angularAcceleration||i.orbitalVelocity||i.orbitalAcceleration;n[0][0]-=r,n[0][1]-=r,n[0][2]-=o?r:0,n[1][0]+=r,n[1][1]+=r,n[1][2]+=o?r:0,n[0].length=3,n[0].length=3;const s=Math.max(...n[0].map(Math.abs),...n[1].map(Math.abs));this.geometry.boundingSphere||(this.geometry.boundingSphere=new THREE.Sphere),this.geometry.boundingSphere.radius=s,this.geometry.boundingBox||(this.geometry.boundingBox=new THREE.Box3),this.geometry.boundingBox.min.set(...n[0]),this.geometry.boundingBox.max.set(...n[1]);const l=this.el.getObject3D("mesh");l&&l.isParticlesEditorObject&&this.enableEditorObject(!0)},updateDestinationEntity:function(){let e=new THREE.Vector3,t=new THREE.Vector3;return function(){this.data.destination.object3D.getWorldPosition(e),this.el.object3D.getWorldPosition(t),e.sub(t);for(let t=0,n=K.length;t<n;t++)this.destination[t]=e[K[t]]+this.destinationOffset[t],this.destination[t+4]=e[K[t]]+this.destinationOffset[t+3]}}(),enableEditorObject(e){const t=this.el.getObject3D("mesh");if(!e||t&&!t.isParticlesEditorObject)!e&&t&&t.isParticlesEditorObject&&this.el.removeObject3D("mesh");else{const e=.25,t=new THREE.Vector3(e,e,e).max(this.geometry.boundingBox.max),n=new THREE.Vector3(-e,-e,-e).min(this.geometry.boundingBox.min);let i=new THREE.Box3(n,t),a=new THREE.Box3Helper(i,8421376);a.isParticlesEditorObject=!0,a.visible=!1,this.el.setObject3D("mesh",a)}},updateAttributes(){if(this.geometry){const e=this.count;let t=new Float32Array(e);if(this.startDisabled||this.data.delay>0||this.data.model)t.fill(-1),this.numEnabled=0,this.numDisabled=e;else{for(let n=0;n<e;n++)t[n]=n;this.numEnabled=e,this.numDisabled=0}if(this.geometry.addAttribute("vertexID",new THREE.Float32BufferAttribute(t,1)),this.geometry.addAttribute("position",new THREE.Float32BufferAttribute(new Float32Array(3*e).fill(0),3)),this.data.source&&this.geometry.addAttribute("quaternion",new THREE.Float32BufferAttribute(new Float32Array(4*e).fill(0),4)),this.isRibbon()){this.geometry.clearGroups();const t=2*this.trailCount;for(let n=0;n<e;n+=t)this.geometry.addGroup(n,t,0)}}},updateDefines(){const e=this.data,t=Object.keys(this.el.getDOMAttribute(this.attrName)),n=t.map(e=>X[e]).filter(e=>e);let i={PARAMS_LENGTH:5,OVER_TIME_ARRAY_LENGTH:this.overTimeArrayLength,RANDOM_REPEAT_COUNT:131072,USE_MAP:!0};for(let e of n)i[e]=!0;e.velocityScale>0&&(i.USE_PARTICLE_VELOCITY_SCALE=!0),e.trailInterval>0&&(this.isRibbon()?"ribbon"===e.trailType?i.USE_RIBBON_TRAILS=!0:i.USE_RIBBON_3D_TRAILS=!0:i.USE_PARTICLE_TRAILS=!0),e.randomizeFrames&&(i.USE_PARTICLE_RANDOMIZE_FRAMES=!0),t.includes("rotation")&&(this.isRibbon()?i.USE_RIBBON_ROTATION=!0:i.USE_PARTICLE_ROTATION=!0);let a="1.";if("taperout"===e.ribbonShape?a="1. - p":"taperin"===e.ribbonShape?a="p":"taper"===e.ribbonShape?a="2. * ( p < .5 ? p : 1. - p )":"="===e.ribbonShape[0]&&(a=e.ribbonShape.slice(1)),i.RIBBON_SHAPE_FUNCTION=a,e.source?i.PARTICLE_ORDER=2:i.PARTICLE_ORDER=Q.indexOf(e.particleOrder),i.PARTICLE_TRAIL_ORDER=Q.indexOf(e.particleOrder),Object.keys(i).filter(e=>this.material.defines[e]!==i[e]).length>0)if(this.isPlaying){const e=t.filter(e=>{const t=X[e];return t&&!this.material.defines[t]});console.error(`cannot add attributes (${e.join(",")}) at run-time`)}else this.material.defines=i,this.material.needsUpdate=!0},updateModelMesh(e){if(!e)return;this.modelBounds=new THREE.Box3,this.modelVertices;let t=0,n=0,i=0;const a=e=>{if(!e.geometry)return;let a=e.geometry.getAttribute("position");a&&3!==a.itemSize||(0==i?n+=a.array.length:(this.modelVertices.set(a.array,t),t+=a.array.length))};i=0,e.traverse(a),n>0&&(i=1,this.modelVertices=new Float32Array(n),e.traverse(a),oe(this.modelVertices,e.el.object3D.scale),this.modelBounds.setFromArray(this.modelVertices),this.updateBounds())},updateWorldTransform:function(){let e=new THREE.Vector3,t=new THREE.Quaternion,n=new THREE.Vector3,i=new THREE.Vector3,a=new THREE.Matrix4;return function(r){const o=this.data,s=this.count,l=this.data.spawnRate,c="burst"===o.spawnType,d=c?0:1/l,u=o.enable?this.numEnabled<s:this.numDisabled<s,h=o.source&&null!=o.source.object3D,f=this.modelVertices&&this.modelVertices.length,m=this.isRibbon(),p=f||h;let v=this.geometry.getAttribute("vertexID"),g=this.geometry.getAttribute("position"),y=this.geometry.getAttribute("quaternion");h&&(this.el.object3D.updateMatrixWorld(),o.source.object3D.updateMatrixWorld(),a.getInverse(this.el.object3D.matrixWorld),a.multiply(o.source.object3D.matrixWorld),a.decompose(e,t,n),this.geometry.boundingSphere.center.copy(e));let T=this.nextID%s,b=0,E=T,x=this.nextID,A=se;switch(o.modelFill){case"edge":A=le;break;case"vertex":A=ce}for(;this.nextTime<r&&b<this.count;){f&&A(this.modelVertices,i);for(let n=0,a=m?2:1;n<a;n++)for(let n=0;n<this.trailCount;n++)x=this.nextID,f&&g.setXYZ(E,i.x,i.y,i.z),h&&(g.setXYZ(E,e.x,e.y,e.z),y.setXYZW(E,t.x,t.y,t.z,t.w)),v.setX(E,o.enable?x:-1),u&&(this.numEnabled=o.enable?this.numEnabled+1:0,this.numDisabled=o.enable?0:this.numDisabled+1),E=(E+1)%s,b++,p?this.nextID++:this.nextID=E;this.nextTime+=d}if(b>0){const e=this.trailCount*(m?2:1);this.params[1]=Math.floor(x/e),c&&(this.nextTime+=this.lifeTime[1],o.trailInterval>0&&(this.nextTime+=this.trailLifeTime[1])),E<T&&(T=0,b=this.count),(h||f)&&(g.updateRange.offset=T,g.updateRange.count=b,g.needsUpdate=!0),h&&(y.updateRange.offset=T,y.updateRange.count=b,y.needsUpdate=!0),v.updateRange.offset=T,v.updateRange.count=b,v.needsUpdate=!0,this.nextID=this.nextID%131072}}}()});const oe=(e,t)=>{if(1!==t.x&&1!==t.y&&1!==t.z)for(let n=0,i=e.length;n<i;n+=3)e[n]*=t.x,e[n+1]*=t.y,e[n+2]*=t.z},se=function(){let e=new THREE.Vector3,t=new THREE.Vector3;return function(n,i){let a,r,o=9*Math.floor(Math.random()*n.length/9);e.fromArray(n,o),t.fromArray(n,o+3),i.fromArray(n,o+6);do{a=Math.random(),r=Math.random()}while(a+r>1);t.sub(e).multiplyScalar(a),i.sub(e).multiplyScalar(r).add(t).add(e)}}(),le=function(){let e=new THREE.Vector3,t=new THREE.Vector3,n=new THREE.Vector3;return function(i,a){let r=9*Math.floor(Math.random()*i.length/9);e.fromArray(i,r),t.fromArray(i,r+3),n.fromArray(i,r+6);let o=Math.random();o>2/3?a.copy(e).sub(n).multiplyScalar(3*o-2).add(n):o>1/3?a.copy(n).sub(t).multiplyScalar(3*o-1).add(t):a.copy(t).sub(e).multiplyScalar(3*o).add(e)}}();function ce(e,t){let n=3*Math.floor(Math.random()*e.length/3);t.fromArray(e,n)}const de="\n#include <common>\n// #include <color_pars_vertex>\n#include <fog_pars_vertex>\n// #include <morphtarget_pars_vertex>\n// #include <logdepthbuf_pars_vertex>\n// #include <clipping_planes_pars_vertex>\n\nattribute float vertexID;\n\n#if defined(USE_PARTICLE_SOURCE)\nattribute vec4 quaternion;\n#endif\n\nuniform vec4 params[PARAMS_LENGTH];\nuniform vec4 offset[2];\nuniform vec4 velocity[2];\nuniform vec4 acceleration[2];\nuniform vec4 angularVelocity[2];\nuniform vec4 angularAcceleration[2];\nuniform vec2 orbital[2];\nuniform vec4 colorOverTime[OVER_TIME_ARRAY_LENGTH];\nuniform vec2 rotationScaleOverTime[OVER_TIME_ARRAY_LENGTH];\nuniform vec4 textureFrames;\nuniform vec3 velocityScale;\nuniform vec4 destination[2];\n\nvarying vec4 vParticleColor;\nvarying vec2 vCosSinRotation;\nvarying vec2 vUv;\nvarying float vOverTimeRatio;\nvarying float vFrame;\n\nfloat VERTS_PER_RIBBON = 2.;\n\n// alternative random algorithm, used for the initial seed.  Provides a better\n// result than using rand()\nfloat pseudoRandom( const float seed )\n{\n  return mod( 1664525.*seed + 1013904223., 4294967296. )/4294967296.; // we don't have enough precision in 32-bit float, but results look ok\n}\n\n// each call to random will produce a different result by varying randI\nfloat randI = 0.;\nfloat random( const float seed )\n{\n  randI += 0.001;\n  return rand( vec2( seed, randI ));\n}\n\nvec3 randVec3Range( const vec3 range0, const vec3 range1, const float seed )\n{\n  vec3 lerps = vec3( random( seed ), random( seed ), random( seed ) );\n  return mix( range0, range1, lerps );\n}\n\nvec2 randVec2Range( const vec2 range0, const vec2 range1, const float seed )\n{\n  vec2 lerps = vec2( random( seed ), random( seed ) );\n  return mix( range0, range1, lerps );\n}\n\nfloat randFloatRange( const float range0, const float range1, const float seed )\n{\n  float lerps = random( seed );\n  return mix( range0, range1, lerps );\n}\n\n// theta.x is the angle in XY, theta.y is the angle in XZ\nvec3 radialToVec3( const float r, const vec2 theta )\n{\n  vec2 cosTheta = cos(theta);\n  vec2 sinTheta = sin(theta);\n  float rc = r * cosTheta.x;\n  float x = rc * cosTheta.y;\n  float y = r * sinTheta.x;\n  float z = rc * sinTheta.y;\n  return vec3( x, y, z );\n}\n\n// array lengths are stored in the first slot, followed by actual values from slot 1 onwards\n// colors are packed min,max,min,max,min,max,...\n// color is packed in xyz and opacity in w, and they may have different length arrays\n\nvec4 calcColorOverTime( const float r, const float seed )\n{\n  vec3 color = vec3(1.);\n  float opacity = 1.;\n\n#if defined(USE_PARTICLE_COLOR)\n  int colorN = int( colorOverTime[0].x );\n  if ( colorN == 1 )\n  {\n    color = randVec3Range( colorOverTime[1].xyz, colorOverTime[2].xyz, seed );\n  }\n  else if ( colorN > 1 )\n  {\n    float ck = r * ( float( colorN ) - 1. );\n    float ci = floor( ck );\n    int i = int( ci )*2 + 1;\n    vec3 sColor = randVec3Range( colorOverTime[i].xyz, colorOverTime[i + 1].xyz, seed );\n    vec3 eColor = randVec3Range( colorOverTime[i + 2].xyz, colorOverTime[i + 3].xyz, seed );\n    color = mix( sColor, eColor, ck - ci );\n  }\n#endif\n\n#if defined(USE_PARTICLE_OPACITY)\n  int opacityN = int( colorOverTime[0].y );\n  if ( opacityN == 1 )\n  {\n    opacity = randFloatRange( colorOverTime[1].w, colorOverTime[2].w, seed );\n  }\n  else if ( opacityN > 1 )\n  {\n    float ok = r * ( float( opacityN ) - 1. );\n    float oi = floor( ok );\n    int j = int( oi )*2 + 1;\n    float sOpacity = randFloatRange( colorOverTime[j].w, colorOverTime[j + 1].w, seed );\n    float eOpacity = randFloatRange( colorOverTime[j + 2].w, colorOverTime[j + 3].w, seed );\n    opacity = mix( sOpacity, eOpacity, ok - oi );\n  }\n#endif\n\n  return vec4( color, opacity );\n}\n\n// as per calcColorOverTime but euler rotation is packed in xyz and scale in w\n\nvec2 calcRotationScaleOverTime( const float r, const float seed )\n{\n  float rotation = 0.;\n  float scale = 1.;\n\n#if defined(USE_PARTICLE_ROTATION) || defined(USE_RIBBON_ROTATION)\n  int rotationN = int( rotationScaleOverTime[0].x );\n  if ( rotationN == 1 )\n  {\n    rotation = randFloatRange( rotationScaleOverTime[1].x, rotationScaleOverTime[2].x, seed );\n  }\n  else if ( rotationN > 1 )\n  {\n    float rk = r * ( float( rotationN ) - 1. );\n    float ri = floor( rk );\n    int i = int( ri )*2 + 1; // *2 because each range is 2 vectors, and +1 because the first vector is for the length info\n    float sRotation = randFloatRange( rotationScaleOverTime[i].x, rotationScaleOverTime[i + 1].x, seed );\n    float eRotation = randFloatRange( rotationScaleOverTime[i + 2].x, rotationScaleOverTime[i + 3].x, seed );\n    rotation = mix( sRotation, eRotation, rk - ri );\n  }\n#endif\n\n#if defined(USE_PARTICLE_SCALE)\n  int scaleN = int( rotationScaleOverTime[0].y );\n  if ( scaleN == 1 )\n  {\n    scale = randFloatRange( rotationScaleOverTime[1].y, rotationScaleOverTime[2].y, seed );\n  }\n  else if ( scaleN > 1 )\n  {\n    float sk = r * ( float( scaleN ) - 1. );\n    float si = floor( sk );\n    int j = int( si )*2 + 1; // *2 because each range is 2 vectors, and +1 because the first vector is for the length info\n    float sScale = randFloatRange( rotationScaleOverTime[j].y, rotationScaleOverTime[j + 1].y, seed );\n    float eScale = randFloatRange( rotationScaleOverTime[j + 2].y, rotationScaleOverTime[j + 3].y, seed );\n    scale = mix( sScale, eScale, sk - si );\n  }\n#endif\n\n  return vec2( rotation, scale );\n}\n\n// assumes euler order is YXZ (standard convention for AFrame)\nvec4 eulerToQuaternion( const vec3 euler )\n{\n  // from https://github.com/mrdoob/three.js/blob/master/src/math/Quaternion.js\n\n  vec3 c = cos( euler * .5 );\n  vec3 s = sin( euler * .5 );\n\n  return vec4(\n    s.x * c.y * c.z + c.x * s.y * s.z,\n    c.x * s.y * c.z - s.x * c.y * s.z,\n    c.x * c.y * s.z - s.x * s.y * c.z,\n    c.x * c.y * c.z + s.x * s.y * s.z\n  );\n}\n\n// from http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm\nvec4 axisAngleToQuaternion( const vec3 axis, const float angle ) \n{\n  return vec4( axis * sin( angle*.5 ), cos( angle*.5 ) );\n}\n\nvec3 applyQuaternion( const vec3 v, const vec4 q )\n{\n  return v + 2. * cross( q.xyz, cross( q.xyz, v ) + q.w * v );\n}\n\nvec3 displacement( const vec3 v, const vec3 a, const float t )\n{\n  return (v + 0.5 * a * t) * t;\n}\n\nfloat displacement1D( const float v, const float a, const float t )\n{\n  return (v + 0.5 * a * t) * t;\n}\n\nfloat ribbonShape( const float p )\n{\n  return RIBBON_SHAPE_FUNCTION;\n}\n\nvec3 particleMotion( const vec3 p, const vec3 v, const vec3 a, const vec3 av, const vec3 aa, const vec3 axis, const float ov, const float oa, const vec3 dest, const float weight, const float t )\n{\n  vec3 pos = p + displacement(v, a, t);\n\n#if defined(USE_PARTICLE_ANGULAR_VELOCITY) || defined(USE_PARTICLE_ANGULAR_ACCELERATION)\n  pos = applyQuaternion( pos, eulerToQuaternion( displacement(av, aa, t) ) );\n#endif\n\n#if defined(USE_PARTICLE_ORBITAL)\n  pos = applyQuaternion( pos, axisAngleToQuaternion( axis, displacement1D(ov, oa, t) ) );\n#endif\n\n#if defined(USE_PARTICLE_SOURCE)\n  pos = applyQuaternion( pos, quaternion );\n#endif\n\npos += position;\n\n#if defined(USE_PARTICLE_DESTINATION)\n  pos = mix( pos, dest, weight );\n#endif\n\n  return pos;\n}\n\nvec2 toScreen( const vec4 clipSpacePos )\n{\n  return clipSpacePos.xy / clipSpacePos.w;\n}\n\nvoid main() {\n\n  float time = params[0].x;\n  float cpuID = params[0].y;\n  float radialTypeX = params[0].z;\n  float radialTypeY = params[4].w;\n  float duration = params[0].w;\n  float spawnType = params[1].x;\n  float spawnRate = params[1].y;\n  float baseSeed = params[1].z;\n  float vertexCount = params[1].w;\n  float direction = params[2].z; // 0 is forward, 1 is backward  \n  float trailInterval = params[3].x;\n  float particleCount = params[3].y;\n  float trailCount = params[3].z;\n  float maxParticleLifeTime = angularVelocity[1].w; // lifeTime packed into w component of angularVelocity\n  float maxTrailLifeTime = angularAcceleration[1].w; // trailLifeTime packed into angularAcceleration.w\n  float particleLoopTime = particleCount / spawnRate;\n  float motionAge = -1.; // used to determine the age for particle movement\n\n#if defined(USE_PARTICLE_TRAILS) || defined(USE_RIBBON_TRAILS) || defined(USE_RIBBON_3D_TRAILS)\n  float maxAge = maxParticleLifeTime + maxTrailLifeTime;\n#else\n  float maxAge = maxParticleLifeTime;\n#endif\n\n  // the CPU manages IDs if it sets the position or disables particles, otherwise cpuID is -1\n  float particleID0 = cpuID > -EPSILON ? cpuID : floor( mod( time, particleLoopTime ) * spawnRate ); // this will lose precision eventually\n\n  vOverTimeRatio = -1.; // the vOverTimeRatio will be used for the lerps on over-time attributes\n\n  // particles are either emitted in a burst (spawnType == 0) or spread evenly\n  // throughout 0..particleLoopTime (spawnType == 1).  We calculate the ID of the last spawned particle particleID0 \n  // for this frame, any vertex IDs after particleID0 are assumed to belong to the previous loop\n\n  // vertex 0 = trail0 of particle0, vertex 1 = trail1 of particle0, ..., vertex k = trail0 of particle1, ...\n#if defined(USE_RIBBON_TRAILS) || defined(USE_RIBBON_3D_TRAILS)\n  float rawParticleID = floor( vertexID / VERTS_PER_RIBBON / trailCount );\n#else\n  float rawParticleID = floor( vertexID / trailCount );\n#endif\n\n  float particleLoop = floor( time / particleLoopTime );\n\n#if defined(USE_PARTICLE_SOURCE)\n  // find particleID relative to the last loop\n  float particleID = rawParticleID - floor( particleID0 / particleCount ) * particleCount;\n#else // defined(USE_PARTICLE_SOURCE)\n\n#if PARTICLE_ORDER == 0\n  float particleID = particleID0 - (particleCount - 1. - rawParticleID); // newest last\n#elif PARTICLE_ORDER == 1\n  float particleID = particleID0 - rawParticleID; // oldest last\n#else\n  float particleID = rawParticleID > particleID0 ? rawParticleID - particleCount : rawParticleID; // cyclic (original)\n#endif\n\n#endif // defined(USE_PARTICLE_SOURCE)\n\n  // for burst mode we use the rawParticleID, because the concept of particleID0 is irrelevant\n  particleID = mix( rawParticleID, particleID, spawnType ); \n\n  float particleStartTime = particleLoop * particleLoopTime + particleID / spawnRate * spawnType;\n\n  // we use the id as a seed for the randomizer, but because the IDs are fixed in \n  // the range 0..particleCount we calculate a virtual ID by taking into account\n  // the number of loops that have occurred (note, particles from the previous \n  // loop will have a negative particleID). We use the modoulo of the RANDOM_REPEAT_COUNT \n  // to ensure that the virtualID doesn't exceed the floating point precision\n\n  float virtualID = mod( particleID + particleLoop * particleCount, float( RANDOM_REPEAT_COUNT ) );\n  float seed = pseudoRandom( virtualID*baseSeed*110. );\n\n  float particleLifeTime = randFloatRange( angularVelocity[0].w, angularVelocity[1].w, seed );\n\n  float particleAge = time - particleStartTime;\n  particleAge = particleAge + direction * ( particleLoopTime - 2. * particleAge );\n\n  // don't show particles that would be emitted after the duration\n  if ( duration > 0. && time - particleAge >= duration ) \n  {\n    particleAge = -1.;\n  } \n\n  // always calculate the trailLifeTime, even if we don't use it, so the particles\n  // with the same seed give consistent results\n  float trailLifeTime = randFloatRange( angularAcceleration[0].w, angularAcceleration[1].w, seed );\n\n#if defined(USE_PARTICLE_TRAILS)\n\n  // +1 beceause we show both the lead particle and the first trail at the start\n  // we cap the particleAge to ensure it never goes past the particleLifeTime\n  float cappedParticleAge = min( particleLifeTime - trailInterval, particleAge );\n  float trailID0 = floor( cappedParticleAge / trailInterval ) + 1.;\n  float rawTrailID = mod( vertexID, trailCount );\n\n#if PARTICLE_TRAIL_ORDER == 0\n  float trailID = trailID0 - ( trailCount - 1. - rawTrailID ); // newest last\n#elif PARTICLE_TRAIL_ORDER == 1\n  float trailID = trailID0 - rawTrailID; // oldest last\n#else\n  float trailID = floor( trailID0 / trailCount ) * trailCount;\n  trailID += rawTrailID > mod( trailID0, trailCount ) ? rawTrailID - trailCount : rawTrailID; // cyclic (original)\n#endif\n\n  float trailStartAge = trailID * trailInterval;\n  \n  if (particleAge > -EPSILON && trailStartAge > -EPSILON && trailStartAge < particleLifeTime + EPSILON)\n  {\n    if (particleAge < trailStartAge)\n    {\n      motionAge = particleAge;\n      vOverTimeRatio = 0.;\n    }\n    else if (particleAge < trailStartAge + trailLifeTime)\n    {\n      motionAge = trailStartAge;\n      vOverTimeRatio = (particleAge - trailStartAge)/trailLifeTime;\n    }\n  }\n\n#elif defined(USE_RIBBON_TRAILS) || defined(USE_RIBBON_3D_TRAILS)\n\n  // +1 to the trailID0 because the ribbon needs two elements to start\n  // we cap the particleAge to ensure it never goes past the particleLifeTime\n  float cappedParticleAge = min( particleLifeTime - trailInterval, particleAge );\n  float trailID0 = floor( cappedParticleAge / trailInterval ) + 1.;\n  float rawTrailID = floor( mod( vertexID / VERTS_PER_RIBBON, trailCount ) );\n  float trailID = max( 0., trailID0 - ( trailCount - 1. - rawTrailID ) ); // newest last\n\n  float trailStartAge = trailID * trailInterval;\n\n  if (particleAge > -EPSILON && trailStartAge > -EPSILON && trailStartAge < particleLifeTime + EPSILON)\n  {\n    // motionAge will typically be the trailStartAge, but the lead particle will be the \n    // cappedParticleAge, and the last particle will be the particleAge - trailLifeTime\n\n    motionAge = min( cappedParticleAge, max( particleAge - trailLifeTime, trailStartAge ) );\n    vOverTimeRatio = ( particleAge - motionAge ) / trailLifeTime;\n  }\n  else\n  {\n    motionAge = particleLifeTime;\n    vOverTimeRatio = 1.0;\n  }\n\n#else // defined(USE_PARTICLE_TRAILS) || defined(USE_RIBBON_TRAILS) || defined(USE_RIBBON_3D_TRAILS)\n\n  motionAge = particleAge;\n  vOverTimeRatio = particleAge/particleLifeTime;\n\n#endif // defined(USE_PARTICLE_TRAILS) || defined(USE_RIBBON_TRAILS) || defined(USE_RIBBON_3D_TRAILS)\n\n  // these checks were around large blocks of code above, but this caused instability\n  // in some of the particle systems, so instead we do all of the work, then cancel \n  // it out here\n  if ( particleStartTime < 0. || vertexID < 0. )\n  {\n    vOverTimeRatio = -1.;\n  }\n\n#if defined(USE_PARTICLE_DRAG)\n  // simulate drag by blending the motionAge to (1-.5*drag)*particleLifeTime\n  float drag = params[2].w;\n  motionAge = mix( .5*drag*vOverTimeRatio, 1. - .5*drag, vOverTimeRatio ) * particleLifeTime;\n#endif\n\n  vec3 p = vec3(0.); // position\n  vec3 v = vec3(0.); // velocity\n  vec3 a = vec3(0.); // acceleration\n  vec3 av = vec3(0.); // angular velocity\n  vec3 aa = vec3(0.); // angular acceleration\n  vec3 axis = vec3( 1., 0., 0. ); // axis of orbital motion\n  float ov = 0.; // orbital velocity\n  float oa = 0.; // orbital acceleration\n  vec3 dest = vec3(0.); // destination position\n  float destWeight = 0.; // destination weighting\n\n#if defined(USE_PARTICLE_OFFSET)\n  p = randVec3Range( offset[0].xyz, offset[1].xyz, seed );\n#endif\n\n#if defined(USE_PARTICLE_VELOCITY)\n  v = randVec3Range( velocity[0].xyz, velocity[1].xyz, seed );\n#endif\n\n#if defined(USE_PARTICLE_ACCELERATION)\n  a = randVec3Range( acceleration[0].xyz, acceleration[1].xyz, seed );\n#endif\n\n#if defined(USE_PARTICLE_RADIAL_OFFSET) || defined(USE_PARTICLE_RADIAL_VELOCITY) || defined(USE_PARTICLE_RADIAL_ACCELERATION)\n  vec2 ANGLE_RANGE[2];\n  vec2 radialDir = vec2( radialTypeX, radialTypeY );\n  ANGLE_RANGE[0] = vec2( 0., 0. ) * radialDir;\n  ANGLE_RANGE[1] = vec2( 2.*PI, 2.*PI ) * radialDir;\n\n  vec2 theta = randVec2Range( ANGLE_RANGE[0], ANGLE_RANGE[1], seed );\n#endif\n\n#if defined(USE_PARTICLE_RADIAL_OFFSET)\n  float pr = randFloatRange( offset[0].w, offset[1].w, seed );\n  vec3 p2 = radialToVec3( pr, theta );\n  p += p2;\n#endif\n\n#if defined(USE_PARTICLE_RADIAL_VELOCITY)\n  float vr = randFloatRange( velocity[0].w, velocity[1].w, seed );\n  vec3 v2 = radialToVec3( vr, theta );\n  v += v2;\n#endif\n\n#if defined(USE_PARTICLE_RADIAL_ACCELERATION)\n  float ar = randFloatRange( acceleration[0].w, acceleration[1].w, seed );\n  vec3 a2 = radialToVec3( ar, theta );\n  a += a2;\n#endif\n\n#if defined(USE_PARTICLE_ANGULAR_VELOCITY)\n  av = randVec3Range( angularVelocity[0].xyz, angularVelocity[1].xyz, seed );\n#endif\n\n#if defined(USE_PARTICLE_ANGULAR_ACCELERATION)\n  aa = randVec3Range( angularAcceleration[0].xyz, angularAcceleration[1].xyz, seed );\n#endif\n\n#if defined(USE_PARTICLE_ORBITAL)\n  if ( length(p) > EPSILON ) {\n    ov = randFloatRange( orbital[0].x, orbital[1].x, seed );\n    float oa = randFloatRange( orbital[0].y, orbital[1].y, seed );\n    float angle = displacement1D(ov, oa, motionAge);\n\n    vec3 randomOribit = vec3( random( seed ), random( seed ), random( seed ) ); // should never equal p or 0,0,0\n    axis = normalize( cross( normalize( p ), normalize( randomOribit ) ) );\n  }\n#endif\n\n#if defined(USE_PARTICLE_DESTINATION)\n  destWeight = randFloatRange( destination[0].w, destination[1].w, seed );\n  dest = randVec3Range( destination[0].xyz, destination[1].xyz, seed );\n#endif\n\n  vec3 transformed = particleMotion( p, v, a, av, aa, axis, ov, oa, dest, motionAge/particleLifeTime*destWeight, motionAge );\n\n  vec2 rotScale = calcRotationScaleOverTime( vOverTimeRatio, seed );\n  float particleScale = rotScale.y;\n  float c = cos( rotScale.x );\n  float s = sin( rotScale.x );\n\n  vParticleColor = calcColorOverTime( vOverTimeRatio, seed ); // rgba format\n\n#if defined(USE_PARTICLE_VELOCITY_SCALE)\n  // We repeat all of the displacement calculations at motionAge + a small amount (velocityScaleDelta).\n  // We convert the current position and the future position in screen space and determine\n  // the screen space velocity. VelocityScaleDelta is reasonably small to give better\n  // results for the angular and orbital displacement, and when drag is applied the effective\n  // velocity will tend to 0 as the vOverTimeRatio increases\n\n  float velocityScaleDelta = .02;\n\n#if defined(USE_PARTICLE_DRAG)\n  float futureT = motionAge + velocityScaleDelta*mix(1., 1. - drag, vOverTimeRatio);\n#else\n  float futureT = motionAge + velocityScaleDelta;\n#endif\n\n  vec4 pos2D = projectionMatrix * modelViewMatrix * vec4( transformed, 1. );\n\n  // use min(1) to ensure the particle stops at the destination position\n  vec3 transformedFuture = particleMotion( p, v, a, av, aa, axis, ov, oa, dest, min( 1., futureT/particleLifeTime )*destWeight, futureT );\n\n  vec4 pos2DFuture = projectionMatrix * modelViewMatrix * vec4( transformedFuture, 1. );\n\n  vec2 screen = pos2DFuture.xy / pos2DFuture.z - pos2D.xy / pos2D.z; // TODO divide by 0?\n  screen /= velocityScaleDelta; // gives screen units per second\n\n  float lenScreen = length( screen );\n  vec2 sinCos = vec2(screen.x, screen.y)/max( EPSILON, lenScreen); // 0 degrees is y == 1, x == 0\n  float c2 = c*sinCos.y + s*sinCos.x; // cos(a-b)\n  float s2 = s*sinCos.y - c*sinCos.x; // sin(a-b)\n\n  // replace rotation with our new rotation\n  c = c2;\n  s = s2;\n\n  // rescale the particle length by the z depth, because perspective will be applied later\n  float screenScale = clamp( lenScreen * pos2D.z * velocityScale.x, velocityScale.y, velocityScale.z );\n\n  particleScale *= screenScale;\n\n#endif // defined(USE_PARTICLE_VELOCITY_SCALE)\n\n  vCosSinRotation = vec2( c, s );\n\n  // #include <color_vertex>\n  // #include <begin_vertex> replaced by code above\n  // #include <morphtarget_vertex>\n  // #include <project_vertex> replaced below\n\n#if defined(USE_RIBBON_3D_TRAILS)\n  float ribbonID = mod( vertexID, VERTS_PER_RIBBON );\n  \n  {\n    float nextT = motionAge + trailInterval;\n    float ribbonWidth = params[4].x * ribbonShape( vOverTimeRatio );\n\n    vec3 nextPosition = particleMotion( p, v, a, av, aa, axis, ov, oa, dest, min( 1., nextT/particleLifeTime )*destWeight, nextT );\n    vec3 dir = nextPosition - transformed;\n    float dirLen = length( dir );\n\n    vec3 normal = dir;\n    vec3 up = vec3( 0., c, -s ); // rotation in YZ\n    if ( dirLen > EPSILON && abs( dot( dir, up ) ) < dirLen * 0.99 ) {\n      normal = normalize( cross( up, dir ) );\n    }\n\n    transformed += ribbonWidth * normal * ( 0.5 - ribbonID );  // +normal for ribbonID 0, -normal for ribbonID 1\n  }\n#endif\n\n  vec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );\n  gl_Position = projectionMatrix * mvPosition;\n\n  float usePerspective = params[2].y;\n\n#if defined(USE_RIBBON_TRAILS)\n  float ribbonID = mod( vertexID, VERTS_PER_RIBBON );\n  \n  {\n    mat4 m = projectionMatrix * modelViewMatrix;\n    vec2 curr = toScreen( gl_Position );\n\n    float nextT = motionAge + trailInterval;\n    vec3 nextPosition = particleMotion( p, v, a, av, aa, axis, ov, oa, dest, min( 1., nextT/particleLifeTime )*destWeight, nextT );\n    vec2 next2D = toScreen( m * vec4( nextPosition, 1. ) ) - curr;\n\n    vec2 dir = normalize( next2D );\n    vec2 normal = vec2( -dir.y, dir.x );\n\n    float ribbonWidth = params[4].x * ribbonShape( vOverTimeRatio );\n    float halfWidth = .5 * ribbonWidth * mix( 1., 1. / - mvPosition.z, usePerspective );\n  \n    gl_Position.xy += halfWidth * normal * ( 1. - ribbonID * 2. ); // +normal for ribbonID 0, -normal for ribbonID 1\n  }\n#endif\n\n#if defined(USE_PARTICLE_SCREEN_DEPTH_OFFSET)\n  float screenDepthOffset = params[3].w;\n\n#if defined(USE_PARTICLE_TRAILS) || defined(USE_RIBBON_TRAILS) || defined(USE_RIBBON_3D_TRAILS)\n  // multiply trailCount by 2 because trailID ranges from [-trailCount, trailCount]\n  gl_Position.z -= (particleID*trailCount*2. + trailID - trailID0)*gl_Position.w*screenDepthOffset/vertexCount;\n#else\n  gl_Position.z -= particleID*gl_Position.w*screenDepthOffset/vertexCount;\n#endif\n\n#endif // defined(USE_PARTICLE_SCREEN_DEPTH_OFFSET)\n\n// vFrame is an int, but we must pass it as a float, so add .5 now and floor() in the\n// fragment shader to ensure there is no rounding error\n#if defined(USE_PARTICLE_RANDOMIZE_FRAMES)\n  vFrame = floor ( random( seed ) * textureFrames.z ) + .5;\n#else\n  float textureCount = textureFrames.z;\n  float textureLoop = textureFrames.w;\n\n  vFrame = floor( mod( vOverTimeRatio * textureCount * textureLoop, textureCount ) ) + .5;\n#endif\n\n#if !defined(USE_RIBBON_TRAILS) && !defined(USE_RIBBON_3D_TRAILS)\n  float particleSize = params[2].x;\n\n  gl_PointSize = particleSize * particleScale * mix( 1., 1. / - mvPosition.z, usePerspective );\n#endif\n\n  // #include <logdepthbuf_vertex>\n  // #include <clipping_planes_vertex>\n  // #include <worldpos_vertex>\n  #include <fog_vertex>\n\n#if defined(USE_RIBBON_TRAILS) || defined(USE_RIBBON_3D_TRAILS)\n  float ribbonUVMultiplier = params[4].y;\n  float ribbonUVType = params[4].z;\n\n  vUv = vec2( mix( 1. - vOverTimeRatio, motionAge/trailInterval, ribbonUVType ) * ribbonUVMultiplier, 1. - ribbonID );\n#endif\n}",ue="\n#include <common>\n#include <packing>\n// #include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n// #include <logdepthbuf_pars_fragment>\n// #include <clipping_planes_pars_fragment>\n\nuniform vec4 textureFrames;\nuniform vec3 emitterColor;\n\nvarying vec4 vParticleColor;\nvarying vec2 vCosSinRotation;\nvarying vec2 vUv;\nvarying float vOverTimeRatio;\nvarying float vFrame;\n\nvoid main() {\n  if ( vOverTimeRatio < 0. || vOverTimeRatio > 1. ) {\n    discard;\n  }\n\n  #include <clipping_planes_fragment>\n\n  vec3 outgoingLight = vec3( 0. );\n  vec4 diffuseColor = vec4( emitterColor, 1. );\n  mat3 uvTransform = mat3( 1. );\n\n#if defined(USE_PARTICLE_ROTATION) || defined(USE_PARTICLE_FRAMES) || defined(USE_PARTICLE_VELOCITY_SCALE)\n  {\n    vec2 invTextureFrame = 1. / textureFrames.xy;\n    float textureCount = textureFrames.z;\n    float textureLoop = textureFrames.w;\n\n    float frame = floor(vFrame);\n    float c = vCosSinRotation.x;\n    float s = vCosSinRotation.y;\n    float tx = mod( frame, textureFrames.x ) * invTextureFrame.x;\n    float ty = (textureFrames.y - 1. - floor( frame * invTextureFrame.x )) * invTextureFrame.y; // assumes textures are flipped on y\n    float sx = invTextureFrame.x;\n    float sy = invTextureFrame.y;\n    float cx = tx + invTextureFrame.x * .5;\n    float cy = ty + invTextureFrame.y * .5;\n  \n    uvTransform[0][0] = sx * c;\n    uvTransform[0][1] = -sx * s;\n    uvTransform[1][0] = sy * s;\n    uvTransform[1][1] = sy * c;\n    uvTransform[2][0] = c * tx + s * ty - ( c * cx + s * cy ) + cx;\n    uvTransform[2][1] = -s * tx + c * ty - ( -s * cx + c * cy ) + cy;\n  }\n#endif // defined(USE_PARTICLE_ROTATION) || defined(USE_PARTICLE_FRAMES) || defined(USE_PARTICLE_VELOCITY_SCALE)\n\n  // #include <logdepthbuf_fragment>\n  // #include <map_particle_fragment>\n  // #include <color_fragment>\n\n#ifdef USE_MAP\n\n#if defined(USE_RIBBON_TRAILS) || defined(USE_RIBBON_3D_TRAILS)\n  vec2 uv = ( uvTransform * vec3( vUv, 1. ) ).xy;\n#else\n  vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1. ) ).xy;\n#endif\n\n  vec4 mapTexel = texture2D( map, uv );\n  diffuseColor *= mapTexelToLinear( mapTexel );\n#endif // USE_MAP\n\n  #include <alphatest_fragment>\n\n  diffuseColor *= vParticleColor;\n  outgoingLight = diffuseColor.rgb;\n\n  gl_FragColor = diffuseColor;\n\n  // #include <premultiplied_alpha_fragment>\n  // #include <tonemapping_fragment>\n  // #include <encodings_fragment>\n  #include <fog_fragment>\n}";function he(){let e,t,n=[];function i(){if(e&&t)for(let i of n)i.removeEventListener(e,t)}function a(e,t,n,i){switch(n){case"self":return""===t?[e]:e.querySelectorAll(t)||[e];case"parent":return""===t?[e]:e.parentNode.querySelectorAll(t)||[e];case"event":{const n=i||e;return""===t?[n]:n.querySelectorAll(t)||[n]}case"document":default:return""===t?[e]:document.querySelectorAll(t)||[e]}}return{set:function(r,o,s,l,c){i(),n=a(r,o,s),e=l,t=c},add:function(){if(e&&t)for(let i of n)i.addEventListener(e,t)},remove:i,getElementsInScope:a}}function fe(){let e,t,n,i;function a(i,a){r(),i>0?(e=setTimeout(a,1e3*i),t=Date.now(),n=a):a()}function r(){clearTimeout(self.sendEventTimer),e=void 0,t=void 0,i=void 0,n=void 0}return{start:a,stop:r,pause:function(){if(e){let e=Date.now()-t;r(),i=e}},resume:function(){i&&(a(i,n),i=void 0)}}}function me(e){let t=function(e){let t={type:"",id:"",classes:[],attrs:{}},n="type",i=0,a="";function r(r,o){let s=e.slice(i,o);if(o>i)switch(n){case"type":t.type=s;break;case"id":t.id=s;break;case"class":t.classes.push(s);break;case"attr":a=s;break;case"value":a&&(t.attrs[a]=s)}n=r,i=o+1}for(let t=0,i=e.length;t<i;t++)switch(e[t]){case"\\":t++;break;case"#":"attr"!==n&&"value"!==n&&r("id",t);break;case".":"attr"!==n&&"value"!==n&&r("class",t);break;case"[":"attr"!==n&&"value"!==n&&r("attr",t);break;case"]":"attr"!==n&&"value"!==n||r("none",t);break;case"=":"attr"===n&&r("value",t)}return r("end",e.length),t}(e),n=t.type||"a-entity",i=document.createElement(n);if(i){t.id&&(i.id=t.id),t.classes.length>0&&i.classList.add(...t.classes);for(let e in t.attrs)AFRAME.utils.entity.setComponentProperty(i,e,pe(t.attrs[e]))}return i}function pe(e){const t="'"===(e=e.trim())[0]||'"'===e[0]?1:0,n=e.length;let i="'"===e[n-1]||'"'===e[n-1]?n-1:n;return 0===t&&i===n?e:e.slice(t,i)}AFRAME.registerComponent("timer-emit",{schema:{src:{type:"selector"},target:{default:""},targetScope:{default:"document",oneOf:["document","self","parent"]},stopOnPause:{default:!0}},multiple:!0,init(){this.sendEvents=this.sendEvents.bind(this),this.mediaEl=void 0,this.restartMedia=!1,this.clockStartTime=Date.now(),this.targets=[]},remove(){this.removeListeners()},updateSchema(e){const t=AFRAME.components["timer-emit"].schema;let n={};for(let i in e)i in t||(n[i]={type:"string"});Object.keys(n).length>0&&this.extendSchema(n)},pause(){const e=this.data;this.removeListeners(),e.stopOnPause&&(this.pauseTime=Date.now(),clearTimeout(this.sendEventsTimer),this.sendEventsTimer=void 0,this.mediaEl&&!this.mediaEl.paused&&(this.mediaEl.pause(),this.restartMedia=!0))},play(){this.pauseTime&&(this.clockStartTime+=Date.now()-this.pauseTime,delete this.pauseTime),this.mediaEl&&(this.addListeners(),this.restartMedia&&(this.mediaEl.play(),this.restartMedia=!1)),this.sendEvents()},update(e){const t=this.data,n=AFRAME.components["timer-emit"].schema;e.src!==t.src&&(this.removeListeners(),this.mediaEl=t.src instanceof HTMLMediaElement?t.src:void 0),e.target!==t.target&&(this.targets=this.querySelectorAll(t.targetScope,t.target)),this.events=[];for(let e in t)if(!(e in n)){let n=t[e].split(",").map(e=>Number(e));for(let t of n)isNaN(t)||this.events.push([t,e])}this.events.sort((e,t)=>e[0]-t[0]),this.lastSendEventsTime=-1},querySelectorAll(e,t){if(""==t)return[this.el];switch(e){case"self":return this.el.querySelectorAll(t)||[this.el];case"parent":return this.el.parentNode.querySelectorAll(t)||[this.el];case"document":default:return document.querySelectorAll(t)||[this.el]}},addListeners(){this.mediaEl&&this.mediaEl.addEventListener("play",this.sendEvents)},removeListeners(){this.mediaEl&&this.mediaEl.removeEventListener("play",this.sendEvents)},sendEvents(){if(this.mediaEl&&this.mediaEl.paused)return;let e,t=this.mediaEl?this.mediaEl.currentTime:(Date.now()-this.clockStartTime)/1e3,n=[];for(let i of this.events)if(!(i[0]<=this.lastSendEventsTime)){if(!(i[0]<=t)){e=i[0];break}n.push(i[1])}if(n.length>0){this.data;const e=this.el;for(let t of this.targets){const i={source:e,target:t};for(let e of n)t.emit(e,i)}}this.lastSendEventsTime=t,e&&(this.sendEventsTimer=setTimeout(this.sendEvents,1e3*(e-t)))}}),AFRAME.registerComponent("wait-add-remove",{schema:{delay:{default:0},event:{default:""},source:{default:""},sourceScope:{default:"document",oneOf:["parent","self","document"]},add:{type:"array"},addRepeat:{type:"int",default:1},remove:{type:"array"}},multiple:!0,init(){this.addRemoveEntities=this.addRemoveEntities.bind(this),this.startDelay=this.startDelay.bind(this),this.waitTimer=fe(),this.waitListener=he()},update(e){const t=this.data;e.event===t.event&&e.source===t.source&&e.sourceScope===t.sourceScope||this.waitListener.set(this.el,t.source,t.sourceScope,t.event,this.startDelay),e.delay===t.delay||!this.timer&&""!==t.event||this.startDelay()},pause(){this.waitTimer.pause(),this.waitListener.remove()},play(){this.waitListener.add(),this.waitTimer.resume()},startDelay(){this.waitTimer.start(this.data.delay,this.addRemoveEntities)},addRemoveEntities(){const e=this.data;for(let t of e.remove){this.el.querySelectorAll(t).forEach(e=>this.el.removeChild(e))}for(let t=0;t<e.addRepeat;++t)for(let t of e.add){let e=me(t);e&&this.el.appendChild(e)}}}),AFRAME.registerComponent("wait-emit",{schema:{event:{default:""},delay:{default:0},source:{default:""},sourceScope:{default:"document",oneOf:["parent","self","document"]},out:{default:""},target:{default:""},targetScope:{default:"document",oneOf:["parent","self","document"]}},multiple:!0,init(){this.sendEvent=this.sendEvent.bind(this),this.startTimer=this.startTimer.bind(this),this.onEvent=this.onEvent.bind(this),this.sources=[],this.waitTimer=fe(),this.waitListener=he()},remove(){this.waitListener.remove(),this.waitTimer.stop()},update(e){const t=this.data;t.event===e.event&&t.source===e.source&&t.sourceScope===e.sourceScope||this.waitListener.set(this.el,t.source,t.sourceScope,t.event,this.onEvent),t.delay===e.delay||!this.sendwaitTimer&&""!==t.event||this.waitTimer.start(t.delay,this.sendEvent)},pause(){this.waitListener.remove(),this.waitTimer.pause()},play(){this.waitListener.add(),this.waitTimer.resume()},onEvent(){this.waitTimer.start(this.data.delay,this.sendEvent)},sendEvent(e){const t=this.data,n=this.waitListener.getElementsInScope(this.el,t.target,t.targetScope,e.target),i=Object.assign({source:this.el},e),a=t.out?t.out:t.event;for(let e of n)e.emit(a,i)}}),AFRAME.registerComponent("wait-set",{schema:{delay:{default:0},event:{default:""},source:{default:""},sourceScope:{default:"document",oneOf:["parent","self","document"]},target:{default:""},targetScope:{default:"document",oneOf:["parent","self","document","event"]},seed:{type:"int",default:-1}},multiple:!0,init(){this.setProperties=this.setProperties.bind(this),this.startDelay=this.startDelay.bind(this),this.eventTargetEl=void 0,this.rules={},this.sources=[],this.waitListener=he(),this.waitTimer=fe(),this.lcg=f()},remove(){this.waitListener.remove(),this.waitTimer.stop()},updateSchema(e){const t=AFRAME.components[this.name].schema;let n={};for(let i in e)i in t||(n[i]={default:""});Object.keys(n).length>0&&this.extendSchema(n)},update(e){const t=AFRAME.components[this.name].schema,n=this.data;n.seed!==e.seed&&this.lcg.setSeed(n.seed);for(let e in this.rules)e in n||delete this.rules[e];for(let i in n)i in t||n[i]===e[i]||(this.rules[i]=E(n[i]));n.event===e.event&&n.source===e.source&&n.sourceScope===e.sourceScope||this.waitListener.set(this.el,n.source,n.sourceScope,n.event,this.startDelay),n.delay===e.delay||!this.delayTimer&&""!==n.event||this.startDelay()},pause(){this.waitListener.remove(),this.waitTimer.pause()},play(){this.waitTimer.resume(),this.waitListener.add()},startDelay(e){this.eventTargetEl=e?e.target:void 0,this.waitTimer.start(this.data.delay,this.setProperties)},setProperties(){const e=this.waitListener.getElementsInScope(this.el,this.data.target,this.data.targetScope,this.eventTargetEl);for(let t of e)for(let e in this.rules){let n=this.rules[e];const i=R(A(n,this.lcg.random));I(t,e,i)}}})});