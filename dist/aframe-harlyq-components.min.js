!function(e){"function"==typeof define&&define.amd?define(e):e()}(function(){"use strict";const e=new THREE.Vector3(0,1,0);AFRAME.registerComponent("arm-swinger",{schema:{handSelectors:{type:"selectorAll"},startEvent:{default:"gripdown"},endEvent:{default:"gripup"},cameraRig:{type:"selector"},scaling:{default:1},enabled:{default:!0}},init(){this.onStartEvent=this.onStartEvent.bind(this),this.onEndEvent=this.onEndEvent.bind(this),this.tick=AFRAME.utils.throttleTick(this.tick,100,this),this.newOffset=new THREE.Vector3,this.isMoving=!1,this.isEnabled=!1,this.sides=[]},update(e){const t=this.data;if(e.handSelectors!==t.handSelectors&&(this.sides.length=0,t.handSelectors))for(let e of t.handSelectors)this.sides.push({handEl:e,active:!1,positions:[],forwards:[]});e.enabled!==t.enabled&&(t.enabled?this.enable():this.disable())},play(){this.data.enabled&&this.enable()},pause(){this.disable()},tick(e,t){const n=this.data,i=.001*t;let[a,s]=this.sides.length>0?this.tickSide(this.sides[0]):[void 0,void 0],[r,o]=this.sides.length>1?this.tickSide(this.sides[1]):[void 0,void 0];if(this.isMoving=!1,s||o){this.newOffset.set(0,0,0);let e=0;s&&(this.newOffset.add(s),e=Math.max(e,a)),o&&(this.newOffset.add(o),e=Math.max(e,r)),this.newOffset.y=0,this.newOffset.normalize().multiplyScalar(-n.scaling*e*i),this.isMoving=!0}},tock(){const e=this.data,t=e.cameraRig?e.cameraRig.object3D:this.el.object3D;this.isMoving&&t&&t.position.add(this.newOffset)},enable(){if(!this.isEnabled){for(let e of this.sides)this.addListeners(e.handEl);this.isEnabled=!0}},disable(){if(this.isEnabled){for(let e of this.sides)this.deactivate(e),this.removeListeners(e.handEl);this.isEnabled=!1}},onStartEvent(e){for(let t of this.sides)e.target===t.handEl&&this.activate(t)},onEndEvent(e){for(let t of this.sides)e.target===t.handEl&&this.deactivate(t)},addListeners(e){e&&(e.addEventListener(this.data.startEvent,this.onStartEvent),e.addEventListener(this.data.endEvent,this.onEndEvent))},removeListeners(e){e&&(e.removeEventListener(this.data.startEvent,this.onStartEvent),e.removeEventListener(this.data.endEvent,this.onEndEvent))},activate(e){e.active=!0,e.positions.length=0,e.forwards.length=0},deactivate(e){e.active=!1},tickSide(t){if(!t.active)return[void 0,void 0];let n,i;t.positions.length>=3?(n=t.positions.shift(),i=t.forwards.shift()):(n=new THREE.Vector3,i=new THREE.Vector3);const a=t.handEl.object3D.matrixWorld;t.positions.push(n.setFromMatrixPosition(a)),t.forwards.push(i.setFromMatrixColumn(a,0).cross(e));let s=0;const r=t.positions.length;for(let e=1;e<r;e++)s+=t.positions[e].distanceTo(t.positions[e-1]);return[s,i]}});AFRAME.registerSystem("audio-vis",{schema:{src:{type:"selector"},fftSize:{default:32}},init:function(){this.context=void 0,this.analysers={}},getOrCreateAnalyser:function(){this.context||(this.context=new AudioContext);const e=this.data.src,t=(e=>{const t=e.className.split(" ");return e.localName.toLowerCase()+(t[0]?"."+t.join("."):"")+"#"+e.id})(e);if(this.analysers[t])return this.analysers[t];const n=this.data.fftSize;let i=this.context.createAnalyser();return this.context.createMediaElementSource(e).connect(i),i.connect(this.context.destination),i.fftSize=n,i.fetchTime=-1,i.frequencyData=new Uint8Array(n),this.analysers[t]=i,i},getByteFrequencyData:function(e,t){return t!==e.fetchTime&&(e.getByteFrequencyData(e.frequencyData),e.fetchTime=t),e.frequencyData}});const t=e=>Number(e),n=e=>e.trim().split(" ").map(t),i=e=>e.includes(".."),a=e=>e.split("..").map(n),s=(e,t)=>{if(e.length<1)return e[0];let n=[];const i=e[0],a=e[1];for(let e=0,s=Math.max(i.length,a.length);e<s;e++)n[e]=THREE.Math.lerp(i[e]||0,a[e]||0,t);return n},r={bins:{type:"array",default:[0],parse:e=>"string"==typeof e?e.split(",").map(t):e},threshold:{default:0,min:0,max:1}};AFRAME.registerComponent("audio-vis",{schema:r,multiple:!0,init:function(){this.ranges={},this.analyser=this.system.getOrCreateAnalyser()},updateSchema:function(e){"object"!=typeof e&&console.error(`invalid properties, expected format <property>:<value>; '${e}'`);let t={};for(let n in e)n in this.schema||(t[n]={type:"string"});(e=>{for(let t in e)if(e.hasOwnProperty(t))return!1;return!0})(t)||this.extendSchema(t)},update:function(e){const t=this.data;for(let e in t)e in r||!i(t[e])||(this.ranges[e]=a(t[e]))},tick:function(e,t){const n=this.data,i=this.system.getByteFrequencyData(this.analyser,e),a=n.bins,r=a.length;let o=0;for(let e of a)o+=i[e];let l=o/r/255,c=l>n.threshold?l:0,d=this.el;for(let e in this.ranges){const t=s(this.ranges[e],c);switch(e){case"position":case"scale":d.object3D[e].set(...t);break;case"rotation":d.object3D[e].set(...t.map(THREE.Math.degToRad));break;default:d.setAttribute(e,t.map(e=>e.toFixed(4)).join(" "))}}}});Object.freeze({x:0,y:0,z:0}),Object.freeze({x:1,y:0,z:0}),Object.freeze({x:0,y:1,z:0}),Object.freeze({x:0,y:0,z:1});function o(e,t){return e.x=t.x,e.y=t.y,e.z=t.z,e}function l(e,t,n){return e.x=Math.max(t.x,n.x),e.y=Math.max(t.y,n.y),e.z=Math.max(t.z,n.z),e}const c=Math.sqrt(.5);Object.freeze({x:0,y:0,z:0,w:1}),Object.freeze({x:1,y:0,z:0,w:0}),Object.freeze({x:0,y:1,z:0,w:0}),Object.freeze({x:0,y:0,z:1,w:0}),Object.freeze({x:c,y:0,z:0,w:c}),Object.freeze({x:0,y:c,z:0,w:c}),Object.freeze({x:0,y:0,z:c,w:c});function d(e,t,n){const i=n.x,a=n.y,s=n.z;return e.x=t[0]*i+t[4]*a+t[8]*s+t[12],e.y=t[1]*i+t[5]*a+t[9]*s+t[13],e.z=t[2]*i+t[6]*a+t[10]*s+t[14],e}function h(e,t,n){const i=t[0],a=t[1],s=t[2],r=t[4],o=t[5],l=t[6],c=t[8],d=t[9],h=t[10],u=t[12],m=t[13],p=t[14],f=h*o-l*d,g=l*c-h*r,v=d*r-o*c,y=1/(i*f+a*g+s*v),b=f*y,E=(s*d-h*a)*y,x=(l*a-s*o)*y,T=g*y,w=(h*i-s*c)*y,A=(s*r-l*i)*y,S=v*y,R=(a*c-d*i)*y,C=(o*i-a*r)*y,k=n.x-u,M=n.y-m,I=n.z-p;return e.x=b*k+T*M+S*I,e.y=E*k+w*M+R*I,e.z=x*k+A*M+C*I,e}function u(e,t=Math.random){return e[function(e,t=Math.random){return~~Math.min(e-1,t()*e)}(e.length,t)]}function m(e,t,n=Math.random){return t===e?e:n()*(t-e)+e}function p(){let e=-1;return{setSeed:function(t){e=t},random:function(){return e<0?Math.random():(e=(1664525*e+1013904223)%4294967296)/4294967296}}}function f(e,t,n){return e<t?t:e>n?n:e}function g(e){return"object"==typeof e&&"r"in e&&"g"in e&&"b"in e}const v=function(){function e(e,t,n){return n<0&&(n+=1),n>1&&(n-=1),n<1/6?e+6*(t-e)*n:n<.5?t:n<2/3?e+6*(t-e)*(2/3-n):e}return function(t,n,i,a){var s;if(n=(n%(s=1)+s)%s,i=f(i,0,1),a=f(a,0,1),0===i)t.r=t.g=t.b=a;else{let s=a<=.5?a*(1+i):a+i-a*i,r=2*a-s;t.r=e(r,s,n+1/3),t.g=e(r,s,n),t.b=e(r,s,n-1/3)}return t}}();const y={aliceblue:15792383,antiquewhite:16444375,aqua:65535,aquamarine:8388564,azure:15794175,beige:16119260,bisque:16770244,black:0,blanchedalmond:16772045,blue:255,blueviolet:9055202,brown:10824234,burlywood:14596231,cadetblue:6266528,chartreuse:8388352,chocolate:13789470,coral:16744272,cornflowerblue:6591981,cornsilk:16775388,crimson:14423100,cyan:65535,darkblue:139,darkcyan:35723,darkgoldenrod:12092939,darkgray:11119017,darkgreen:25600,darkgrey:11119017,darkkhaki:12433259,darkmagenta:9109643,darkolivegreen:5597999,darkorange:16747520,darkorchid:10040012,darkred:9109504,darksalmon:15308410,darkseagreen:9419919,darkslateblue:4734347,darkslategray:3100495,darkslategrey:3100495,darkturquoise:52945,darkviolet:9699539,deeppink:16716947,deepskyblue:49151,dimgray:6908265,dimgrey:6908265,dodgerblue:2003199,firebrick:11674146,floralwhite:16775920,forestgreen:2263842,fuchsia:16711935,gainsboro:14474460,ghostwhite:16316671,gold:16766720,goldenrod:14329120,gray:8421504,green:32768,greenyellow:11403055,grey:8421504,honeydew:15794160,hotpink:16738740,indianred:13458524,indigo:4915330,ivory:16777200,khaki:15787660,lavender:15132410,lavenderblush:16773365,lawngreen:8190976,lemonchiffon:16775885,lightblue:11393254,lightcoral:15761536,lightcyan:14745599,lightgoldenrodyellow:16448210,lightgray:13882323,lightgreen:9498256,lightgrey:13882323,lightpink:16758465,lightsalmon:16752762,lightseagreen:2142890,lightskyblue:8900346,lightslategray:7833753,lightslategrey:7833753,lightsteelblue:11584734,lightyellow:16777184,lime:65280,limegreen:3329330,linen:16445670,magenta:16711935,maroon:8388608,mediumaquamarine:6737322,mediumblue:205,mediumorchid:12211667,mediumpurple:9662683,mediumseagreen:3978097,mediumslateblue:8087790,mediumspringgreen:64154,mediumturquoise:4772300,mediumvioletred:13047173,midnightblue:1644912,mintcream:16121850,mistyrose:16770273,moccasin:16770229,navajowhite:16768685,navy:128,oldlace:16643558,olive:8421376,olivedrab:7048739,orange:16753920,orangered:16729344,orchid:14315734,palegoldenrod:15657130,palegreen:10025880,paleturquoise:11529966,palevioletred:14381203,papayawhip:16773077,peachpuff:16767673,peru:13468991,pink:16761035,plum:14524637,powderblue:11591910,purple:8388736,rebeccapurple:6697881,red:16711680,rosybrown:12357519,royalblue:4286945,saddlebrown:9127187,salmon:16416882,sandybrown:16032864,seagreen:3050327,seashell:16774638,sienna:10506797,silver:12632256,skyblue:8900331,slateblue:6970061,slategray:7372944,slategrey:7372944,snow:16775930,springgreen:65407,steelblue:4620980,tan:13808780,teal:32896,thistle:14204888,tomato:16737095,turquoise:4251856,violet:15631086,wheat:16113331,white:16777215,whitesmoke:16119285,yellow:16776960,yellowgreen:10145074},b=/^((?:rgb|hsl)a?)\(\s*([^\)]*)\)/;function E(e){let t;if(t=b.exec(e)){let e;const n=t[1],i=t[2];switch(n){case"rgb":case"rgba":if(e=/^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(i)){const t={r:Math.min(255,parseInt(e[1],10))/255,g:Math.min(255,parseInt(e[2],10))/255,b:Math.min(255,parseInt(e[3],10))/255};return e[5]&&(t.a=parseFloat(e[5])),t}if(e=/^(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(i)){const t={r:Math.min(100,parseInt(e[1],10))/100,g:Math.min(100,parseInt(e[2],10))/100,b:Math.min(100,parseInt(e[3],10))/100};return e[5]&&(t.a=parseFloat(e[5])),t}break;case"hsl":case"hsla":if(e=/^([0-9]*\.?[0-9]+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(i)){const t=v({r:0,g:0,b:0,a:0},parseFloat(e[1])/360,parseInt(e[2],10)/100,parseInt(e[3],10)/100);return e[5]&&(t.a=parseFloat(e[5])),t}}}else if(t=/^\#([A-Fa-f0-9]+)$/.exec(e)){const e=t[1],n=e.length;if(3===n)return{r:parseInt(e.charAt(0)+e.charAt(0),16)/255,g:parseInt(e.charAt(1)+e.charAt(1),16)/255,b:parseInt(e.charAt(2)+e.charAt(2),16)/255};if(6===n)return{r:parseInt(e.charAt(0)+e.charAt(1),16)/255,g:parseInt(e.charAt(2)+e.charAt(3),16)/255,b:parseInt(e.charAt(4)+e.charAt(5),16)/255}}if(e&&e.length>0){const t=y[e];if(void 0!==t)return(n={r:0,g:0,b:0}).r=((t=t)>>16&255)/255,n.g=(t>>8&255)/255,n.b=(255&t)/255,n}var n,i}function x(e,t){let n=e,i=t&&Array.isArray(t)?t.slice().reverse():[];for(;n&&i.length>0;)n=n[i.pop()];return n}const T=e=>e,w=Symbol("nested"),A="|",S="->";function R(e,t=C,n=T){const i=function(e){if(V.test(e))return{variable:e};const t=e.split(A);if(t.length>1)return{options:t};const n=e.split(S);if(n.length>1)return{range:[n[0],n[1]]};return{options:t}}(e.trim());return i.variable?{variable:i.variable}:i.range?{range:i.range.map(e=>n(t(e)))}:{options:i.options.map(e=>n(t(e)))}}const C=function(){const e=e=>Number(e.trim());return function(t){if(""===t)return"";let n=t.split(" ").filter(e=>""!==e).map(e);if(!n.some(isNaN))switch(n.length){case 1:return n[0];case 2:return{x:n[0],y:n[1]};case 3:return{x:n[0],y:n[1],z:n[2]};case 4:return{x:n[0],y:n[1],z:n[2],w:n[3]}}let i=E(t.trim());return i||t.trim()}}();function k(e){const t=Number(e.trim());return!e||isNaN(t)?void 0:t}function M(e){const t=function(e){return e.split(" ").filter(e=>""!==e).map(e=>Number(e.trim()))}(e);return t.length<3||t.some(isNaN)?void 0:{x:Number(t[0]),y:Number(t[1]),z:Number(t[2])}}function I(e){return E(e.trim())}function O(e){return"number"==typeof e}function P(e){return"object"==typeof e&&"x"in e&&"y"in e&&"z"in e&&"number"==typeof e.x&&"number"==typeof e.y&&"number"==typeof e.z}function F(e){return"object"==typeof e&&"r"in e&&"g"in e&&"b"in e&&"number"==typeof e.r&&"number"==typeof e.g&&"number"==typeof e.b}function D(e,t){return e.range?e.range.every(t):e.options?e.options.every(t):!!e.variable}function L(e,t,n,i=T){const a=R(e,t,i);return D(a,n)?a:void 0}function H(e,t,n,i,a=T){if(""===e.trim())return[];const s=W(e,",").flatMap(e=>{const n=e.trim();return!i||n?R(n,t,a):void 0});return s.every(e=>!(!i||void 0!==e)||D(e,n))?s:void 0}function j(e,t=T){return H(e,I,F,!1,t)}function _(e,t=T){return L(e,k,O,t)}function z(e,t=T){return H(e,k,O,!1,t)}function N(e,t=T){return L(e,M,P,t)}function B(e){if(e.options){if(e.options.length>0&&"number"==typeof e.options[0])return Math.max(...e.options)}else if(e.range&&"number"==typeof e.range[0])return Math.max(...e.range)}const V=/\$([\.\w]+)\$/g;function U(e,t=Math.random){if(e&&e.range){const n=e.range[0],i=e.range[1];return g(n)?function(e,t,n,i=Math.random){return e.r=m(t.r,n.r,i),e.g=m(t.g,n.g,i),e.b=m(t.b,n.b,i),e}({r:0,g:0,b:0},n,i,t):"object"==typeof n&&"x"in n&&"object"==typeof i&&"x"in i?function(e,t,n,i=Math.random){return e.x=m(t.x,n.x,i),e.y=m(t.y,n.y,i),"z"in t&&"z"in n&&(e.z=m(t.z,n.z,i)),"w"in t&&"w"in n&&(e.w=m(t.w,n.w,i)),e}({x:0,y:0},n,i,t):"number"==typeof n&&"number"==typeof i?m(n,i,t):n}if(e&&e.options)return u(e.options,t)}function q(e,t=Math.random){return e&&e.map(e=>U(e,t))}function G(e){if("object"==typeof e){if(e.range)return G(e.range[0])+S+G(e.range[1]);if(e.options)return e.options.map(e=>G(e)).join(A);if(g(e))return"#"+function(e){return 255*e.r<<16^255*e.g<<8^255*e.b<<0}(e).toString(16).padStart(6,"0");if("x"in e&&"y"in e)return e.x+" "+e.y+("z"in e?" "+e.z:"")+("w"in e?" "+e.w:"");if(e.length&&"0"in e)return e.join(",");if(e instanceof HTMLElement)return"#"+e.id}return void 0!==e?e.toString():void 0}function W(e,t=",",n=["''",'""',"{}","[]","()"]){let i=[],a=[],s=0,r=0;for(let o=0,l=e.length;o<l;o++){const l=e[o];if(a.length>0&&l===a[a.length-1][1])a.pop();else for(let e of n)l===e[0]&&a.push(e);0===a.length&&l===t[r]?++r===t.length&&(i.push(e.substring(s,o-r+1)),s=o+1,r=0):r=0}return i.push(e.substring(s,e.length)),i}const Q=Symbol("default"),$=Symbol("last"),Y=Symbol("first"),X=Symbol("append");function Z(e){return e.tagName.toLowerCase()+(e.id?"#"+e.id:"")+(e.classList.length>0?"."+Array.from(e.classList).join("."):"")}const K=(()=>{const e=e=>e.trim(),t={rotation:e=>isNaN(e)?0:THREE.Math.degToRad(e),position:e=>isNaN(e)?0:e,scale:e=>isNaN(e)?1:e};return function(n,i,a){let s=t[i];if(s)return Array.isArray(a)||(a="object"==typeof a?[a.x,a.y,a.z]:"number"==typeof a?[a]:a.split(" ").map(e)),a.length=3,void n.object3D[i].set(...a.map(s));const r=i.split(".");if(r.length<=2)return r[0]=r[0].replace(/[A-Z]/g,e=>"-"+e.toLowerCase()),void(a||"boolean"==typeof a||"number"==typeof a?AFRAME.utils.entity.setComponentProperty(n,r.join("."),G(a)):n.removeAttribute(r[0],r[1]));const o=x(n,r.slice(0,-1));o?o[r[r.length-1]]=a:console.warn(`unknown path for setProperty() '${i}'`)}})();function J(e,t){const n=t.split(".");if(1===n.length)return e.getAttribute(t);if(n.length<=2){n[0]=n[0].replace(/[A-Z]/g,e=>"-"+e.toLowerCase());const t=e.getAttribute(n[0]);return"object"==typeof t?t[n[1]]:void 0}return x(e,n)}function ee(){let e=[];function t(e,t,i){e.id=setTimeout(()=>{n(e),i()},1e3*t),e.startTime=Date.now(),e.callback=i}function n(t){const n=e.indexOf(t);n>=0&&(clearTimeout(t.id),e.splice(n,1))}return{startTimer:function(n,i){if(n>0){const a={};return t(a,n,i),e.push(a),a}i()},clearTimer:n,clearAllTimers:function(){for(let t of e)clearTimeout(t.id);e.length=0},pause:function(){for(let t of e)t.resumeTime=Date.now()-t.startTime,clearTimeout(t.id)},resume:function(){for(let n of e)n.resumeTime&&(t(n,n.resumeTime,n.callback),delete n.resumeTime)}}}function te(e,t,n,i){switch(n){case"self":return t?e.querySelectorAll(t):[e];case"parent":return t?e.parentNode.querySelectorAll(t):[e];case"event":return t&&i instanceof HTMLElement?i.querySelectorAll(t):[e];case"document":default:return t?document.querySelectorAll(t):[e]}}function ne(e,t){let n,i,a,s=!1,r=[],o=l(n);function l(e){return e&&"string"==typeof e?e.split(",").map(e=>e.trim()):[]}function c(){if(!s){for(let e of r)for(let n of o)e.addEventListener(n,t);s=!0}}function d(){if(s){for(let e of r)for(let n of o)e.removeEventListener(n,t);s=!1}}return{set:function(t,h,u){const m=s;!m||t===n&&h===i&&u===a||d(),i=h,a=u,n!==t&&(o=l(n=t)),r=te(e,i,a,void 0),m&&c()},add:c,remove:d}}function ie(e,t,n){const i=e&&e.match(/url\((.+)\)/);if(i){const e=i[1];(new THREE.FileLoader).load(e,e=>n(e),()=>{},t=>{console.error(`unable to load: ${e} `,t)})}else if(t&&e.includes(t))n(e.trim());else{const t=e?document.querySelector(e):void 0;n(t?t.textContent.trim():e.trim())}}function ae(e,...t){console.log(oe(e),...t)}function se(e,...t){console.warn(oe(e),...t)}function re(e,...t){console.error(oe(e),...t)}function oe(e){return Z(e.el)+"["+e.attrName+"]"}const le="prnbqkPRNBQK",ce=/(O\-O)(\-O)?([\#|\+]?)/,de=/([RNBKQ]?[a-h]?[1-8]?)(x?)([a-h][1-8])(=[RNBQ])?([\#|\+]?)/,he=/1\-0|0\-1|1\/2\-1\/2|\*/,ue=/\[\s*(\w+)\s*\"([^\"]*)\"\s*\]/,me=/([\d\.]+)\s*([a-zA-Z][\w\=\#\+\-\/\*]*)\s+([a-zA-Z][\w\=\#\+\-\/\*]*)?\s*(\d\-\/\*)?\s*(\{[^\}*]\})?\s*/;function pe(e){return e.charCodeAt(0)-96}function fe(e){return e.charCodeAt(0)-48}function ge(e){return 2===e.length?[pe(e[0]),fe(e[1])]:void 0}function ve(e,t){return String.fromCharCode(e+96,t+48)}function ye(e){if(!e)return;const t=e.layout.sort((e,t)=>10*(t.rank-e.rank)+e.file-t.file);let n=[],i="",a=1,s=8,r=0,o=t[0];for(;s>=1;)for(o&&s===o.rank||(a<=8&&(i+=8-a+1),n.push(i),i="",a=1,s--);o&&o.rank===s;)o.file>a&&(i+=o.file-a),i+=o.code,a=o.file+1,o=t[++r];const l="white"===e.player?"w":"b";let c=(e.whiteKingCastle?"K":"")+(e.whiteQueenCastle?"Q":"")+(e.blackKingCastle?"k":"")+(e.blackQueenCastle?"q":"");c=c||"-";const d=e.enPassant?ve(e.enPassant.file,e.enPassant.rank):"-";return`${n.join("/")} ${l} ${c} ${d} ${e.halfMove} ${e.fullMove}`}function be(e){if(e.enPassant){const t=Ae(e.layout,e.enPassant.file,6===e.enPassant.rank?5:4);return t&&"p"===t.code.toLowerCase()?t:void 0}}function Ee(e,t){const n=t.charCodeAt(0)-96,i=t.charCodeAt(1)-48,a=t.charCodeAt(2)-96,s=t.charCodeAt(3)-48,r=t[4],o=Ae(e.layout,n,i);if(!o)throw Error(`unable to find piece for move ${t}`);const l=e.enPassant&&"p"===o.code.toLowerCase()&&a===e.enPassant.file&&s===e.enPassant.rank?be(e):void 0,c=Ae(e.layout,a,s)||l,d=o.code===o.code.toLowerCase(),h=a>n,u=("k"===o.code||"K"===o.code)&&2===Math.abs(n-a)?d?h?"k":"q":h?"K":"Q":"",m=r?d?r.toLowerCase():r.toUpperCase():"";return{code:o.code,fromFile:n,fromRank:i,capture:!!c,toFile:a,toRank:s,promote:m,castle:u,check:""}}function xe(e){return ve(e.fromFile,e.fromRank)+ve(e.toFile,e.toRank)+e.promote}function Te(e,t){const n="white"===e,i=t.match(ce);if(i){const e=n?"K":"k",t=i[2]?n?"Q":"q":n?"K":"k";return{code:e,fromFile:void 0,fromRank:void 0,capture:!1,toFile:i[2]?3:7,toRank:n?1:8,promote:"",castle:t,check:i[3]}}const a=t.match(de);if(!a)return;const s=a[1],r=s[0];let o=void 0,l=void 0,c=void 0,d=0;"PRNBKQ".includes(r)?(o=n?r.toUpperCase():r.toLowerCase(),d=1):o=n?"P":"p",d<s.length&&(c=pe(s[d]),l=fe(s[s.length-1]),c=c>=1&&c<=8?c:void 0,l=l>=1&&l<=8?l:void 0);const[h,u]=ge(a[3]),m=a[4]?n?a[4][1].toUpperCase():a[4][1].toLowerCase():"";return a?{code:o,fromFile:c,fromRank:l,capture:"x"===a[2],toFile:h,toRank:u,promote:m,castle:"",check:a[5]}:void 0}function we(e){if(e){const i="P"===e.code.toUpperCase()||e.castle?"":e.code.toUpperCase(),a=e.fromFile?(n=e.fromFile,String.fromCharCode(n+96)):"",s=e.fromRank?(t=e.fromRank,String.fromCharCode(t+48)):"",r=e.castle?"":ve(e.toFile,e.toRank),o=e.promote?"="+e.promote.toUpperCase():"",l=e.capture?"x":"";return e.castle?("K"===e.castle.toUpperCase()?"O-O":"O-O-O")+e.check:i+a+s+l+r+o+e.check}var t,n}function Ae(e,t,n){return e.find(e=>e.file===t&&e.rank===n)}function Se(e,t){return e.find(n=>{if(n.code===t.code&&function(e,t){const n=e.file,i=e.rank,a=t.toFile,s=t.toRank;if(n===a&&i===s)return!1;const r=e.code===e.code.toLowerCase();switch(e.code){case"p":case"P":return n!==a||t.capture?!(!t.capture||n-1!==a&&n+1!==a)&&s===i+(r?-1:1):r&&7===i?6===s||5===s:r||2!==i?s===i+(r?-1:1):3===s||4===s;case"r":case"R":return n===a||i===s;case"n":case"N":{const e=Math.abs(n-a),t=Math.abs(i-s);return 2===e&&1===t||1===e&&2===t}case"b":case"B":return Math.abs(n-a)===Math.abs(i-s);case"q":case"Q":return Math.abs(n-a)===Math.abs(i-s)||n===a||i===s;case"k":case"K":return Math.abs(n-a)<=1&&Math.abs(i-s)<=1||!t.capture&&5===n&&i===(r?8:1)&&(3===a||7===a)&&i===s}}(n,t))return t.fromFile||t.fromRank?!(t.fromFile&&n.file!==t.fromFile||t.fromRank&&n.rank!==t.fromRank):!function(e,t,n){if("N"!==t.code.toUpperCase()){const i=Math.sign(n.toFile-t.file),a=Math.sign(n.toRank-t.rank);let s=t.file+i,r=t.rank+a;for(;s!==n.toFile||r!==n.toRank;){if(Ae(e,s,r))return!0;s+=i,r+=a}}return!n.capture&&!!Ae(e,n.toFile,n.toRank)}(e,n,t)})}function Re(e,t){const n=[],i=Se(e.layout,t);if(!i)throw Error("unable to find piece for move");const a="P"===i.code||"p"===i.code,s=i.code===i.code.toLowerCase();if(t.castle){const a="K"===t.castle.toUpperCase(),r=Ae(e.layout,a?8:1,s?8:1);if(!r)throw Error("unable to find rook to castle");n.push({type:"castle",king:i,rook:r,kingside:a}),i.file=a?7:3,r.file=a?6:4,e.enPassant=void 0}else{if(n.push({type:"move",piece:i,fromFile:i.file,fromRank:i.rank,toFile:t.toFile,toRank:t.toRank}),t.capture){const i=Ae(e.layout,t.toFile,t.toRank)||a&&be(e);if(!i)throw Error("unable to find piece to capture");n.push({type:"capture",capturedPiece:i,capturedIndex:e.capturedPieces.length}),e.capturedPieces.push(i),e.layout.splice(e.layout.indexOf(i),1)}if(a&&2==Math.abs(i.rank-t.toRank)?e.enPassant={file:i.file,rank:(i.rank+t.toRank)/2}:e.enPassant=void 0,i.file=t.toFile,i.rank=t.toRank,t.promote){const a={code:t.promote,file:t.toFile,rank:t.toRank};n.push({type:"promote",piece:i,newPiece:a,file:t.toFile,rank:t.toRank,capturedIndex:e.capturedPieces.length}),e.layout.splice(e.layout.indexOf(i),1),e.capturedPieces.push(i),e.layout.push(a)}}return a||t.capture?e.halfMove=0:e.halfMove++,s?(e.blackKingCastle=e.blackKingCastle&&"k"!==i.code&&("r"!==i.code||8!==i.file),e.blackQueenCastle=e.blackKingCastle&&"k"!==i.code&&("r"!==i.code||1!==i.file),e.fullMove++):(e.whiteKingCastle=e.whiteKingCastle&&"K"!==i.code&&("R"!==i.code||8!==i.file),e.whiteQueenCastle=e.whiteKingCastle&&"K"!==i.code&&("R"!==i.code||1!==i.file)),n}function Ce(e,t,n,i=0,a=0,s=0){return e[s]=t[i]-n[a],e[s+1]=t[i+1]-n[a+1],e[s+2]=t[i+2]-n[a+2],e}function ke(e,t,n=0,i=0){const a=t[n],s=t[n+1],r=t[n+2],o=Math.hypot(a,s,r)||1;return e[i]=a/o,e[i+1]=s/o,e[i+2]=r/o,e}function Me(e,t,n=0,i=0){return e[n]*t[i]+e[n+1]*t[i+1]+e[n+2]*t[i+2]}function Ie(e,t,n,i,a=0,s=0,r=0){return e[r]=t[a]+n[s]*i,e[r+1]=t[a+1]+n[s+1]*i,e[r+2]=t[a+2]+n[s+2]*i,e}function Oe(e,t,n=1e-5,i=0,a=0){return Math.abs(e[i]-t[a])<n&&Math.abs(e[i+1]-t[a+1])<n&&Math.abs(e[i+2]-t[a+2])<n}function Pe(e,t,n,i=0,a=0,s=0){const r=t[i],o=t[i+1],l=t[i+2],c=n[a],d=n[a+1],h=n[a+2];return e[s]=o*h-l*d,e[s+1]=l*c-r*h,e[s+2]=r*d-o*c,e}const Fe=function(){let e=new Float32Array(3),t=new Float32Array(3),n=new Float32Array(3);return function(i,a,s,r,o=0,l=0,c=0,d=0){return Ce(e,r,s,c,l),Ce(t,a,s,o,l),ke(i,Pe(n,e,t),0,d)}}();function De(e,t,n,i=0){const a=n.length;let s=0,r=0,o=0;for(let e=0;e<n.length;e++){const i=n[e];s+=t[i]/a,r+=t[i+1]/a,o+=t[i+2]/a}return function(e,t=0,n=0,i=0,a=0){return e[a]=t,e[a+1]=n,e[a+2]=i,e}(e,s,r,o,i)}const Le=function(){const e=new Float32Array(3),t=new Float32Array(3),n=new Float32Array(3);return function(i,a,s,r,o=1e-5,l=0,c=0,d=0,h=0){return Ce(e,a,i,c,l),Ce(t,s,i,d,l),Ce(n,r,i,h,l),Math.abs(Me(n,Pe(e,e,t)))<o}}();function He(e,t,n,i=0,a=0){return e[a]=t[i]*n,e[a+1]=t[i+1]*n,e[a+2]=t[i+2]*n,e}function je(e,t,n,i=0,a=0){const s=t[i],r=t[i+1],o=t[i+2];return e[a]=n[0]*s+n[4]*r+n[8]*o+n[12],e[a+1]=n[1]*s+n[5]*r+n[9]*o+n[13],e[a+2]=n[2]*s+n[6]*r+n[10]*o+n[14],e}function _e(e,t=3){const n=e.length;if(n<12)return;const i=[],a=new Float32Array(3),s=new Float32Array(3),r=1e-5;function o(t,n,i){const r=new Float32Array(3);return Fe(r,e,e,e,t,n,i),Me(r,Ce(s,e,a,t))>0?{ai:t,bi:n,ci:i,normal:r}:{ai:t,bi:i,ci:n,normal:He(r,r,-1)}}function l(t){let n=[];for(let a=0;a<i.length;a++){ke(s,Ce(s,e,e,t,i[a].ai)),Me(s,i[a].normal)>r&&n.push(a)}return n}function c(e){for(let t=0;t<e.length;){let n=!1;for(let i=t+1;i<e.length;i++)if(e[t][0]===e[i][0]&&e[t][1]===e[i][1]||e[t][1]===e[i][0]&&e[t][0]===e[i][1]){e.splice(i,1),e.splice(t,1),n=!0;break}n||t++}return e}let d=0,h=0;for(let s=0,r=0,l=0,c=t;c<n;c+=t)if(0===r)Oe(e,e,1e-5,c,s)||(r=c);else if(0===l)Oe(e,e,1e-5,c,r)||(l=c);else if(0===h&&!Oe(e,e,1e-5,c,l)&&!Le(e,e,e,e,1e-5,s,r,l,c)){De(a,e,[s,r,l,h=c]),i.push(o(s,r,l)),i.push(o(s,r,h)),i.push(o(s,l,h)),i.push(o(r,l,h)),d=4;break}if(0!==d){for(let s=3*t;s<n;s+=t){if(s===h)continue;const t=l(s),n=t.flatMap(e=>{const t=i[e];return[[t.ai,t.bi],[t.ai,t.ci],[t.bi,t.ci]]});t.length>1&&c(n),Ie(a,e,a,d,s,0),He(a,a,1/(d+1));for(let e=t.length-1;e>=0;--e)i.splice(t[e],1);for(let e of n)i.push(o(e[0],e[1],s));d++}return i.flatMap(e=>[e.ai,e.bi,e.ci])}}const ze=function(){const e=new THREE.Quaternion,t=new THREE.Vector3,n=new THREE.Vector3;return function(i,a,s=new THREE.Matrix4){return We(i,a,e),qe(i,a,t),function(e,t,n=new THREE.Vector3){const i=e.geometry.getAttribute("instanceScale");n.x=i.getX(t),n.y=i.getY(t),n.z=i.getZ(t)}(i,a,n),s.compose(t,e,n),s.premultiply(i.matrixWorld),s}}(),Ne=function(){const e=new THREE.Matrix4;return function(t,n,i,a=new THREE.Matrix4){return ze(n,i,e),a.getInverse(t.matrixWorld).multiply(e),a}}(),Be=function(){const e=new THREE.Matrix4,t=new THREE.Matrix4,n=new THREE.Quaternion,i=new THREE.Vector3,a=new THREE.Vector3;return function(s,r,o,l){e.getInverse(r.parent.matrixWorld),t.multiplyMatrices(s.matrixWorld,l),t.premultiply(e),t.decompose(i,n,a),Ue(r,o,i),Ge(r,o,n)}}();function Ve(e,t){const n=e?e.getObjectByProperty("isMesh",!0):void 0;if(!n||!n.geometry||!n.material)return;function i(e){return function(t){e&&e(t);let n=t.vertexShader,i=t.fragmentShader;n=(n=(n=(n=n.replace("void main()","\n      attribute vec3 instancePosition;\n      attribute vec4 instanceQuaternion;\n      attribute vec4 instanceColor;\n      attribute float instanceScale;\n  \n      varying vec4 vInstanceColor;\n  \n      vec3 applyQuaternion( const vec3 v, const vec4 q ) \n      {\n        return v + 2. * cross( q.xyz, cross( q.xyz, v ) + q.w * v );\n      }\n  \n      void main()")).replace("#include <color_vertex>","\n      #include <color_vertex>\n      vInstanceColor = instanceColor;")).replace("#include <begin_vertex>","\n      vec3 transformed = applyQuaternion( position*instanceScale, instanceQuaternion ) + instancePosition;")).replace("#include <defaultnormal_vertex>","\n      vec3 transformedNormal = normalMatrix * applyQuaternion( objectNormal/instanceScale, -instanceQuaternion );\n      \n      #ifdef FLIP_SIDED\n        transformedNormal = - transformedNormal;\n      #endif\n  \n      #ifdef USE_TANGENT\n        vec3 transformedTangent = normalMatrix * applyQuaternion( objectTangent/instanceScale, -instanceQuaternion );\n        #ifdef FLIP_SIDED\n          transformedTangent = - transformedTangent;\n        #endif\n      #endif"),i=(i=i.replace("#include <color_pars_fragment>","\n      #include <color_pars_fragment>\n      varying vec4 vInstanceColor;")).replace("#include <color_fragment>","\n      #include <color_fragment>\n      diffuseColor *= vInstanceColor;"),t.vertexShader=n,t.fragmentShader=i}}const a=new Float32Array(4*t),s=new Float32Array(3*t),r=new Float32Array(3*t),o=new Float32Array(3*t).fill(1);for(let e=0;e<t;e++)a[4*e+3]=1;const l=new THREE.InstancedBufferAttribute(s,3),c=new THREE.InstancedBufferAttribute(a,4),d=new THREE.InstancedBufferAttribute(r,3),h=new THREE.InstancedBufferAttribute(o,3),u=(new THREE.InstancedBufferGeometry).copy(n.geometry);u.maxInstancedCount=t,u.setAttribute("instancePosition",l),u.setAttribute("instanceQuaternion",c),u.setAttribute("instanceScale",d),u.setAttribute("instanceColor",h);let m=n.material;Array.isArray(n.material)?(m=n.material.map(e=>e.clone())).forEach(e=>e.onBeforeCompile=i(e.onBeforeCompile)):(m=n.material.clone()).onBeforeCompile=i(m.onBeforeCompile);const p=new THREE.Mesh(u,m);return p.frustumCulled=!1,p}function Ue(e,t,n,i,a){const s=e.geometry.getAttribute("instancePosition");"object"==typeof n?s.setXYZ(t,n.x,n.y,n.z):s.setXYZ(t,n,i,a),s.needsUpdate=!0}function qe(e,t,n=new THREE.Vector3){const i=e.geometry.getAttribute("instancePosition");return n.x=i.getX(t),n.y=i.getY(t),n.z=i.getZ(t),n}function Ge(e,t,n,i,a,s){const r=e.geometry.getAttribute("instanceQuaternion");"object"==typeof n?r.setXYZW(t,n.x,n.y,n.z,n.w):r.setXYZW(t,n,i,a,s),r.needsUpdate=!0}function We(e,t,n=new THREE.Quaternion){const i=e.geometry.getAttribute("instanceQuaternion");return n.x=i.getX(t),n.y=i.getY(t),n.z=i.getZ(t),n.w=i.getW(t),n}function Qe(e,t,n,i,a){const s=e.geometry.getAttribute("instanceColor");"object"==typeof n?s.setXYZ(t,n.r,n.g,n.b):s.setXYZ(t,n,i,a),s.needsUpdate=!0}function $e(e,t,n,i,a){const s=e.geometry.getAttribute("instanceScale");"object"==typeof n?s.setXYZ(t,n.x,n.y,n.z):s.setXYZ(t,n,i,a),s.needsUpdate=!0}function Ye(e,t,n){return 0===n?e:e+(t-e)*n}function Xe(e,t,n){let i=Object.assign({},e);if(0===n)return i;for(let a in t)i[a]=void 0!==e[a]?Ye(e[a],t[a],n):t[a];return i}function Ze(e,t,n=Ke){const i=e.length;if(t<=0||i<=1)return[0,0];if(t>=1)return[i-2,1];const a=t*(i-1),s=~~a;return[s,n(a-s)]}function Ke(e){return e}const Je={In:function(e){return e*e},Out:function(e){return e*(2-e)},InOut:function(e){return(e*=2)<1?.5*e*e:-.5*(--e*(e-2)-1)}},et={In:function(e){return e*e*e},Out:function(e){return--e*e*e+1},InOut:function(e){return(e*=2)<1?.5*e*e*e:.5*((e-=2)*e*e+2)}},tt={In:function(e){return e*e*e*e},Out:function(e){return 1- --e*e*e*e},InOut:function(e){return(e*=2)<1?.5*e*e*e*e:-.5*((e-=2)*e*e*e-2)}},nt={In:function(e){return e*e*e*e*e},Out:function(e){return--e*e*e*e*e+1},InOut:function(e){return(e*=2)<1?.5*e*e*e*e*e:.5*((e-=2)*e*e*e*e+2)}},it={In:function(e){return 1-Math.cos(e*Math.PI/2)},Out:function(e){return Math.sin(e*Math.PI/2)},InOut:function(e){return.5*(1-Math.cos(Math.PI*e))}},at={In:function(e){return 0===e?0:Math.pow(1024,e-1)},Out:function(e){return 1===e?1:1-Math.pow(2,-10*e)},InOut:function(e){return 0===e?0:1===e?1:(e*=2)<1?.5*Math.pow(1024,e-1):.5*(2-Math.pow(2,-10*(e-1)))}},st={In:function(e){return 1-Math.sqrt(1-e*e)},Out:function(e){return Math.sqrt(1- --e*e)},InOut:function(e){return(e*=2)<1?-.5*(Math.sqrt(1-e*e)-1):.5*(Math.sqrt(1-(e-=2)*e)+1)}},rt={In:function(e){return 0===e?0:1===e?1:-Math.pow(2,10*(e-1))*Math.sin(5*(e-1.1)*Math.PI)},Out:function(e){return 0===e?0:1===e?1:Math.pow(2,-10*e)*Math.sin(5*(e-.1)*Math.PI)+1},InOut:function(e){return 0===e?0:1===e?1:(e*=2)<1?-.5*Math.pow(2,10*(e-1))*Math.sin(5*(e-1.1)*Math.PI):.5*Math.pow(2,-10*(e-1))*Math.sin(5*(e-1.1)*Math.PI)+1}},ot={In:function(e){var t=1.70158;return e*e*((t+1)*e-t)},Out:function(e){var t=1.70158;return--e*e*((t+1)*e+t)+1},InOut:function(e){var t=2.5949095;return(e*=2)<1?e*e*((t+1)*e-t)*.5:.5*((e-=2)*e*((t+1)*e+t)+2)}},lt={In:function(e){return 1-lt.Out(1-e)},Out:function(e){return e<1/2.75?7.5625*e*e:e<2/2.75?7.5625*(e-=1.5/2.75)*e+.75:e<2.5/2.75?7.5625*(e-=2.25/2.75)*e+.9375:7.5625*(e-=2.625/2.75)*e+.984375},InOut:function(e){return e<.5?.5*lt.In(2*e):.5*lt.Out(2*e-1)+.5}},ct={linear:Ke,ease:et.InOut,"ease-in":et.In,"ease-out":et.Out,"ease-in-out":et.InOut,"ease-cubic":et.In,"ease-in-cubic":et.In,"ease-out-cubic":et.Out,"ease-in-out-cubic":et.InOut,"ease-quad":Je.InOut,"ease-in-quad":Je.In,"ease-out-quad":Je.Out,"ease-in-out-quad":Je.InOut,"ease-quart":tt.InOut,"ease-in-quart":tt.In,"ease-out-quart":tt.Out,"ease-in-out-quart":tt.InOut,"ease-quint":nt.InOut,"ease-in-quint":nt.In,"ease-out-quint":nt.Out,"ease-in-out-quint":nt.InOut,"ease-sine":it.InOut,"ease-in-sine":it.In,"ease-out-sine":it.Out,"ease-in-out-sine":it.InOut,"ease-expo":at.InOut,"ease-in-expo":at.In,"ease-out-expo":at.Out,"ease-in-out-expo":at.InOut,"ease-circ":st.InOut,"ease-in-circ":st.In,"ease-out-circ":st.Out,"ease-in-out-circ":st.InOut,"ease-elastic":rt.InOut,"ease-in-elastic":rt.In,"ease-out-elastic":rt.Out,"ease-in-out-elastic":rt.InOut,"ease-back":ot.InOut,"ease-in-back":ot.In,"ease-out-back":ot.Out,"ease-in-out-back":ot.InOut,"ease-bounce":lt.InOut,"ease-in-bounce":lt.In,"ease-out-bounce":lt.Out,"ease-in-out-bounce":lt.InOut},dt=function(){const e={x:0,y:0,z:0};return function(t,n,i,a,s,r){for(let p=0;p<8;p++)e.x=p%2?a.x:i.x,e.y=(p>>>1)%2?a.y:i.y,e.z=(p>>>2)%2?a.z:i.z,d(e,s,e),h(e,r,e),0===p?(o(t,e),o(n,e)):(u=e,m=t,(c=t).x=Math.min(u.x,m.x),c.y=Math.min(u.y,m.y),c.z=Math.min(u.z,m.z),l(n,e,n));var c,u,m}}(),ht=function(){let e={x:0,y:0,z:0},t={x:0,y:0,z:0};function n(n,i,a,s,r,o){return dt(e,t,n,i,a,o),Math.max(e.x-r.x,e.y-r.y,e.z-r.z,s.x-t.x,s.y-t.y,s.z-t.z)}return function(e,t,i,a,s,r){const o=n(e,t,i,a,s,r),l=n(a,s,r,e,t,i);return Math.max(o,l)}}();function ut(e){let t=e.el;for(;t&&t.components&&!t.components.networked;)t=t.parentNode;return t&&t.components&&t.components.networked&&t.components.networked.data}function mt(e){if("object"==typeof NAF&&ut(e)){const t=NAF.utils.getNetworkOwner(e.el);return!t||t===NAF.clientId}return!0}function pt(){return"object"==typeof NAF?NAF.clientId:void 0}function ft(e){return{registerNetworking(e,t){if("object"==typeof NAF){const n=e.el;console.assert(!this.networkCallbacks.has(e),"component already registered"),this.networkCallbacks.set(e,t),NAF.clientId&&NAF.utils.getNetworkId(n)&&this.requestSync(e),"function"==typeof t.onOwnershipGained&&n.addEventListener("ownership-gained",t.onOwnershipGained),"function"==typeof t.onOwnershipLost&&n.addEventListener("ownership-lost",t.onOwnershipLost),"function"==typeof t.onOwnershipChanged&&n.addEventListener("ownership-changed",t.onOwnershipChanged)}},unregisterNetworking(e){if("object"==typeof NAF){console.assert(this.networkCallbacks.has(e),"component not registered");const t=e.el,n=this.networkCallbacks.get(e);"function"==typeof n.onOwnershipGained&&t.removeEventListener("onOwnershipGained",n.onOwnershipGained),"function"==typeof n.onOwnershipLost&&t.removeEventListener("onOwnershipLost",n.onOwnershipLost),"function"==typeof n.onOwnershipChanged&&t.removeEventListener("onOwnershipChanged",n.onOwnershipChanged),this.networkCallbacks.delete(e)}},setupNetwork(){"object"==typeof NAF&&(this.networkCache={},this.networkCallbacks=new Map,this.networkPacket={},NAF.connection.subscribeToDataChannel(e,(t,n,i,a)=>{const s=NAF.entities.getEntity(i.networkId),r=s?s.components[e]:void 0;if("NETRequestSync"===i.data){if(r&&NAF.clientId===NAF.utils.getNetworkOwner(s)){const e=this.networkCallbacks.get(r);"function"==typeof e.requestSync&&e.requestSync(t)}}else if(r){const e=this.networkCallbacks.get(r);"function"==typeof e.receiveNetworkData&&e.receiveNetworkData(i.data,t)}else i.senderId=t,this.networkCache[i.networkId]=i}),this.onEntityCreated=this.onEntityCreated.bind(this),this.onClientConnected=this.onClientConnected.bind(this),this.onClientDisconnected=this.onClientDisconnected.bind(this),this.onConnected=this.onConnected.bind(this),NAF.clientId||document.body.addEventListener("connected",this.onConnected),document.body.addEventListener("entityCreated",this.onEntityCreated),document.body.addEventListener("clientConnected",this.onClientConnected),document.body.addEventListener("clientDisconnected",this.onClientDisconnected))},shutdownNetwork(){"object"==typeof NAF&&(NAF.connection.unsubscribeToDataChannel(e),document.body.removeEventListener("connected",this.onConnected),document.body.removeEventListener("entityCreated",this.onEntityCreated),document.body.removeEventListener("clientConnected",this.onClientConnected),document.body.removeEventListener("clientDisconnected",this.onClientDisconnected),console.assert(0===this.networkCallbacks.length,"missing calls to unregisterNetworking(). Some components are still registered"),delete this.networkCallbacks,delete this.networkCache)},broadcastNetworkData(e,t){this.sendNetworkData(e,t,void 0)},sendNetworkData(t,n,i){if("object"==typeof NAF){const a=NAF.utils.getNetworkId(t.el);a&&(this.networkPacket.networkId=a,this.networkPacket.data=n,i?NAF.connection.sendDataGuaranteed(i,e,this.networkPacket):NAF.connection.broadcastData(e,this.networkPacket))}},onConnected(e){this.networkCallbacks.forEach((e,t)=>{this.requestSync(t)}),document.body.removeEventListener("connected",this.onConnected)},onEntityCreated(t){const n=t.detail.el,i=n.components[e],a=NAF.utils.getNetworkId(n),s=a?this.networkCache[a]:void 0;if(i&&s){const e=this.networkCallbacks.get(i);"function"==typeof e.receiveNetworkData&&e.receiveNetworkData(s.data,s.senderId),delete this.networkCache[a]}i&&NAF.clientId&&this.requestSync(i)},onClientConnected(e){e.detail.clientId;this.networkCallbacks.forEach(t=>{"function"==typeof t.onClientConnected&&t.onClientConnected(e)})},onClientDisconnected(e){e.detail.clientId;this.networkCallbacks.forEach(t=>{"function"==typeof t.onClientDisconnected&&t.onClientDisconnected(e)})},requestSync(e){this.broadcastNetworkData(e,"NETRequestSync")}}}function gt(e,t,n,i,a,s){return ht(e,t,n,i,a,s)<0}const vt=function(){let e={x:0,y:0,z:0},t={x:0,y:0,z:0};return function(n,i,a,s,r,o){return dt(e,t,n,i,a,o),e.x>s.x&&e.y>s.y&&e.z>s.z&&t.x<r.x&&t.y<r.y&&t.z<r.z}}();function yt(e,t){for(let n of["map","alphaMap","aoMap","bumpMap","displacementMap","emissiveMap","envMap","lighMap","metalnessMap","normalMap","roughnessMap"])e[n]&&e[n].image===t&&(e[n].needsUpdate=!0)}function bt(e,t){e.uniforms&&e.uniforms.map&&e.uniforms.map.value&&"object"==typeof e.uniforms.map.value&&e.uniforms.map.value.image===t&&(e.uniforms.map.value.needsUpdate=!0)}function Et(e,t){e.traverse(e=>{if(e.material)if(Array.isArray(e.material))for(let n of e.material)yt(n,t),bt(n,t);else yt(e.material,t),bt(e.material,t)})}const xt=function(){let e=new THREE.Vector3,t=new THREE.Quaternion,n=new THREE.Vector3,i=new THREE.Box3;return function(a,s){e.copy(s.position),t.copy(s.quaternion),n.copy(s.scale);const r=s.parent;return s.parent=null,s.position.set(0,0,0),s.quaternion.set(0,0,0,1),s.scale.set(1,1,1),s.updateMatrixWorld(!0),i.setFromObject(s),s.parent=r,s.position.copy(e),s.quaternion.copy(t),s.scale.copy(n),s.updateMatrixWorld(!0),a.min.x=i.min.x,a.min.y=i.min.y,a.min.z=i.min.z,a.max.x=i.max.x,a.max.y=i.max.y,a.max.z=i.max.z,a}}();function Tt(e,t){if(e.boundingBox=e.boundingBox||new THREE.Box3,e.boundingSphere=e.boundingSphere||new THREE.Sphere,e.boundingBoxDebug&&(e.remove(e.boundingBoxDebug),e.boundingBoxDebug=void 0),xt(e.boundingBox,e),!e.boundingBox.isEmpty()&&(e.boundingBox.getBoundingSphere(e.boundingSphere),t)){const n=new THREE.Vector3;e.boundingBox.getSize(n);const i=new THREE.Group,a=new THREE.Box3Helper(e.boundingBox,t),s=new THREE.AxesHelper(Math.min(n.x,n.y,n.z));i.add(s),i.add(a),i.name="orientedBoundingDebug",e.add(i),e.boundingBoxDebug=i}}var wt=Math.PI/180,At=48,St=57,Rt=44,Ct=32,kt=46,Mt=45;function It(e){'"'!==e[0]&&"'"!==e[0]||(e=e.substring(1,e.length-1));var t,n,i,a,s=new THREE.Shape,r=1,o=e.length,l=0,c=0,d=0,h=0,u=null,m=null,p=0,f=0,g=0,v=0,y=0,b=0,E=0,x=0,T=0;function w(){for(var t,n,i,a=!1;r<o&&((n=e.charCodeAt(r))===Rt||n===Ct);)r++;for(t=n===Mt?r++:r;r<o;)if(n=e.charCodeAt(r),At<=n&&n<=St)r++;else{if(n!==kt)return i=e.substring(t,r),a?parseFloat(i):parseInt(i);r++,a=!0}return i=e.substring(t),a?parseFloat(i):parseInt(i)}function A(){for(var t;r<o&&((t=e.charCodeAt(r))===Rt||t===Ct);)r++;return(t=e.charCodeAt(r))===Mt||At<=t&&t<=St}for(t=e[0];r<=o;){switch(a=!0,t){case"M":l=w(),c=w(),s.moveTo(l,c),t="L",u=l,m=c;break;case"m":l+=w(),c+=w(),s.moveTo(l,c),t="l",u=l,m=c;break;case"Z":case"z":a=!1,l===u&&c===m||s.lineTo(u,m);break;case"L":case"H":case"V":d="V"===t?l:w(),h="H"===t?c:w(),s.lineTo(d,h),l=d,c=h;break;case"l":case"h":case"v":d="v"===t?l:l+w(),h="h"===t?c:c+w(),s.lineTo(d,h),l=d,c=h;break;case"C":p=w(),g=w();case"S":"S"===t&&(p=2*l-f,g=2*c-v),f=w(),v=w(),d=w(),h=w(),s.bezierCurveTo(p,g,f,v,d,h),l=d,c=h;break;case"c":p=l+w(),g=c+w();case"s":"s"===t&&(p=2*l-f,g=2*c-v),f=l+w(),v=c+w(),d=l+w(),h=c+w(),s.bezierCurveTo(p,g,f,v,d,h),l=d,c=h;break;case"Q":p=w(),g=w();case"T":"T"===t&&(p=2*l-p,g=2*c-g),d=w(),h=w(),s.quadraticCurveTo(p,g,d,h),l=d,c=h;break;case"q":p=l+w(),g=c+w();case"t":"t"===t&&(p=2*l-p,g=2*c-g),d=l+w(),h=c+w(),s.quadraticCurveTo(p,g,d,h),l=d,c=h;break;case"A":y=w(),b=w(),E=w()*wt,x=w(),T=w(),d=w(),h=w(),y!==b&&console.warn("Forcing elliptical arc to be a circular one :(",y,b),p=Math.cos(E)*(l-d)/2+Math.sin(E)*(c-h)/2,g=-Math.sin(E)*(l-d)/2+Math.cos(E)*(c-h)/2;var S=Math.sqrt((y*y*b*b-y*y*g*g-b*b*p*p)/(y*y*g*g+b*b*p*p));x===T&&(S=-S),f=S*y*g/b,v=S*-b*p/y,n=Math.cos(E)*f-Math.sin(E)*v+(l+d)/2,i=Math.sin(E)*f+Math.cos(E)*v+(c+h)/2;var R=new THREE.Vector2(1,0),C=new THREE.Vector2((p-f)/y,(g-v)/b),k=Math.acos(R.dot(C)/R.length()/C.length());R.x*C.y-R.y*C.x<0&&(k=-k),R.x=(-p-f)/y,R.y=(-g-v)/b;var M=Math.acos(C.dot(R)/C.length()/R.length());C.x*R.y-C.y*R.x<0&&(M=-M),!T&&M>0&&(M-=2*Math.PI),T&&M<0&&(M+=2*Math.PI),s.absarc(n,i,y,k,k+M,T),l=d,c=h;break;default:throw new Error("weird path command: "+t)}a&&A()||(t=e[r++])}return s}const Ot=function(){let e=new THREE.Vector3,t=new THREE.Vector3;return function(n,i){let a,s,r=9*Math.floor(Math.random()*n.length/9);e.fromArray(n,r),t.fromArray(n,r+3),i.fromArray(n,r+6);do{a=Math.random(),s=Math.random()}while(a+s>1);t.sub(e).multiplyScalar(a),i.sub(e).multiplyScalar(s).add(t).add(e)}}(),Pt=function(){let e=new THREE.Vector3,t=new THREE.Vector3;return function(n,i){const a=9*Math.floor(Math.random()*n.length/9),s=3*Math.random();s>2?(e.fromArray(n,a+6),t.fromArray(n,a)):s>1?(e.fromArray(n,a+3),t.fromArray(n,a+6)):(e.fromArray(n,a),t.fromArray(n,a+3)),i.copy(t).sub(e).multiplyScalar(s-Math.floor(s)).add(e)}}();function Ft(e,t,n=new THREE.Matrix4){return n.getInverse(e.matrixWorld).multiply(t.matrixWorld),n}const Dt=function(){const e=new THREE.Matrix4,t=new THREE.Matrix4;return function(n,i,a){e.getInverse(i.parent.matrixWorld),t.multiplyMatrices(n.matrixWorld,a),t.premultiply(e),t.decompose(i.position,i.quaternion,i.scale)}}();AFRAME.registerComponent("chalk",{dependencies:["raycaster"],schema:{color:{type:"color"},length:{default:.1},radius:{default:.02},debug:{default:!1}},init(){this.boards=[],this.onRaycasterIntersection=this.onRaycasterIntersection.bind(this),this.onRaycasterIntersectionCleared=this.onRaycasterIntersectionCleared.bind(this);const e=this.data,t=new THREE.CylinderBufferGeometry(e.radius,e.radius,e.length,16);t.applyMatrix((new THREE.Matrix4).set(1,0,0,0,0,0,1,0,0,-1,0,0,0,0,0,1));const n=new THREE.Mesh(t,new THREE.MeshBasicMaterial({color:e.color}));this.el.setObject3D("mesh",n)},update(e){const t=this.data;if(t.color!==e.color){const e=this.el.getObject3D("mesh");e&&e.material&&!Array.isArray(e.material)&&e.material.color.setStyle(t.color)}},play(){this.el.addEventListener("raycaster-intersection",this.onRaycasterIntersection),this.el.addEventListener("raycaster-intersection-cleared",this.onRaycasterIntersectionCleared)},pause(){this.el.removeEventListener("raycaster-intersection",this.onRaycasterIntersection),this.el.removeEventListener("raycaster-intersection-cleared",this.onRaycasterIntersectionCleared)},onRaycasterIntersection(e){this.data.debug&&console.log("contact"),0===this.boards.length&&this.startTick(),this.boards.push(...e.detail.els.map(e=>({el:e,radius:-1,ctx:void 0,texture:void 0,prevIntersection:void 0})))},onRaycasterIntersectionCleared(e){this.data.debug&&console.log("cleared"),this.boards.length=0},tick(){if(0===this.boards.length)return void this.stopTick();const e=this.el.components.raycaster;for(let t of this.boards)this.tryDrawOnBoard(e,t)},startTick(){this.el.sceneEl.addBehavior(this)},stopTick(){this.el.sceneEl.removeBehavior(this)},tryDrawOnBoard:function(){const e=new THREE.Vector2;return function(t,n){const i=this.data,a=t.getIntersection(n.el);if(!a)return!1;if(!n.ctx){let e,t;a.object&&a.object.isMesh&&(t=a.object.material.map)&&t.image&&t.image instanceof HTMLCanvasElement&&(e=t.image),n.ctx=e?e.getContext("2d"):void 0,n.texture=t}const s=n.ctx,r=n.texture;if(n.radius<0&&s)if(n.prevIntersection){const e=a.point.distanceTo(n.prevIntersection.point);if(e>.001){const t=i.radius/e,r=t*(a.uv.x-n.prevIntersection.uv.x)*s.canvas.width,o=t*(a.uv.y-n.prevIntersection.uv.y)*s.canvas.height;n.radius=Math.hypot(r,o),n.prevIntersection=void 0}}else n.prevIntersection=a;const o=n.radius;if(s&&r&&o>0){e.set(a.uv.x,a.uv.y),r.transformUv(e);const t=s.canvas,o=e.x*t.width,l=e.y*t.height,c=n.radius;s.beginPath(),s.fillStyle=i.color,s.arc(o,l,c,0,2*Math.PI),s.fill(),Et(this.el.sceneEl.object3D,t)}return!0}}()});const Lt="rnbqkpRNBQKP".split(""),Ht=/url\((.*)\)/,jt=e=>e.toLowerCase();AFRAME.registerSystem("chess",{...ft("chess"),init(){this.setupNetwork()},remove(){this.shutdownNetwork()}}),AFRAME.registerComponent("chess",{schema:{model:{default:"https://cdn.jsdelivr.net/gh/harlyq/aframe-harlyq-components@master/examples/assets/chess_set/chess_set.glb"},meshes:{default:"rook,knight',bishop',queen,king,pawn,rook,knight,bishop,queen,king,pawn"},boardMesh:{default:"board"},blackColor:{type:"color",default:"#444"},whiteColor:{type:"color",default:"#eee"},highlightColor:{type:"color",default:"#ff0"},fen:{default:"rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1"},pgn:{default:""},debug:{default:!1},boardMoveSpeed:{default:4},replayTurnDuration:{default:.5},mode:{oneOf:["freestyle","replay","static","game"],default:"freestyle",parse:jt},aiDuration:{default:1},whitePlayer:{oneOf:["human","ai"],default:"ai",parse:jt},blackPlayer:{oneOf:["human","ai"],default:"ai",parse:jt},maxCountPerPiece:{default:8},aiWorker:{default:"https://cdn.jsdelivr.net/gh/harlyq/aframe-harlyq-components@master/examples/garbochess.js"}},init(){this.onObject3dSet=this.onObject3dSet.bind(this),this.onHoverStart=this.onHoverStart.bind(this),this.onHoverEnd=this.onHoverEnd.bind(this),this.onGrabStart=this.onGrabStart.bind(this),this.onGrabEnd=this.onGrabEnd.bind(this),this.onReset=this.onReset.bind(this),this.el.addEventListener("object3dset",this.onObject3dSet),this.el.addEventListener("hoverstart",this.onHoverStart),this.el.addEventListener("hoverend",this.onHoverEnd),this.el.addEventListener("grabstart",this.onGrabStart),this.el.addEventListener("grabend",this.onGrabEnd),this.el.addEventListener("reset",this.onReset),this.chessMaterial=new THREE.MeshStandardMaterial,this.blackColor=new THREE.Color(.2,.2,.2),this.whiteColor=new THREE.Color(.8,.8,.8),this.highlightColor=new THREE.Color(1,1,0),this.gameBounds=new THREE.Box3,this.pgnAST=void 0,this.rotate180Quaternion=(new THREE.Quaternion).setFromAxisAngle(new THREE.Vector3(0,1,0),Math.PI),this.board={name:"",board3D:void 0,bounds:new THREE.Box3},this.garbochess=void 0,this.state={fenAST:{layout:[],capturedPieces:[],player:"white"},replayIndex:0,currentPlayer:"white",globalMode:"",playerInfo:{},actions:[],grabMap:new Map,movers:[],nextAIMove:"",nextHumanMove:"",pickingSide:"none",delay:0,localMode:"setup",pendingLocalMove:"",waitingForSetup:!1};const e=this.data;this.el.setAttribute("gltf-model",e.model),this.meshInfos=this.parseMeshes(e.meshes),this.board.name=e.boardMesh.trim(),this.pendingMode="",this.system.registerNetworking(this,{onClientDisconnected:this.onClientDisconnected.bind(this),onOwnershipGained:this.onOwnershipGained.bind(this),onOwnershipLost:this.onOwnershipLost.bind(this),receiveNetworkData:this.receiveNetworkData.bind(this),requestSync:this.requestSync.bind(this)})},remove(){this.system.unregisterNetworking(this),this.el.removeEventListener("object3dset",this.onObject3dSet),this.el.removeEventListener("hoverstart",this.onHoverStart),this.el.removeEventListener("hoverend",this.onHoverEnd),this.el.removeEventListener("grabstart",this.onGrabStart),this.el.removeEventListener("grabend",this.onGrabEnd),this.el.removeEventListener("reset",this.onReset)},update(e){const t=this.data;if(t.pgn!==e.pgn&&(this.pgnAST=this.parsePGN(t.pgn)),t.blackColor&&this.blackColor.set(t.blackColor),t.whiteColor&&this.whiteColor.set(t.whiteColor),this.highlightColor.set(t.highlightColor),mt(this)){const n=this.state;let i=!1;t.mode!==e.mode&&(n.globalMode=t.mode,i=!0),t.whitePlayer===e.whitePlayer&&t.blackPlayer===e.blackPlayer||(n.playerInfo.white={playerType:"human"!==t.whitePlayer?"ai":"human",networkClientId:void 0},n.playerInfo.black={playerType:"human"!==t.blackPlayer?"ai":"human",networkClientId:void 0},i=!0),i&&this.resetGame(n.globalMode)}},tick(e,t){const n=Math.min(.1,t/1e3),i=this.data,a=this.state;switch(a.localMode){case"freestyle":this.grabTick();break;case"replay":this.actionsTick(n,i.boardMoveSpeed),this.replayTick();break;case"game":this.actionsTick(n,i.boardMoveSpeed),"ai"===a.playerInfo[a.currentPlayer].playerType?this.aiTick():(this.grabTick(),this.humanTick());break;case"network":this.actionsTick(n,a.actions.length<4?i.boardMoveSpeed:4*i.boardMoveSpeed),0===a.actions.length&&this.grabTick()}},setCurrentPlayer(e){const t=this.state,n=this.data,i=t.playerInfo[e];t.currentPlayer=e,t.fenAST.player=e,"ai"===i.playerType?(this.setupPicking("none"),t.nextAIMove="",mt(this)&&this.garbochess.postMessage("search "+1e3*n.aiDuration)):(t.nextHumanMove="",this.setupHumanPicking(e))},nextTurn(){this.setCurrentPlayer("white"===this.state.currentPlayer?"black":"white")},parseMeshes(e){const t=e.split(",");return t.length!==Lt.length?(re(this,`missing meshes, found ${t.length}, expecting ${Lt.length}`),[]):Object.fromEntries(t.map((e,t)=>{const n="'"===(e=e.trim())[e.length-1];return[Lt[t],{name:n?e.slice(0,-1):e,rotate180:n,instancedMesh:void 0,nextIndex:0}]}))},parseFEN:e=>(function(e){const t={layout:[],player:"white",whiteKingCastle:!1,whiteQueenCastle:!1,blackKingCastle:!1,blackQueenCastle:!1,enPassant:void 0,halfMove:0,fullMove:1,capturedPieces:[]},n=e.split(" ");if(n.length<5)throw Error("malformed fen");const i=n[0].split("/");function a(e,t,n){let i=1;for(let a=0;a<n.length;a++){const s=n[a];if(le.includes(s))e.push({code:s,file:i,rank:t}),i++;else{if(Number(s)!=s)throw Error(`unknown letter "${s}" in fen rank chunk "${n}"`);i+=Number(s)}}}const s=i.length;for(let e=0;e<s;e++){const n=i[e];a(t.layout,s-e,n)}if(t.player="b"===n[1]?"black":"white",t.whiteKingCastle=n[2].includes("K"),t.whiteQueenCastle=n[2].includes("Q"),t.blackKingCastle=n[2].includes("k"),t.blackQueenCastle=n[2].includes("q"),n[3]&&"-"!==n[3]){const[e,i]=ge(n[3]);t.enPassant={file:e,rank:i}}return t.halfMove=n[4]?Number(n[4]):0,t.fullMove=n[5]?Number(n[5]):1,t})(e),parsePGN(e){if(!e)return;const t=e.match(Ht);if(!t)return this.pgnAST=function(e){let t={moves:[]};const n=e.replace(/\r\n|\n/," ");let i=0,a=!0,s=!0;for(;a&&i<n.length;){const e=n.slice(i).match(ue);e?(t[e[1]]=e[2],i+=e[0].length+e.index):a=!1}for(;s&&i<n.length;){const e=n.slice(i).match(me);if(e){let n=e[1].includes("...")?"black":"white";if(0===t.moves.length){const i=Number(e[1].slice(0,e[1].indexOf(".")));t.moveOffset=2*(i-1)+("white"===n?0:1)}t.moves.push(Te(n,e[2])),e[3]&&"white"===n&&!he.test(e[3])&&t.moves.push(Te("black",e[3])),i+=e[0].length+e.index}else s=!1}return t}(e),this.pgnAST;fetch(t[1]).then(e=>(e.ok||re(this,`file: "${t[1]}" ${e.statusText}`),e.text())).then(e=>this.parsePGN(e))},resetGame(e){console.assert("network"!==e);const t=this.state;let n=this.pgnAST&&this.pgnAST.FEN?this.pgnAST.FEN:this.data.fen;n=n||"rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1",t.fenAST=this.parseFEN(n),t.replayIndex=0,"game"===e&&this.setupGameWorker(),this.releaseAllInstances(),this.setupMode(e)},setupMode(e){if(!this.chess3D||"game"===e&&!this.garbochess)return void(this.pendingMode=e);this.data.debug&&console.log("mode",e);const t=this.state;switch(t.actions.length=0,t.grabMap.clear(),t.movers.length=0,t.nextAIMove="",t.nextHumanMove="",t.delay=0,t.localMode=e,e){case"replay":break;case"game":this.garbochess.postMessage("position "+ye(t.fenAST))}switch(this.setupBoard(t.fenAST),e){case"freestyle":this.setupPicking("all");break;case"game":case"network":this.setCurrentPlayer(t.fenAST.player)}},createChessSet(e){const t=this,n=this.data;xt(this.gameBounds,e);const i=e.getObjectByName(this.board.name);if(i){this.board.board3D=i;const e=(new THREE.Matrix4).getInverse(i.parent.matrixWorld);this.board.bounds.setFromObject(i),this.board.bounds.applyMatrix4(e)}else re(this,`unable to find board mesh '${this.board.name}'`);let a=Object.fromEntries(Lt.map(e=>[this.meshInfos[e].name,0]));for(let e of Lt){a[this.meshInfos[e].name]+=n.maxCountPerPiece}let s={};const r=new THREE.Matrix4;for(let i in this.meshInfos){const o=this.meshInfos[i],l=o.name,c=s[l];if(c)o.instancedMesh=c.instancedMesh,o.startIndex=o.nextIndex=c.nextIndex,c.nextIndex+=n.maxCountPerPiece;else{const i=e.getObjectByName(l);i?(i.visible=!1,i.material=this.chessMaterial,o.instancedMesh=Ve(i,a[l]),r.compose(o.instancedMesh.position,i.quaternion,i.scale),o.instancedMesh.geometry.applyMatrix(r),o.nextIndex=o.startIndex=0,e.add(o.instancedMesh),s[l]={instancedMesh:o.instancedMesh,nextIndex:n.maxCountPerPiece}):re(t,`unable to find mesh '${l}'`)}}},setupInstanceForPiece(e){const t=this.meshInfos[e.code],n=t?t.instancedMesh:void 0;if(n){const i=t.nextIndex++;if(t.rotate180){const e=new THREE.Quaternion;We(n,i,e),Ge(n,i,e.multiply(this.rotate180Quaternion))}$e(n,i,1,1,1),Qe(n,i,e.code===e.code.toLowerCase()?this.blackColor:this.whiteColor),e.index=i,e.instancedMesh=n}},releaseAllInstances(){for(let e of Lt){const t=this.meshInfos[e];for(let e=t.startIndex;e<t.nextIndex;e++)$e(t.instancedMesh,e,0,0,0);t.nextIndex=t.startIndex}},setupHumanPicking(e){const t=this.state.playerInfo[e];t.networkClientId&&t.networkClientId!==pt()?this.setupPicking("none"):this.setupPicking(e)},setupPicking(e){const t=this.state;if(e===t.pickingSide)return;const n=this.el.sceneEl.systems["grab-system"],i=this.el,a=t.fenAST.layout,s=e=>n.unregisterTarget(i,{obj3D:e.instancedMesh,instanceIndex:e.index});"none"!==t.pickingSide&&(t.fenAST.capturedPieces.forEach(s),a.forEach(s)),"none"!==e&&a.forEach(t=>{const a=t.code===t.code.toLowerCase();("all"===e||a&&"black"===e||!a&&"white"===e)&&(e=>n.registerTarget(i,{obj3D:e.instancedMesh,score:"closestforward",instanceIndex:e.index}))(t)}),t.pickingSide=e},setupBoard(e){if(!this.board.board3D||Lt.some(e=>!this.meshInfos[e].instancedMesh))return;const t=this.board.bounds.max.y;for(let n of e.layout){const e=this.xzFromFileRank(this.board.bounds,n.file,n.rank);n.instancedMesh||this.setupInstanceForPiece(n),Ue(n.instancedMesh,n.index,e.x,t,e.z)}if(e.capturedPieces)for(let n=0;n<e.capturedPieces.length;n++){const i=e.capturedPieces[n],a=this.fileRankFromCaptured(n),s=this.xzFromFileRank(this.board.bounds,a.file,a.rank);i.instancedMesh||this.setupInstanceForPiece(i),Ue(i.instancedMesh,i.index,s.x,t,s.z)}},xzFromFileRank(e,t,n){const i=e.max.x-e.min.x,a=e.max.z-e.min.z;return{x:e.min.x+(t-.5)*i/8,z:e.max.z-(n-.5)*a/8}},fileRankFromXZ(e,t,n){const i=e.max.x-e.min.x,a=e.max.z-e.min.z,s=Math.floor(8*(t-e.min.x)/i)+1,r=Math.floor(8*(e.max.z-n)/a)+1;return s>=1&&s<=8&&r>=1&&r<=8?{file:s,rank:r}:void 0},fileRankFromCaptured:e=>({file:Math.floor(e/10)+10,rank:e%10/10*8+1}),snapToBoard(e,t){const n=this.fileRankFromXZ(this.board.bounds,t.x,t.z);if(n){const t=this.xzFromFileRank(this.board.bounds,n.file,n.rank),i=this.board.bounds.max.y;Ue(e.instancedMesh,e.index,t.x,i,t.z)}return n},actionsTick(e,t){const n=this.state;if(n.delay-=e,n.movers.length>0)n.movers.length>0&&(n.movers.forEach(t=>t.tick(e)),n.movers.every(e=>e.isComplete())&&(n.movers.length=0,n.actions.splice(0,1)));else if(n.actions.length>0){const e=n.actions[0],i=this.board.bounds;switch(e.type){case"move":{const a=e.piece,s=this.createMover(i,a,e.fromFile,e.fromRank,e.toFile,e.toRank,t);n.movers.push(s);break}case"capture":{const a=e.capturedPiece,s=this.fileRankFromCaptured(e.capturedIndex),r=this.createMover(i,a,s.file,s.rank,s.file,s.rank,t);n.movers.push(r);break}case"promote":{const a=e.newPiece;this.setupInstanceForPiece(a);const s=this.fileRankFromCaptured(e.capturedIndex),r=this.createMover(i,a,a.file,a.rank,a.file,a.rank,t),o=this.createMover(i,e.piece,s.file,s.rank,s.file,s.rank,t);n.movers.push(r,o);break}case"castle":{const a=e.king,s=e.rook,r=this.createMover(i,a,5,a.rank,e.kingside?7:3,a.rank,t),o=this.createMover(i,s,e.kingside?8:1,s.rank,e.kingside?6:4,s.rank,t);n.movers.push(r,o);break}default:throw Error(`unknown action of type "${e.type}"`)}}},replayTick(){const e=this.state;if(e.delay<=0&&0===e.movers.length&&0===e.actions.length&&this.pgnAST&&this.pgnAST.moves[e.replayIndex]){e.actions=Re(e.fenAST,this.pgnAST.moves[e.replayIndex]),e.delay=e.actions?this.data.replayTurnDuration:0;const t=this.pgnAST.moves[e.replayIndex],n=e.actions[0];"move"===n.type?(t.fromFile=n.fromFile,t.fromRank=n.fromRank):"castle"===n.type&&(t.fromFile=5,t.fromRank=n.king.rank),e.replayIndex++,this.system.broadcastNetworkData(this,{command:"move",nextPlayer:e.currentPlayer,moveStr:xe(t),nextReplayIndex:e.replayIndex})}},aiTick(){const e=this.state,t=this.data;if(0===e.movers.length&&0===e.actions.length&&this.garbochess&&e.nextAIMove){const n=Ee(e.fenAST,e.nextAIMove);t.debug&&console.log("AI",n.code===n.code.toLowerCase()?"black":"white",e.nextAIMove,we(n)),e.actions=Re(e.fenAST,n),e.nextAIMove="",this.nextTurn(),this.system.broadcastNetworkData(this,{command:"move",nextPlayer:e.currentPlayer,moveStr:xe(n),nextReplayIndex:0})}},grabTick(){this.state.grabMap.forEach((e,t)=>{Be(e.hand.object3D,t.instancedMesh,t.index,e.offsetMatrix)})},humanTick(){const e=this.data,t=this.state;if(t.nextHumanMove){const n=Ee(t.fenAST,t.nextHumanMove);e.debug&&console.log("HU",n.code===n.code.toLowerCase()?"black":"white",t.nextHumanMove,we(n)),Re(t.fenAST,n),this.setupBoard(t.fenAST),t.nextHumanMove="",this.nextTurn(),this.system.broadcastNetworkData(this,{command:"move",nextPlayer:t.currentPlayer,moveStr:xe(n),nextReplayIndex:0})}},createMover(e,t,n,i,a,s,r){let o=0;const l=Math.hypot(a-n,s-i)/r,c=this;return{tick:function(r){o+=r;const d=THREE.Math.clamp(o/l,0,1),h=(a-n)*d+n,u=(s-i)*d+i,m=c.xzFromFileRank(e,h,u),p=e.max.y;Ue(t.instancedMesh,t.index,m.x,p,m.z)},isComplete:function(){return o>l}}},setupGameWorker(){if(!this.garbochess){const e=this.state;fetch(this.data.aiWorker).then(e=>{if(!e.ok)throw Error(`problem with file "${this.data.aiWorker}"`);return e.text()}).then(t=>{const n=new Blob([t],{type:"text/javascript"}),i=window.URL.createObjectURL(n);this.garbochess=new Worker(i),this.garbochess.onerror=(e=>{throw Error(`problem with worker "${this.data.aiWorker} - ${e.message}"`)}),this.garbochess.onmessage=(t=>{if(this.data.debug&&console.log(t.data),t.data.startsWith("pv"));else if(t.data.startsWith("message"));else if(t.data.startsWith("invalid"))e.playerInfo[e.currentPlayer].networkClientId&&this.system.sendNetworkData(this,{command:"invalidMove"},e.playerInfo[e.currentPlayer].networkClientId),this.setupBoard(this.state.fenAST);else if(t.data.startsWith("valid")){const n=t.data.split(" ");e.nextHumanMove=n[1]}else t.data.startsWith("options")||(e.nextAIMove=t.data)}),this.setupMode(this.pendingMode)})}},onObject3dSet(e){this.data;this.chess3D=e.detail.object,this.createChessSet(this.chess3D),this.setupMode(this.pendingMode)},onHoverStart(e){const t=e.detail.obj3D;if(Object.keys(this.meshInfos).find(e=>this.meshInfos[e].instancedMesh===t)){const n=e.detail.instanceIndex;Qe(t,n,this.highlightColor)}},onHoverEnd(e){const t=e.detail.obj3D;if(Lt.find(e=>this.meshInfos[e].instancedMesh===t)){const n=this.state,i=e.detail.instanceIndex,a=n.fenAST.layout.find(e=>e.instancedMesh===t&&e.index===i)||n.fenAST.capturedPieces.find(e=>e.instancedMesh===t&&e.index===i),s=a.code===a.code.toLowerCase();Qe(t,i,s?this.blackColor:this.whiteColor)}},onGrabStart(e){const t=e.detail.obj3D;if(Lt.find(e=>this.meshInfos[e].instancedMesh===t)){const n=this.state,i=e.detail.hand,a=e.detail.instanceIndex,s=n.fenAST.layout.find(e=>e.instancedMesh===t&&e.index===a),r=n.grabMap.get(s);r?(r.offsetMatrix=Ne(i.object3D,t,s.index,r.offsetMatrix),r.hand=i):n.grabMap.set(s,{hand:i,offsetMatrix:Ne(i.object3D,t,s.index),startQuaternion:We(t,s.index)}),this.system.broadcastNetworkData(this,{command:"setHuman",player:n.currentPlayer,networkClientId:pt()})}},onGrabEnd(e){const t=e.detail.obj3D;if(Lt.find(e=>this.meshInfos[e].instancedMesh===t)){const n=this.state,i=e.detail.hand,a=e.detail.instanceIndex,s=n.fenAST.layout.find(e=>e.instancedMesh===t&&e.index===a),r=n.grabMap.get(s);if(r&&r.hand===i){const e=qe(t,a);if(e.y<this.gameBounds.max.y){const t=this.snapToBoard(s,e);if("game"===n.localMode||"network"===n.localMode){const e=ve(s.file,s.rank)+ve(t.file,t.rank);mt(this)?this.garbochess.postMessage(e):(n.pendingLocalMove=e,this.system.broadcastNetworkData(this,{command:"possibleMove",player:n.currentPlayer,moveStr:e}))}}Ge(t,a,r.startQuaternion),n.grabMap.delete(s)}}},onReset(){mt(this)&&this.resetGame(this.state.globalMode)},getSetupPacket(){const e=this.state;return{command:"setup",fen:ye(e.fenAST),captureStr:e.fenAST.capturedPieces.map(e=>e.code).join(""),playerInfo:e.playerInfo,globalMode:e.globalMode,replayIndex:e.replayIndex}},requestSync(e){this.system.sendNetworkData(this,this.getSetupPacket(),e)},receiveNetworkData(e,t){const n=this.state,i=t===NAF.utils.getNetworkOwner(this.el);if(!this.state.waitingForSetup||"setup"===e.command)switch(e.command){case"setup":i&&(n.waitingForSetup=!1,n.fenAST=this.parseFEN(e.fen),n.fenAST.capturedPieces=e.captureStr.split("").map(e=>({code:e,file:-1,rank:-1})),n.playerInfo=e.playerInfo,n.globalMode=e.globalMode,n.replayIndex=e.replayIndex,this.releaseAllInstances(),this.setupMode("network"));break;case"move":if(i){const t=Re(n.fenAST,Ee(n.fenAST,e.moveStr));n.pendingLocalMove===e.moveStr?this.setupBoard(this.state.fenAST):n.actions.push(...t),n.pendingLocalMove="",n.replayIndex=e.nextReplayIndex,this.setCurrentPlayer(e.nextPlayer)}break;case"possibleMove":mt(this)&&this.garbochess.postMessage(e.moveStr);break;case"invalidMove":i&&this.setupBoard(this.state.fenAST);break;case"setHuman":this.state.playerInfo[e.player].networkClientId=e.networkClientId,n.currentPlayer===e.player&&this.setupHumanPicking(e.player)}},onClientDisconnected(e){const t=e.detail.clientId,n=NAF.utils.getNetworkOwner(this.el);if(this.data.debug&&console.log("onClientDisconnected client:",t,"me:",NAF.clientId,"owner:",NAF.utils.getNetworkOwner(this.el)),n===NAF.clientId||n==t){const e=this.state;for(let n in e.playerInfo){e.playerInfo[n].networkClientId==t&&(e.playerInfo[n].networkClientId="",e.currentPlayer===n&&this.setupHumanPicking(n),this.system.broadcastNetworkData(this,{command:"setHuman",player:n,networkClientId:""}))}}},onOwnershipGained(){this.data.debug&&console.log("ownership-gained");const e=this.state;this.system.broadcastNetworkData(this,this.getSetupPacket()),this.setupMode(e.globalMode),e.waitingForSetup=!1},onOwnershipLost(){this.data.debug&&console.log("ownership-lost"),this.setupMode("network"),this.state.waitingForSetup=!0}}),AFRAME.registerComponent("climb",{schema:{cameraRig:{type:"selector"},enabled:{default:!0},debug:{default:!1}},init(){this.onGrabStart=this.onGrabStart.bind(this),this.onGrabEnd=this.onGrabEnd.bind(this),this.grab={hand:void 0,target:void 0,position:new THREE.Vector3}},tick:function(){let e=new THREE.Vector3;return function(){const t=this.data;if(t.enabled&&this.grab.hand&&this.grab.target){const n=t.cameraRig?t.cameraRig.object3D:this.el.object3D;n&&(this.grab.hand.object3D.getWorldPosition(e).sub(this.grab.position),n.position.sub(e))}}}(),play(){this.addListeners()},pause(){this.removeListeners()},addListeners(){this.el.addEventListener("grabstart",this.onGrabStart),this.el.addEventListener("grabend",this.onGrabEnd)},removeListeners(){this.el.removeEventListener("grabstart",this.onGrabStart),this.el.removeEventListener("grabend",this.onGrabEnd)},onGrabStart(e){this.data.debug&&console.log(Z(this.el),this.attrName,"onGrabStart",Z(e.detail.hand),Z(e.detail.object)),this.grab.hand=e.detail.hand,this.grab.target=e.detail.object,this.grab.hand.object3D.getWorldPosition(this.grab.position)},onGrabEnd(e){this.data.debug&&console.log(Z(this.el),this.attrName,"onGrabEnd",Z(e.detail.hand)),e.detail.hand===this.grab.hand&&(this.grab.hand=void 0)}});let _t=0;AFRAME.registerComponent("clone-entity",{schema:{type:"selector"},multiple:!0,update(){const e=this.data;let t=document.importNode(e instanceof HTMLTemplateElement?e.content:e,!0);const n=e=>{e.id&&(e.id+="_clone"+_t),e.children.forEach(n)};n(t),this.el.appendChild(t),_t++}}),AFRAME.registerComponent("clone-geometry",{schema:{src:{type:"selector"}},init(){this.onObject3DSet=this.onObject3DSet.bind(this)},update(e){if(this.data.src!==e.src){e instanceof HTMLElement&&e.removeEventListener("object3dset",this.onObject3DSet);const t=this.data.src;t instanceof HTMLElement&&"object3D"in t&&(this.cloneObject3D(t),t.addEventListener("object3dset",this.onObject3DSet))}},onObject3DSet(e){e.target===this.data.src&&e.detail.type&&this.cloneObject3D(this.data.src)},cloneObject3D(e){const t=this.el.object3D;for(let e in this.el.object3DMap)this.el.removeObject3D(e);for(;t.children.length>0;)t.remove(t.children[0]);function n(t){for(let n in e.object3DMap)if(t===e.object3DMap[n])return n}for(let i=0;i<e.object3D.children.length;i++){const a=e.object3D.children[i],s=n(a);s?this.el.setObject3D(s,a.clone()):t.add(a.clone())}}});const zt=[],Nt=.5*Math.PI,Bt=Math.PI,Vt=3,Ut=2**(6*Vt);function qt(e,t,n){return(new THREE.Quaternion).setFromEuler(new THREE.Euler(e,t,n))}const Gt={F2:{side:4,quaternion:qt(0,0,-Bt)},R2:{side:0,quaternion:qt(-Bt,0,0)},U2:{side:2,quaternion:qt(0,-Bt,0)},L2:{side:1,quaternion:qt(Bt,0,0)},D2:{side:3,quaternion:qt(0,Bt,0)},B2:{side:5,quaternion:qt(0,0,Bt)},"F'":{side:4,quaternion:qt(0,0,Nt)},"R'":{side:0,quaternion:qt(Nt,0,0)},"U'":{side:2,quaternion:qt(0,Nt,0)},"L'":{side:1,quaternion:qt(-Nt,0,0)},"D'":{side:3,quaternion:qt(0,-Nt,0)},"B'":{side:5,quaternion:qt(0,0,-Nt)},F:{side:4,quaternion:qt(0,0,-Nt)},R:{side:0,quaternion:qt(-Nt,0,0)},U:{side:2,quaternion:qt(0,-Nt,0)},L:{side:1,quaternion:qt(Nt,0,0)},D:{side:3,quaternion:qt(0,Nt,0)},B:{side:5,quaternion:qt(0,0,Nt)}};function Wt(e){let t=0;for(let n=0;n<e.length;n++)t+=e[n]*Math.pow(2,(e.length-n-1)*Vt);return t/Ut}window.addEventListener("load",()=>{document.body.addEventListener("connected",()=>{let e=document.querySelector("#clientId");e||((e=document.createElement("div")).id="clientId",e.setAttribute("style","position: absolute; left: 0; top: 0"),document.body.appendChild(e)),e.innerHTML=NAF.clientId.toString()})}),AFRAME.registerSystem("cube-puzzle",{...ft("cube-puzzle"),init(){this.setupNetwork()},remove(){this.shutdownNetwork()}}),AFRAME.registerComponent("cube-puzzle",{schema:{hands:{type:"selectorAll",default:"[hand-controls], [oculus-touch-controls], [vive-controls], [windows-motion-controls]"},grabStart:{default:"triggerdown"},grabEnd:{default:"triggerup"},highlightColor:{type:"color",default:"#555"},snapAngle:{default:20},moves:{default:"",parse:function(e){return e.trim().toUpperCase()}},debug:{default:!1}},init(){this.onGrabStart=this.onGrabStart.bind(this),this.onGrabEnd=this.onGrabEnd.bind(this),this.onBeforeCompile=this.onBeforeCompile.bind(this),this.actionTick={idle:this.tickIdle.bind(this),hold:this.tickHold.bind(this),turn:this.tickTurn.bind(this),turning:this.tickTurning.bind(this)},this.highlightColor=new THREE.Color,this.prevHighlighted=[],this.state={name:"idle",hold:{side:-1,matrix:new THREE.Matrix4},turn:{side:-1,pieces:[],matrices:[],handStart:new THREE.Matrix4,startAngle:0},snapped:!0,activeHands:[],slerpolator:void 0,snappedQuaternions:void 0,holderId:void 0},this.cube=this.createCube(),this.el.setObject3D("mesh",this.cube),this.state.snappedQuaternions=this.quaternions.slice(),this.system.registerNetworking(this,{requestSync:this.requestSync.bind(this),receiveNetworkData:this.receiveNetworkData.bind(this),onClientDisconnected:this.onClientDisconnected.bind(this),onOwnershipGained:this.onOwnershipGained.bind(this)})},remove(){this.system.unregisterNetworking(this)},update(e){const t=this.data;for(let e of t.hands)e.addEventListener(t.grabStart,this.onGrabStart),e.addEventListener(t.grabEnd,this.onGrabEnd);this.highlightColor.set(t.highlightColor),this.snapAngle=THREE.Math.degToRad(Math.abs(t.snapAngle)),t.moves!==e.moves&&(this.resetCube(),t.moves.split(" ").forEach(e=>{e&&!this.rotateCube(e)&&re(this,`unknown move "${e}"`)}))},tick(e,t){const n=Math.min(100,t)/1e3,i=this.state;this.tickSlerpolator(n),i.holderId&&i.holderId!==pt()||this.actionTick[this.state.name]()},dispatch(e){this.data.debug&&console.log("action",e.name,e);const t=this.state,n=t.name;switch(e.name){case"grab":if(t.activeHands.push(e.hand),"idle"===t.name)t.name="hold",t.hold.side=-1,t.holderId=pt(),Ft(t.activeHands[0].object3D,this.el.object3D,t.hold.matrix),i=this,"object"==typeof NAF&&ut(i)&&NAF.utils.takeOwnership(i.el);else if("hold"===t.name){const n=t.hold.side;if(t.snapped&&-1!==n){const i=this.getSidePieces(n);t.name="turn",t.turn.side=n,t.turn.pieces=i,t.turn.quaternions=this.quaternions.slice(),t.turn.handStart.copy(e.hand.object3D.matrixWorld),t.turn.startAngle=0}else t.snapped||n!==t.turn.side||(t.name="turning",t.turn.handStart.copy(e.hand.object3D.matrixWorld))}break;case"release":if("hold"===t.name){const n=t.activeHands.indexOf(e.hand);t.activeHands.splice(n,1),t.activeHands.length>0?Ft(t.activeHands[0].object3D,this.el.object3D,t.hold.matrix):(t.name="idle",this.broadcastState())}else if("turn"===t.name||"turning"===t.name){if("turning"===t.name){const e=t.activeHands[1];t.turn.startAngle+=this.calcAngleBetween(t.turn.handStart,e.object3D.matrixWorld)}const n=t.activeHands.indexOf(e.hand);t.activeHands.splice(n,1),t.activeHands.length>0&&Ft(t.activeHands[0].object3D,this.el.object3D,t.hold.matrix),t.name="hold"}break;case"unsnap":"turn"===t.name?(t.name="turning",t.snapped=!1):"turning"===t.name&&(t.snapped=!1);break;case"snap":t.snappedQuaternions.set(this.quaternions),this.broadcastState({slerp:!0}),t.snapped=!0;break;case"hover":"hold"===t.name&&(t.hold.side=e.side)}var i;this.data.debug&&t.name!==n&&console.log("newState",t.name)},tickSlerpolator(e){const t=this.state;t.slerpolator&&(t.slerpolator.isFinished()?(t.snapped=!0,t.slerpolator=void 0):t.slerpolator.step(e))},tickIdle(){if(!this.el.sceneEl.is("vr-mode"))return;this.data.hands.find(e=>this.isNear(e))?this.highlightPieces(this.allPieces):this.highlightPieces(zt)},tickHold(){const e=this.state;Dt(e.activeHands[0].object3D,this.el.object3D,e.hold.matrix);const t=this.data.hands.find(t=>!e.activeHands.includes(t)&&this.isNear(t));let n=zt;if(t){let i=e.turn.side;e.snapped?(i=this.calcBestSide(t,e.hold.side))>=0&&(n=this.getSidePieces(i)):n=e.turn.pieces,e.hold.side!==i&&this.dispatch({name:"hover",side:i})}this.highlightPieces(n)},tickTurn(){const e=this.state;Dt(e.activeHands[0].object3D,this.el.object3D,e.hold.matrix),this.highlightPieces(e.turn.pieces);const t=e.activeHands[1],n=this.calcAngleBetween(e.turn.handStart,t.object3D.matrixWorld);Math.abs(n)>this.snapAngle&&this.dispatch({name:"unsnap"})},tickTurning:function(){const e=new THREE.Quaternion,t=new THREE.Quaternion,n=new THREE.Vector3(1,0,0),i=new THREE.Vector3(0,1,0),a=new THREE.Vector3(0,0,1);return function(){const s=this.state;Dt(s.activeHands[0].object3D,this.el.object3D,s.hold.matrix),this.highlightPieces(s.turn.pieces);const r=s.activeHands[1],o=s.turn.startAngle+this.calcAngleBetween(s.turn.handStart,r.object3D.matrixWorld),l=Math.round(o/Nt)*Nt,c=Math.abs(o-l)<this.snapAngle,d=c?l:o;switch(s.turn.side%6){case 0:t.setFromAxisAngle(n,d);break;case 1:t.setFromAxisAngle(n,-d);break;case 2:t.setFromAxisAngle(i,d);break;case 3:t.setFromAxisAngle(i,-d);break;case 4:t.setFromAxisAngle(a,d);break;case 5:t.setFromAxisAngle(a,-d)}for(let n=0;n<s.turn.pieces.length;n++){const i=s.turn.pieces[n];e.fromArray(s.turn.quaternions,4*i),e.premultiply(t),e.toArray(this.quaternions,4*i)}this.instanceQuaternion.needsUpdate=!0,c&&!s.snapped?this.dispatch({name:"snap"}):s.snapped&&!c&&this.dispatch({name:"unsnap"})}}(),calcAngleBetween:function(){const e=new THREE.Vector3,t=new THREE.Vector3,n=new THREE.Vector3;return function(i,a){n.setFromMatrixColumn(i,0),e.setFromMatrixColumn(i,1),t.setFromMatrixColumn(a,1);const s=t.dot(n)<=0?1:-1;return e.angleTo(t)*s}}(),highlightPieces(e){if(this.prevHighlighted!==e&&(this.prevHighlighted.length!==e.length||this.prevHighlighted.some(t=>!e.includes(t)))){this.highlights.fill(0);for(let t of e)this.highlights[t]=1;this.instanceHighlight.needsUpdate=!0,this.prevHighlighted=e}},createCube(){const e=this.createCubeMaterial(),t=new THREE.BoxBufferGeometry(1/3,1/3,1/3),n=(new THREE.InstancedBufferGeometry).copy(t);this.positions=new Float32Array(78),this.quaternions=new Float32Array(104),this.packedFrames=new Float32Array(26),this.highlights=new Float32Array(26),this.allPieces=new Uint8Array(26);let i=0;for(let e=-1;e<=1;e++)for(let t=-1;t<=1;t++)for(let n=-1;n<=1;n++){if(0===e&&0===t&&0===n)continue;let a=3*i;this.positions[a]=e*(1/3),this.positions[a+1]=t*(1/3),this.positions[a+2]=n*(1/3),a=4*i,this.quaternions[a+3]=1;let s=[];for(let i=0;i<6;i++){let a=!1;switch(i){case 0:a=1===e;break;case 1:a=-1===e;break;case 2:a=1===t;break;case 3:a=-1===t;break;case 4:a=1===n;break;case 5:a=-1===n}s.push(a?i:7)}this.packedFrames[i]=Wt(s),this.highlights[i]=0,this.allPieces[i]=i,i++}return this.instancePosition=new THREE.InstancedBufferAttribute(this.positions,3),this.instanceQuaternion=new THREE.InstancedBufferAttribute(this.quaternions,4),this.instancePackedFrame=new THREE.InstancedBufferAttribute(this.packedFrames,1),this.instanceHighlight=new THREE.InstancedBufferAttribute(this.highlights,1),n.setAttribute("instancePosition",this.instancePosition),n.setAttribute("instanceQuaternion",this.instanceQuaternion),n.setAttribute("instancePackedFrame",this.instancePackedFrame),n.setAttribute("instanceHighlight",this.instanceHighlight),n.maxInstanceCount=26,new THREE.Mesh(n,e)},createCubeMaterial(){const e=128,t=document.createElement("canvas");t.width=e,t.height=64;const n=t.getContext("2d");n.fillStyle="black",n.fillRect(0,0,e,64),n.fillStyle="red",n.fillRect(2,34,28,28),n.fillStyle="orange",n.fillRect(34,34,28,28),n.fillStyle="white",n.fillRect(66,34,28,28),n.fillStyle="yellow",n.fillRect(98,34,28,28),n.fillStyle="green",n.fillRect(2,2,28,28),n.fillStyle="blue",n.fillRect(34,2,28,28),n.fillStyle="grey",n.fillRect(66,2,28,28);const i=new THREE.CanvasTexture(t),a=new THREE.MeshStandardMaterial({map:i});return a.onBeforeCompile=this.onBeforeCompile,a},resetCube(){const e=new THREE.Matrix4;for(let t of this.cube.children)t.position.set(0,0,0),t.quaternion.set(0,0,0,1),t.matrix.copy(e)},shuffleCube(e=30){const t=this.state,n=Object.keys(Gt);this.quaternions.set(t.snappedQuaternions);for(let t=0;t<e;t++){const e=~~(Math.random()*n.length);this.rotateCube(n[e])}t.snappedQuaternions.set(this.quaternions),this.broadcastState(),t.snapped=!0},rotateCube:function(){const e=new THREE.Quaternion;return function(t){const n=Gt[t];if(n){const n=Gt[t],i=n.side,a=this.getSidePieces(i);for(let t of a)e.fromArray(this.quaternions,4*t),e.premultiply(n.quaternion),e.toArray(this.quaternions,4*t)}return this.instanceQuaternion.needsUpdate=!0,n}}(),calcBestSide:function(){const e=new THREE.Matrix4,t=new THREE.Vector3,n=[{x:1,y:0,z:0},{x:-1,y:0,z:0},{x:0,y:1,z:0},{x:0,y:-1,z:0},{x:0,y:0,z:1},{x:0,y:0,z:-1}];return function(i,a){e.getInverse(this.el.object3D.matrixWorld).multiply(i.object3D.matrixWorld),t.setFromMatrixPosition(e);let s=-1,r=0;for(let e=0;e<n.length;e++){const i=n[e],a=t.dot(i);a>r&&(s=e,r=a)}return r>.6?s:a%6+6}}(),isNear:function(){const e=new THREE.Vector3,t=new THREE.Vector3,n=new THREE.Vector3;return function(i){const a=this.el.object3D;return n.setFromMatrixScale(a.matrixWorld),e.setFromMatrixPosition(i.object3D.matrixWorld),t.setFromMatrixPosition(a.matrixWorld),e.distanceTo(t)<n.length()}}(),getSidePieces:function(){const e=new THREE.Vector3,t=new THREE.Quaternion,n=[e=>e.x>.3,e=>e.x<-.3,e=>e.y>.3,e=>e.y<-.3,e=>e.z>.3,e=>e.z<-.3,e=>e.x>-.1,e=>e.x<.1,e=>e.y>-.1,e=>e.y<.1,e=>e.z>-.1,e=>e.z<.1];return function(i){if(i<0||i>=n.length)return[];const a=n[i];let s=[];for(let n of this.allPieces)e.fromArray(this.positions,3*n),t.fromArray(this.quaternions,4*n),e.applyQuaternion(t),a(e)&&s.push(n);return s}}(),onBeforeCompile(e){let t=e.vertexShader,n=e.fragmentShader;t=(t=(t=(t=t.replace("void main()","\n    attribute vec3 instancePosition;\n    attribute vec4 instanceQuaternion;\n    attribute float instancePackedFrame;\n    attribute float instanceHighlight;\n\n    varying vec3 vHighlightColor;\n\n    vec3 applyQuaternion( const vec3 v, const vec4 q ) \n    {\n      return v + 2. * cross( q.xyz, cross( q.xyz, v ) + q.w * v );\n    }\n\n    void main()")).replace("#include <uv_vertex>",`\n    #include <uv_vertex>\n    {\n      float faceDot = dot( normal, vec3(1., 3., 5.) );\n      float face = abs( faceDot ) - max( 0., sign( faceDot ) );\n      \n      float singleMultipler = ${2**Vt}.0;\n      float faceMultipler = pow(2., face * ${Vt}.0);\n      float prevFaces = floor( instancePackedFrame * faceMultipler );\n      float frame = floor( instancePackedFrame * faceMultipler * singleMultipler ) - prevFaces * singleMultipler;\n\n      float u0 = mod(frame, 4.0) / 4.0;\n      float v0 = floor(frame / 4.0) / 2.0;\n      vUv = mix( vec2(u0, v0), vec2(u0 + .25, v0 + .5), vUv );\n\n      vHighlightColor = mix(vec3(0.), vec3(.4), float( instanceHighlight ));\n    }`)).replace("#include <begin_vertex>","\n    vec3 transformed = applyQuaternion( position + instancePosition, instanceQuaternion );")).replace("#include <defaultnormal_vertex>","\n    vec3 transformedNormal = normalMatrix * applyQuaternion( objectNormal, -instanceQuaternion );\n    \n    #ifdef FLIP_SIDED\n      transformedNormal = - transformedNormal;\n    #endif\n\n    #ifdef USE_TANGENT\n      vec3 transformedTangent = normalMatrix * applyQuaternion( objectTangent, -instanceQuaternion );\n      #ifdef FLIP_SIDED\n        transformedTangent = - transformedTangent;\n      #endif\n    #endif"),n=(n=n.replace("#include <color_pars_fragment>","\n    #include <color_pars_fragment>\n    varying vec3 vHighlightColor;")).replace("vec3 totalEmissiveRadiance = emissive;","\n    vec3 totalEmissiveRadiance = emissive;\n    totalEmissiveRadiance += vHighlightColor;"),e.vertexShader=t,e.fragmentShader=n},onGrabStart(e){if(!this.el.sceneEl.is("vr-mode"))return;const t=e.target;-1===this.state.activeHands.indexOf(t)&&this.isNear(t)&&this.dispatch({name:"grab",hand:t})},onGrabEnd(e){if(!this.el.sceneEl.is("vr-mode"))return;const t=e.target;-1!==this.state.activeHands.indexOf(t)&&this.isNear(t)&&this.dispatch({name:"release",hand:t})},broadcastState(e={}){this.sendStateToClient(e)},sendStateToClient(e,t){const n=this.state;if(mt(this)){const i={holderId:n.holderId,slerp:!1,packedQuats:function(e){let t=Array(e.length);for(let n=0;n<e.length;n++){const i=Math.trunc(10*e[n]);let a;switch(i){case 0:a=0;break;case 5:a=1;break;case 7:a=2;break;case 10:a=3;break;case-5:a=4;break;case-7:a=5;break;case-10:a=6;break;default:console.assert(!1,`unknown value ${i} from ${e[n]}`)}t[n]=a}return t.join("")}(n.snappedQuaternions),...e};this.system.sendNetworkData(this,i,t)}},receiveNetworkData(e,t){const n=this.state;if(this.data.debug&&console.log("received packet from:",t,"owner:",NAF.utils.getNetworkOwner(this.el)),t===NAF.utils.getNetworkOwner(this.el)){n.holderId=e.holderId;const t=function(e,t,n){const i=e.slice(),a=e.slice(),s=e;let r=0;return{endQuaternions:a,step:function(e){r+=e;const o=THREE.Math.clamp(r/t,0,1);for(let e=0,t=i.length;e<t;e+=4)THREE.Quaternion.slerpFlat(s,e,i,e,a,e,o);n()},isFinished:function(){return r>t}}}(this.quaternions,e.slerp?.3:0,()=>{this.instanceQuaternion.needsUpdate=!0});!function(e,t){console.assert(e.length===t.length);const n=Math.cos(Math.PI/4);for(let i=0;i<t.length;i++){let a=0;switch(t[i]){case"0":a=0;break;case"1":a=.5;break;case"2":a=n;break;case"3":a=1;break;case"4":a=-.5;break;case"5":a=-n;break;case"6":a=-1}e[i]=a}}(t.endQuaternions,e.packedQuats),n.snappedQuaternions.set(t.endQuaternions),n.slerpolator=t}},requestSync(e){this.sendStateToClient({},e)},onClientDisconnected(e){const t=e.detail.clientId;this.state.holderId===t&&(this.state.holderId=void 0)},onOwnershipGained(){this.data.debug&&console.log("ownership-gained"),this.broadcastState()}}),AFRAME.registerComponent("cube-sphere",{schema:{radius:{default:1},segments:{default:16}},update(){this.createMesh()},createMesh(){const e=this.data.segments,t=new THREE.BoxBufferGeometry(1,1,1,e,e,e),n=t.getAttribute("position"),i=t.getAttribute("normal"),a=new THREE.Vector3;for(let e=0;e<n.count;e++){const t=3*e;a.fromArray(n.array,t),a.normalize(),a.toArray(n.array,t),a.toArray(i.array,t)}n.needsUpdate=!0,i.needsUpdate=!0;const s=new THREE.Mesh(t,["red","green","blue","yellow","orange","purple"].map(e=>new THREE.MeshBasicMaterial({color:e})));this.el.setObject3D("mesh",s)}}),AFRAME.registerComponent("extrude",{schema:{shape:{default:""},depth:{default:100},curveSegments:{type:"int",default:12},bevelEnabled:{default:!0},bevelThickness:{default:6},bevelSize:{default:2},bevelSegments:{type:"int",default:3},extrudePath:{default:""},steps:{type:"int",default:1}},update(){const e=this.data,t=It(e.shape),n={...e,extrudePath:e.extrudePath?It(e.extrudePath):void 0},i=new THREE.ExtrudeBufferGeometry(t,n),a=new THREE.Mesh(i,new THREE.MeshBasicMaterial);this.el.setObject3D("mesh",a)}});AFRAME.registerComponent("face-color",{schema:{color:{type:"color"},faces:{type:"array",parse:function(e){return"string"==typeof e?e.split(",").map(e=>parseInt(e,10)):e}},minPosition:{type:"vec3",default:{x:-1e10,y:-1e10,z:-1e10}},maxPosition:{type:"vec3",default:{x:1e10,y:1e10,z:1e10}},minSlope:{type:"int",default:0},maxSlope:{type:"int",default:90},meshName:{default:"mesh"}},multiple:!0,init(){this.onObject3DSet=this.onObject3DSet.bind(this),this.el.addEventListener("object3dset",this.onObject3DSet),this.isFirstFrame=!0,this.applyingFaceColors=!1},remove(){this.el.removeEventListener("object3dset",this.onObject3DSet)},update(){if(this.isFirstFrame)this.applyFaceColors(),this.isFirstFrame=!1;else{const e=this.el.components;for(let t in e)0===t.indexOf("face-color")&&e[t].applyFaceColors()}},onObject3DSet(e){e.target===this.el&&e.detail.type===this.data.meshName&&this.applyFaceColors()},applyFaceColors(){const e=this.data,t=this.el.getObject3D(e.meshName);if(t&&!this.applyingFaceColors){let n=t.geometry,i=!1;const a=t.material.color;if(a.r<.3&&a.g<.3&&a.b<.3&&se("material color is very dark, face-color will also be dark"),n.isInstancedBufferGeometry)return void se("face-color does not support InstancedBufferGeometry");if(this.applyingFaceColors=!0,n.isGeometry&&(n=(new THREE.BufferGeometry).copy(n),i=!0),n.index&&(n=n.toNonIndexed(),i=!0),!n.getAttribute("color")){const e=new Float32Array(3*n.getAttribute("position").count).fill(1);n.setAttribute("color",new THREE.Float32BufferAttribute(e,3))}const s=n.getAttribute("position"),r=n.getAttribute("normal"),o=n.getAttribute("color"),l=e.minPosition.x-.5,c=e.minPosition.y,d=e.minPosition.z-.5,h=e.maxPosition.x-.5,u=e.maxPosition.y,m=e.maxPosition.z-.5,p=new THREE.Color(e.color),f=1e-5,g=THREE.Math.degToRad,v=Math.cos(g(Math.max(0,e.minSlope)))+f,y=Math.cos(g(Math.max(0,e.maxSlope)))-f;for(let t=0,n=o.count,i=0;t<n;t+=3,i++){let n=!1;if(e.faces.length>0&&!e.faces.includes(i))n=!1;else{n=!0;for(let e=0;e<3;e++){const i=t+e,a=s.getX(i),o=s.getY(i),p=s.getZ(i);if(a<l||a>h||o<c||o>u||p<d||p>m){n=!1;break}const f=Math.abs(r.getY(i));if(f<y||f>v){n=!1;break}}}if(n)for(let e=0;e<3;e++)o.setXYZ(t+e,p.r,p.g,p.b)}o.needsUpdate=!0;const b=t.material;if(b.vertexColors=THREE.VertexColors,i){console.info(`face-color rebuilding mesh '${e.meshName}'`);const t=new THREE.Mesh(n,b);this.el.setObject3D(e.meshName,t)}this.applyingFaceColors=!1}}});const Qt=(e,t,n)=>t*n+e,$t=(e,t)=>[e%t,Math.trunc(e/t)];AFRAME.registerComponent("foliage",{schema:{instancePool:{type:"selector"},cellSize:{default:10},avoidance:{default:1},densities:{default:"1"},rotations:{default:"0"},scales:{default:"1"},colors:{default:"white"},intensityMap:{type:"selector"},debugCanvas:{type:"selector"},seed:{default:-1}},multiple:!0,init(){this.cells=[],this.lcg=p(),this.onPoolAvailable=this.onPoolAvailable.bind(this)},remove(){this.data.instancePool&&this.data.instancePool.removeEventListener("pool-available",this.onPoolAvailable),this.removeModels()},update(e){const t=this.data;this.lcg.setSeed(t.seed),this.densities=z(t.densities),this.rotations=z(t.rotations),this.scales=z(t.scales),this.colors=j(t.colors),this.drawCtx=t.debugCanvas instanceof HTMLCanvasElement?t.debugCanvas.getContext("2d"):void 0,t.instancePool&&(this.pool=t.instancePool.components["instance-pool"],t.instancePool.addEventListener("pool-available",this.onPoolAvailable),this.pool.isAvailable()&&this.createFoliage())},tick(){},tock(){},createFoliage(){const e=this.data,t=e.intensityMap,n=t.width,i=t.height;let a;if(t instanceof HTMLCanvasElement)a=t.getContext("2d");else if(t instanceof HTMLImageElement||t instanceof SVGImageElement){const e=document.createElement("canvas");e.width=n,e.height=i,(a=e.getContext("2d")).drawImage(t,0,0)}const s=this.densities.length-1,r=a.getImageData(0,0,n,i).data,o=Float32Array.from({length:r.length/4},(e,t)=>(r[4*t]+r[4*t+1]+r[4*t+2])/766),l=Array.from(o.keys()).sort((e,t)=>o[t]-o[e]);for(let e of this.cells)this.removeModels(e);this.cells=[],this.drawGrid2D(n,i,"black");for(let t of l){const a=Math.trunc(o[t]*(s+2));if(0===a)break;const[r,l]=$t(t,n),c=this.densities[a-1]||1,d=this.rotations[Math.min(this.rotations.length-1,a-1)]||0,h=this.scales[Math.min(this.scales.length-1,a-1)]||1,u=this.colors[Math.min(this.colors.length-1,a-1)]||1,m=this.populateCell(a,t,r,l,n,i,e.cellSize,c,d,h,u,e.avoidance);this.cells[t]=m,this.addModels(m,n,i,e.cellSize)}Et(this.el.sceneEl.object3D,e.debugCanvas)},addModels(e,t,n,i){const a=new THREE.Vector3,s=new THREE.Euler,r=new THREE.Quaternion,o=e.objects.length;if((!e.indexCount||e.indexCount<o)&&(e.indexCount&&this.pool.releaseBlock(o),e.index=this.pool.reserveBlock(o),e.indexCount=o),void 0===e.index)return;const l=e.index;for(let c=0;c<o;c++){const o=e.objects[c];a.x=(o.x-t/2)*i,a.y=0,a.z=(o.y-n/2)*i,r.setFromEuler(s.set(0,o.rotation,0)),this.pool.setScaleAt(l+c,o.scale,o.scale,o.scale),this.pool.setPositionAt(l+c,a.x,a.y,a.z),this.pool.setQuaternionAt(l+c,r.x,r.y,r.z,r.w),this.pool.setColorAt(l+c,o.color.r,o.color.g,o.color.b)}return e.objects.length},removeModels(e){this.poolIndex&&e.indexCount>0&&(this.pool.releaseBlock(e.index),e.indexCount=0,e.index=void 0)},populateCell(e,t,n,i,a,s,r,o,l,c,d,h){const u=h/r,m=e=>e*e,p={id:t,objects:[]};function f(e,t,n,i){if(e)for(let a of e.objects)if(m(a.x-t)+m(a.y-n)<m(i+a.r))return!0;return!1}this.lcg.setSeed(1761*t);const g=U(o,this.lcg.random);let v=0,y=4*g;for(;v<g&&y-- >0;){const t=this.lcg.random()+n,r=this.lcg.random()+i;let o=f(p,t,r,u);if(o=(o=(o=(o=o||n>0&&f(this.cells[Qt(n-1,i,a)],t,r,u))||i>0&&f(this.cells[Qt(n,i-1,a)],t,r,u))||n<a-1&&f(this.cells[Qt(n+1,i,a)],t,r,u))||i<s-1&&f(this.cells[Qt(n,i+1,a)],t,r,u))this.drawCircle2D(t/a,r/s,u/a,"red");else{const n=U(l,this.lcg.random),i=U(c,this.lcg.random),o=U(d,this.lcg.random);p.objects.push({level:e,x:t,y:r,r:u,scale:i,rotation:n,color:o}),this.drawCircle2D(t/a,r/s,u/a,"blue",!0),v++}}return p},onPoolAvailable(e){e.detail.pool===this.pool&&this.createFoliage()},drawCircle2D(e,t,n,i,a=!1){this.drawCtx&&(e*=this.drawCtx.canvas.width,t*=this.drawCtx.canvas.height,n*=this.drawCtx.canvas.width,this.drawCtx.beginPath(),this.drawCtx.arc(e,t,n,0,2*Math.PI),a?(this.drawCtx.fillStyle=i,this.drawCtx.fill()):(this.drawCtx.strokeStyle=i,this.drawCtx.stroke()))},drawPoint2D(e,t,n){this.drawCtx&&(e*=this.drawCtx.canvas.width,t*=this.drawCtx.canvas.height,this.drawCtx.fillStyle=n,this.drawCtx.fillRect(e,t,1,1))},drawGrid2D(e,t,n){if(this.drawCtx){this.drawCtx.strokeStyle=n;const i=this.drawCtx.canvas.width/e,a=this.drawCtx.canvas.height/t;for(let n=0;n<e;n++)for(let e=0;e<t;e++)this.drawCtx.strokeRect(n*i,e*a,i,a)}}});var Yt={},Xt={};AFRAME.registerComponent("gltf-part",{schema:{part:{type:"string"},src:{type:"asset"}},update:function(){var e=this.el;!this.data.part&&this.data.src||this.getModel(function(t){t&&e.setObject3D("mesh",t)})},getModel:function(e){var t=this;if(!Xt[this.data.src])return Yt[this.data.src]?Yt[this.data.src].then(function(n){e(t.selectFromModel(n))}):void(Yt[this.data.src]=new Promise(function(n){(new THREE.GLTFLoader).load(t.data.src,function(i){var a=i.scene||i.scenes[0];Xt[t.data.src]=a,delete Yt[t.data.src],e(t.selectFromModel(a)),n(a)},function(){},console.error)}));e(this.selectFromModel(Xt[this.data.src]))},selectFromModel:function(e){var t;if(t=e.getObjectByName(this.data.part))return t.clone();console.error("[gltf-part] `"+this.data.part+"` not found in model.")}});const Zt=Symbol("idle"),Kt=Symbol("hover"),Jt=Symbol("grab");AFRAME.registerSystem("grab-system",{schema:{hands:{type:"selectorAll",default:"[hand-controls], [oculus-touch-controls], [vive-controls], [windows-motion-controls]"},grabStart:{default:"triggerdown"},grabEnd:{default:"triggerup"},debug:{default:!1}},init(){this.grabEvents=new Set,this.onGrabEvent=this.onGrabEvent.bind(this),this.targets=[],this.hands=[]},remove(){this.grabEvents.forEach(e=>this.removeHandListeners(e,this.onGrabEvent))},update(e){const t=this.data;e.hands!==t.hands&&(this.grabEvents.forEach(e=>this.removeHandListeners(e,this.onGrabEvent)),this.hands=t.hands?t.hands.map(e=>({el:e,target:void 0,name:Zt})):[],this.grabEvents.forEach(e=>this.addHandListeners(e,this.onGrabEvent)),t.debug&&ae(this,`found ${this.hands.length} hands`))},tick(){for(let e of this.hands)e.name!==Jt&&this.checkHover(e)},checkHover(e){const t=this.findOverlapping(e.el,this.targets);this.transition(e,{name:t?Kt:Zt,target:t})},registerTarget(e,t={}){const n=this.data,i=Object.assign({el:e,obj3D:e.object3D,grabStart:n.grabStart,grabEnd:n.grabEnd,instanceIndex:-1},t);-1===this.targets.findIndex(t=>t.el===e&&t.obj3D===i.obj3D&&t.instanceIndex===i.instanceIndex)&&(this.targets.push(i),this.grabEvents.add(i.grabStart),this.grabEvents.add(i.grabEnd),this.addHandListeners(i.grabStart,this.onGrabEvent),this.addHandListeners(i.grabEnd,this.onGrabEvent),n.debug&&ae(this,`registered: ${Z(e)}, grabStart: ${i.grabStart}, grabEnd: ${i.grabEnd}, instanceIndex: ${i.instanceIndex}`))},unregisterTarget(e,t){const n=t.obj3D||e.object3D,i=void 0!==t.instanceIndex?t.instanceIndex:-1,a=this.targets.findIndex(t=>t.el===e&&t.obj3D===n&&t.instanceIndex===i);-1!==a&&(this.targets.splice(a),this.data.debug&&ae(this,`unregistered ${Z(e)}, instanceIndex: ${i}`))},addHandListeners(e,t){for(let n of this.hands)n.el.addEventListener(e,t),this.data.debug&&ae(this,`add listener '${e}' to ${Z(n.el)}`)},removeHandListeners(e,t){for(let n of this.hands)n.el.removeEventListener(e,t),this.data.debug&&ae(this,`remove listener '${e}' from ${Z(n.el)}`)},sendEvent(e,t,n){this.data.debug&&ae(this,`send '${t}' to '${Z(e)}'`),e.emit(t,n)},findOverlapping:function(){const e=new THREE.Matrix4;return function(t,n){if(!this.el.is("vr-mode"))return;const i=this.data,a=this;let s=Number.MAX_VALUE,r=void 0;const o=t.object3D;o.boundingSphere&&o.boundingBox&&!o.boundingBox.isEmpty()||Tt(o,i.debug?65535:void 0);for(let e of n){const t=e.obj3D;t&&(t.boundingSphere&&t.boundingBox&&!t.boundingBox.isEmpty()||Tt(t,i.debug?16776960:void 0))}if(!o.boundingBox.isEmpty()){for(let t of n){const n=t.obj3D;if(!n)continue;if(n.boundingBox.isEmpty())continue;const i=t.instanceIndex>=0?ze(n,t.instanceIndex,e):n.matrixWorld;if(gt(o.boundingBox.min,o.boundingBox.max,o.matrixWorld.elements,n.boundingBox.min,n.boundingBox.max,i.elements)){const e=a.getScore(o,t,i);e<s&&(s=e,r=t)}}return r}}}(),transition(e,t){switch(e.name){case Zt:t.name===Kt&&(this.sendEvent(t.target.el,"hoverstart",{hand:e.el,obj3D:t.target.obj3D,instanceIndex:t.target.instanceIndex}),e.name=Kt,e.target=t.target);break;case Kt:t.name===Zt?(this.sendEvent(e.target.el,"hoverend",{hand:e.el,obj3D:e.target.obj3D,instanceIndex:e.target.instanceIndex}),e.name=Zt,e.target=void 0):t.name===Jt?(this.sendEvent(e.target.el,"hoverend",{hand:e.el,obj3D:e.target.obj3D,instanceIndex:e.target.instanceIndex}),this.sendEvent(e.target.el,"grabstart",{hand:e.el,obj3D:e.target.obj3D,instanceIndex:e.target.instanceIndex}),e.name=Jt):t.name===Kt&&t.target!==e.target&&(this.sendEvent(e.target.el,"hoverend",{hand:e.el,obj3D:e.target.obj3D,instanceIndex:e.target.instanceIndex}),this.sendEvent(t.target.el,"hoverstart",{hand:e.el,obj3D:t.target.obj3D,instanceIndex:t.target.instanceIndex}),e.target=t.target);break;case Jt:t.name===Zt&&(this.sendEvent(e.target.el,"grabend",{hand:e.el,obj3D:e.target.obj3D,instanceIndex:e.target.instanceIndex}),e.name=Zt,e.target=void 0)}return e},onGrabEvent(e){const t=this.hands.find(t=>t.el===e.target);t&&(t.name===Jt&&t.target&&t.target.grabEnd===e.type&&t.target.el?this.transition(t,{name:Zt}):t.name===Kt&&t.target&&t.target.el&&t.target.grabStart===e.type&&this.transition(t,{name:Jt}))},getScore:function(){const e=new THREE.Vector3,t=new THREE.Vector3,n=new THREE.Vector3,i=new THREE.Vector3,a=new THREE.Vector3;return function(s,r,o){switch(r.score){case"closestforward":e.setFromMatrixPosition(s.matrixWorld),t.setFromMatrixPosition(o),n.setFromMatrixColumn(s.matrixWorld,2),i.subVectors(t,e),n.normalize();const c=n.dot(i);a.copy(n).multiplyScalar(c);const d=a.sub(i).length();return c<0?d:10*d;case"volume":default:return((l=r.obj3D.boundingBox).max.x-l.min.x)*(l.max.y-l.min.y)*(l.max.z-l.min.z)}var l}}()}),AFRAME.registerComponent("handle",{schema:{target:{default:"parent"},debug:{default:!1}},events:{grabstart:function(e){this.onGrabStart(e)},grabend:function(e){this.onGrabEnd(e)}},init(){this.onGrabStart=this.onGrabStart.bind(this),this.onGrabEnd=this.onGrabEnd.bind(this),this.grabHand=void 0,this.invHandMatrix=new THREE.Matrix4},tick(){this.grabHand?this.repositionTarget():this.el.sceneEl.removeBehavior(this)},repositionTarget:function(){const e=new THREE.Matrix4,t=new THREE.Matrix4,n=new THREE.Vector3;return function(){const i=this.getTargetObject3D(this.data.target);if(!i)return;const a=this.grabHand.object3D;a.updateMatrixWorld(),i.updateMatrixWorld(),t.getInverse(i.parent.matrixWorld),e.copy(this.invHandMatrix).premultiply(a.matrixWorld).premultiply(t),e.decompose(i.position,i.quaternion,n)}}(),getTargetObject3D(e){switch(e){case"self":return this.el.object3D;case"parent":return this.el.object3D.parent;default:const t=document.querySelector(this.data.target);return t?t.object3D:void 0}},onGrabStart(e){this.data.debug&&console.log(Z(this.el),"onGrabStart",Z(e.detail.hand)),this.grabHand=e.detail.hand,this.el.sceneEl.addBehavior(this);const t=this.getTargetObject3D(this.data.target);if(t){const e=this.grabHand.object3D;e.updateMatrixWorld(),t.updateMatrixWorld(),this.invHandMatrix.getInverse(e.matrixWorld).multiply(t.matrixWorld)}},onGrabEnd(e){this.data.debug&&console.log(Z(this.el),"onGrabEnd",Z(e.detail.hand)),this.grabHand===e.detail.hand&&(this.grabHand=void 0)}});const en={rgb:[1/765,1/765,1/765,0],rgba:[1/765,1/765,1/765,1/765],r:[1/255,0,0,0],g:[0,1/255,0,0],b:[0,0,1/255,0],a:[0,0,0,1/255]};function tn(e){let t=[];e.parent.updateMatrixWorld();const n=(new THREE.Matrix4).getInverse(e.matrixWorld),i=new THREE.Matrix4,a=new THREE.Vector3;return e.traverse(e=>{const s=e.isMesh?e:void 0;if(s&&s.geometry)if(i.copy(s.matrixWorld).multiply(n),s.geometry.isBufferGeometry){const e=s.geometry.getAttribute("position").array,n=s.geometry.getAttribute("position").itemSize,r=e.length;for(let s=0;s<r;s+=n)a.set(e[s],e[s+1],e[s+2]).applyMatrix4(i),t.push(a.x,a.y,a.z)}else{const e=s.geometry.vertices,n=s.geometry.vertices.length;for(let s=0;s<n;s++)a.copy(e[s]).applyMatrix4(i),t.push(a.x,a.y,a.z)}}),t.length>0?t:void 0}AFRAME.registerComponent("heightfield",{schema:{src:{type:"selector"},numRows:{type:"int",default:32},numCols:{type:"int",default:32},heightScale:{default:.2},channels:{default:"rgb",oneOf:Object.keys(en)},smooth:{default:!1}},init(){this.onLoaded=this.onLoaded.bind(this),this.loadTextureCallback=this.loadTextureCallback.bind(this),this.geometry=void 0,this.image=void 0},update(e){const t=this.data;e.src!==t.src?this.loadTexture(t.src):e.numRows!==t.numRows||e.numCols!==t.numCols||e.smooth!==t.smooth?this.createHeightfield(this.image):e.heightScale===t.heightScale&&e.channels===t.channels||this.el.getObject3D("mesh")===this.mesh&&this.updateHeightfield(this.image)},loadTexture(e){this.el.sceneEl.systems.material.loadTexture(e,{src:e},this.loadTextureCallback)},loadTextureCallback(e){e&&e.image&&e.image instanceof HTMLElement?this.createHeightfield(e.image):se(`heightfield: unable to access image '${this.data.src}'`)},onLoaded(e){this.createHeightfield(e.target)},createHeightfield(e){this.image!==e&&(this.image&&this.image.removeEventListener("loaded",this.onLoaded),this.image=e,e&&e.addEventListener("loaded",this.onLoaded));const t=this.data.numRows,n=this.data.numCols;let i;if(this.data.smooth)(i=new THREE.PlaneBufferGeometry(1,1,n,t)).applyMatrix((new THREE.Matrix4).set(1,0,0,0,0,0,-1,0,0,-1,0,0,0,0,0,1));else{const e=6*(n*t),a=new Float32Array(3*e),s=new Float32Array(3*e),r=new Float32Array(2*e);i=new THREE.BufferGeometry;for(let e=0;e<t;e++)for(let i=0;i<n;i++){const s=6*(e*n+i)*3,o=6*(e*n+i)*2,l=i/n,c=(i+1)/n,d=e/t,h=(e+1)/t;a[s+3]=a[s+9]=a[s+15]=l-.5,a[s+2]=a[s+5]=a[s+17]=d-.5,a[s+0]=a[s+6]=a[s+12]=c-.5,a[s+8]=a[s+11]=a[s+14]=h-.5,r[o+2]=r[o+6]=r[o+10]=l,r[o+1]=r[o+3]=r[o+11]=1-d,r[o+0]=r[o+4]=r[o+8]=c,r[o+5]=r[o+7]=r[o+9]=1-h}i.setAttribute("position",new THREE.Float32BufferAttribute(a,3)),i.setAttribute("normal",new THREE.Float32BufferAttribute(s,3)),i.setAttribute("uv",new THREE.Float32BufferAttribute(r,2))}const a=this.el.getObject3D("mesh");this.mesh=new THREE.Mesh(i,a?a.material:new THREE.MeshBasicMaterial),this.updateHeightfield(this.image),this.el.setObject3D("mesh",this.mesh)},updateHeightfield(e){let t;e instanceof HTMLCanvasElement?t=e:((t=document.createElement("canvas")).width=e.width,t.height=e.height,t.getContext("2d").drawImage(e,0,0));const n=t.width,i=t.height,a=t.getContext("2d").getImageData(0,0,n,i).data,s=this.data.numRows,r=this.data.numCols,o=this.mesh.geometry.getAttribute("uv"),l=this.mesh.geometry.getAttribute("position"),c=en[this.data.channels]||en.rgb,d=this.data.heightScale,h=s*r,u=new Float32Array((s+1)*(r+1)),m=new Float32Array(h),p=(n-1)/r,f=(i-1)/s;for(let e=0;e<=s;e++)for(let t=0;t<=r;t++){const i=4*(Math.floor(t*p)+Math.floor(e*f)*n);u[t+e*(r+1)]=(a[i]*c[0]+a[i+1]*c[1]+a[i+2]*c[2]+a[i+3]*c[3])*d}for(let e=0;e<s;e++)for(let t=0;t<r;t++){const i=4*(Math.floor((t+.5)*p)+Math.floor((e+.5)*f)*n);m[t+e*r]=(a[i]*c[0]+a[i+1]*c[1]+a[i+2]*c[2]+a[i+3]*c[3])*d}if(this.data.smooth)for(let e=0;e<l.count;e++)l.setY(e,u[e]);else for(let e=0;e<s;e++)for(let t=0;t<r;t++){const n=t+e*(r+1),i=t+e*r,a=6*i,s=u[n],c=u[n+1],d=u[n+r+1],h=u[n+r+2],p=m[i],f=t/r,g=(t+1)/r;l.setY(a,c),l.setY(a+1,s),l.setY(a+3,d),l.setY(a+4,h),Math.abs(.5*(s+h)-p)>Math.abs(.5*(d+c)-p)?(l.setX(a+2,f-.5),l.setY(a+2,d),l.setX(a+5,g-.5),l.setY(a+5,c),o.setX(a+2,f),o.setX(a+5,g)):(l.setX(a+2,g-.5),l.setY(a+2,h),l.setX(a+5,f-.5),l.setY(a+5,s),o.setX(a+2,g),o.setX(a+5,f))}this.mesh.geometry.computeVertexNormals(),l.needsUpdate=!0}}),AFRAME.registerComponent("hull",{schema:{points:{default:""},src:{type:"selector"},computeNormals:{default:!1}},init(){this.onObject3DSet=this.onObject3DSet.bind(this)},update(e){const t=this.data;let n;if(t.src===this.el&&re("cannot set 'src' to yourself"),t.src!==e.src&&(e.src&&e.src.removeEventListener("object3dset",this.onObject3DSet),t.src&&(t.src.object3D?(n=tn(t.src.object3D),t.src.addEventListener("object3dset",this.onObject3DSet)):se("'src' must point to an entity"))),t.points!==e.points&&t.points&&!n){const e=t.points.split(",").map(e=>AFRAME.utils.coordinates.parse(e)),i=["x","y","z"];n=Float32Array.from({length:3*e.length},(t,n)=>e[~~(n/3)][i[n%3]])}n&&this.generateHull(n)},generateHull(e){const t=_e(e).flatMap(t=>[e[t],e[t+1],e[t+2]]),n=new THREE.BufferGeometry;n.setAttribute("position",new THREE.BufferAttribute(Float32Array.from(t),3)),this.data.computeNormals&&n.computeVertexNormals();const i=new THREE.Mesh(n,new THREE.MeshBasicMaterial({color:"white"}));this.el.setObject3D("mesh",i)},onObject3DSet(e){const t=this.data;if(e.target===t.src){const e=tn(t.src.object3D);e&&this.generateHull(e)}}}),AFRAME.registerComponent("instance",{schema:{src:{type:"selector"},color:{type:"color",default:"#fff"},dynamic:{default:!1}},init(){this.instancePool=void 0,this.blockIndex=void 0,this.color=new THREE.Color},remove(){this.freeInstance()},update(e){const t=this.data;if(e.src!==t.src){const e=t.src.components["instance-pool"];e?(this.freeInstance(),this.blockIndex=e.reserveBlock(1),this.instancePool=e,void 0===this.blockIndex&&se("no more instances available")):se("no 'instance-pool' found on src")}else re("missing 'src' on 'instance' component");e.dynamic!==t.dynamic&&t.dynamic&&this.el.sceneEl.addBehavior(this),e.color!==t.color&&this.color.set(t.color)},tick(){this.syncTransform(),this.data.dynamic||this.el.sceneEl.removeBehavior(this)},syncTransform(){const e=this.blockIndex;if(this.instancePool&&void 0!==e){let t=this.el.object3D.position;this.instancePool.setPositionAt(e,t.x,t.y,t.z),t=this.el.object3D.quaternion,this.instancePool.setQuaternionAt(e,t.x,t.y,t.z,t.w),t=this.el.object3D.scale,this.instancePool.setScaleAt(e,t.x,t.y,t.z);const n=this.color;this.instancePool.setColorAt(e,n.r,n.g,n.b)}},freeInstance(){this.instancePool&&void 0!==this.blockIndex&&this.instancePool.releaseBlock(this.blockIndex),this.instancePool=void 0,this.blockIndex=void 0}}),AFRAME.registerPrimitive("a-instance",{defaultComponents:{instance:{}},mappings:{src:"instance.src",color:"instance.color",dynamic:"instance.dynamic"}});AFRAME.registerComponent("instance-pool",{schema:{size:{default:1e3},patchShader:{default:!0}},init(){this.oldMesh=void 0,this.positions=void 0,this.colors=void 0,this.quaternions=void 0,this.scales=void 0,this.instancedGeoemtry=void 0,this.reservedCount=0,this.occupiedBlocks=[],this.freeBlocks=[],this.inCreateInstances=!1,this.onObject3DSet=this.onObject3DSet.bind(this),this.onBeforeCompile=this.onBeforeCompile.bind(this),this.el.addEventListener("object3dset",this.onObject3DSet)},remove(){this.el.removeEventListener("object3dset",this.setobject3d),this.destroyInstances()},update(){this.createInstances()},onObject3DSet(e){this.inCreateInstances||e.target!==this.el||"mesh"!==e.detail.type||(this.destroyInstances(),this.createInstances())},createInstances(){const e=this.el.getObject3D("mesh"),t=e?e.getObjectByProperty("isMesh",!0):void 0;if(!t||!t.geometry||!t.material)return;this.inCreateInstances=!0,this.oldMesh=t;const n=this.data,i=(new THREE.InstancedBufferGeometry).copy(t.geometry),a=n.size;i.maxInstancedCount=0;const s=this.positions&&this.positions.length===a?this.positions:new Float32Array(3*a),r=this.scales&&this.scales.length===a?this.scales:new Float32Array(3*a).fill(0),o=this.colors&&this.colors.length===a?this.colors:new Float32Array(4*a).fill(1),l=this.quaternions&&this.quaternions===a?this.quaternions:new Float32Array(4*a).map((e,t)=>(t-3)%4?0:1);this.instancePosition=new THREE.InstancedBufferAttribute(s,3),this.instanceQuaternion=new THREE.InstancedBufferAttribute(l,4),this.instanceScale=new THREE.InstancedBufferAttribute(r,3),this.instanceColor=new THREE.InstancedBufferAttribute(o,4),i.setAttribute("instancePosition",this.instancePosition),i.setAttribute("instanceQuaternion",this.instanceQuaternion),i.setAttribute("instanceScale",this.instanceScale),i.setAttribute("instanceColor",this.instanceColor);let c=t.material;n.patchShader&&(Array.isArray(t.material)?(c=t.material.map(e=>e.clone())).forEach(e=>e.onBeforeCompile=this.onBeforeCompile(e.onBeforeCompile)):(c=t.material.clone()).onBeforeCompile=this.onBeforeCompile(c.onBeforeCompile));const d=new THREE.Mesh(i,c);d.frustumCulled=!1,this.el.setObject3D("mesh",d),this.instancedGeoemtry=i,this.positions=s,this.quaternions=l,this.scales=r,this.colors=o,this.reservedCount=0,this.freeBlocks=[[0,a]],this.occupiedBlocks=[],this.inCreateInstances=!1,this.el.emit("pool-available",{pool:this})},destroyInstances(){this.oldMesh&&(this.el.setObject3D("mesh",this.oldMesh),this.oldMesh=void 0),this.instancedGeoemtry=void 0,this.positions=void 0,this.quaternions=void 0,this.scales=void 0,this.colors=void 0,this.freeBlocks=[],this.occupiedBlocks=[]},onBeforeCompile(e){const t=e;return function(e){t&&t(e);let n=e.vertexShader,i=e.fragmentShader;n=(n=(n=(n=n.replace("void main()","\n      attribute vec3 instancePosition;\n      attribute vec4 instanceQuaternion;\n      attribute vec4 instanceColor;\n      attribute vec3 instanceScale;\n  \n      varying vec4 vInstanceColor;\n  \n      vec3 applyQuaternion( const vec3 v, const vec4 q ) \n      {\n        return v + 2. * cross( q.xyz, cross( q.xyz, v ) + q.w * v );\n      }\n  \n      void main()")).replace("#include <color_vertex>","\n      #include <color_vertex>\n      vInstanceColor = instanceColor;")).replace("#include <begin_vertex>","\n      vec3 transformed = applyQuaternion( position*instanceScale, instanceQuaternion ) + instancePosition;")).replace("#include <defaultnormal_vertex>","\n      vec3 transformedNormal = normalMatrix * applyQuaternion( objectNormal/instanceScale, -instanceQuaternion );\n      \n      #ifdef FLIP_SIDED\n        transformedNormal = - transformedNormal;\n      #endif\n  \n      #ifdef USE_TANGENT\n        vec3 transformedTangent = normalMatrix * applyQuaternion( objectTangent/instanceScale, -instanceQuaternion );\n        #ifdef FLIP_SIDED\n          transformedTangent = - transformedTangent;\n        #endif\n      #endif"),i=(i=i.replace("#include <color_pars_fragment>","\n      #include <color_pars_fragment>\n      varying vec4 vInstanceColor;")).replace("#include <color_fragment>","\n      #include <color_fragment>\n      diffuseColor *= vInstanceColor;"),e.vertexShader=n,e.fragmentShader=i}},isAvailable(){return!!this.instancedGeoemtry},reserveBlock(e){if(!(e<=0))for(let t=this.freeBlocks.length-1;t>=0;t--){const n=this.freeBlocks[t],i=n[1]-e;if(i>=0){const t=[n[0],e];if(this.occupiedBlocks.push(t),this.instancedGeoemtry.maxInstancedCount=Math.max(this.instancedGeoemtry.maxInstancedCount,t[0]+t[1]),i>0)n[0]+=e,n[1]=i;else{const e=this.freeBlocks;this.freeBlocks.splice(e,1)}return t[0]}}},releaseBlock(e){for(let t=0;t<this.occupiedBlocks.length;t++){const n=this.occupiedBlocks[t];if(n[0]===e){for(let t=e;t<e+n[1];t++)this.setScaleAt(t,0,0,0);this.occupiedBlocks.splice(t,1),this.freeBlocks.push(n),this.repartionBlocks(n);const i=this.occupiedBlocks.reduce((e,t)=>Math.max(e,t[0]+t[1]),0);return this.instancedGeoemtry.maxInstancedCount=Math.max(this.instancedGeoemtry.maxInstancedCount,i),!0}}return!1},repartionBlocks(){for(let e=this.freeBlocks.length-1;e>=0;e--){const t=this.freeBlocks[e];for(let n=0;n<e;n++){const i=this.freeBlocks[n];if(i[0]==t[0]+t[1]){i[0]=t[0],i[1]+=t[1],this.freeBlocks.splice(e,1);break}if(i[0]+i[1]===t[0]){i[1]+=t[1],this.freeBlocks.splice(e,1);break}}}},setColorAt(e,t,n,i,a){const s=4*e;this.colors[s]=t,this.colors[s+1]=n,this.colors[s+2]=i,this.colors[s+3]=void 0!==a?a:1,this.instanceColor.needsUpdate=!0},setPositionAt(e,t,n,i){const a=3*e;this.positions[a]=t,this.positions[a+1]=n,this.positions[a+2]=i,this.instancePosition.needsUpdate=!0},setScaleAt(e,t,n,i){const a=3*e;this.scales[a]=t,this.scales[a+1]=void 0!==n?n:t,this.scales[a+2]=void 0!==i?i:t,this.instanceScale.needsUpdate=!0},setQuaternionAt(e,t,n,i,a){const s=4*e;this.quaternions[s]=t,this.quaternions[s+1]=n,this.quaternions[s+2]=i,this.quaternions[s+3]=a,this.instanceQuaternion.needsUpdate=!0},getPositionAt(e,t){const n=3*e;return t.x=this.positions[n],t.y=this.positions[n+1],t.z=this.positions[n+2],t},getColorAt(e,t){const n=4*e;return t.r=this.colors[n],t.g=this.colors[n+1],t.b=this.colors[n+2],t.a=this.colors[n+3],t},getScaleAt(e,t){const n=3*e;return t.x=this.scales[n],t.y=this.scales[n+1],t.z=this.scales[n+2],t},getQuaternionAt(e,t){const n=4*e;return t.x=this.quaternions[n],t.y=this.quaternions[n+1],t.z=this.quaternions[n+2],t.w=this.quaternions[n+3],t}});function nn(e,t,n,i=Ke){const[a,s]=Ze(t,n,i);switch(e){case"object":return Xe(t[a],t[a+1],s);case"number":return Ye(t[a],t[a+1],s);default:return t[a]}}function an(e,t){const n=t.split(".");if(n.length<=2)return G(AFRAME.utils.entity.getComponentProperty(e,t));const i=x(e,n);if(i)return G(i[t]);se(`unknown path for getProperty() '${t}'`)}AFRAME.registerComponent("keyframe",{schema:{events:{default:""},delay:{default:0},duration:{default:1},direction:{default:"forward",oneOf:["forward","backward","alternate"]},loops:{default:-1},seed:{default:-1,type:"int"},easing:{default:"linear",oneOf:Object.keys(ct)},randomizeEachLoop:{default:!0},enabled:{default:!0},debug:{default:!1},bubbles:{default:!1}},multiple:!0,init(){this.startKeyframes=this.startKeyframes.bind(this),this.lcg=p(),this.loopTime=0,this.loops=0,this.keys={},this.rules={},this.isStarted=!1,this.eventListener=ne(this.el,this.onEvent.bind(this)),this.delayClock=ee()},remove(){this.eventListener.remove(),this.delayClock.clearAllTimers()},play(){this.eventListener.add(),this.delayClock.resume()},pause(){this.eventListener.remove(),this.delayClock.pause()},updateSchema(e){"object"!=typeof e&&console.error(`invalid properties, expected format <property>:<value>; '${e}'`);const t=AFRAME.components[this.name].schema;let n={};for(let i in e)i in t||(n[i]={type:"string"});Object.keys(n).length>0&&this.extendSchema(n)},update(e){const t=this.data,n=AFRAME.components[this.name].schema;e.seed!==t.seed&&this.lcg.setSeed(t.seed);for(let e in this.rules)e in t||(delete this.rules[e],delete this.keys[e]);for(let i in t)if(e[i]!==t[i]&&!(i in n)){const e=t[i];this.rules[i]=e.split(",").map(e=>R(e))}if(e.duration===t.duration&&e.loops===t.loops||(this.loopTime=0,this.loops=0),e.direction!==t.direction&&(this.forward="backward"!==t.direction,this.loopTime=this.forward?0:t.duration),this.generateKeys(!0),this.isComplete()?this.el.sceneEl.removeBehavior(this):this.el.sceneEl.addBehavior(this),t.duration<=0)for(let e in this.keys)K(this.el,e,this.keys[e][0]);t.events!==e.events&&this.eventListener.set(t.events),t.events||t.delay===e.delay||this.delayClock.startTimer(t.delay,this.startKeyframes)},tick(e,t){if(this.data.enabled){const e=Math.min(t,100)/1e3;this.step(e)}},step(e){const t=this.data,n=this.isComplete();if(!n&&this.isStarted){let n=!1;this.loopTime=this.loopTime+(this.forward?e:-e),(this.loopTime>t.duration||this.loopTime<0)&&(this.loops++,n=!0),n&&(t.loops<0||this.loops<t.loops)&&("alternate"===t.direction?(this.forward=!this.forward,this.loopTime=this.loopTime<0?-this.loopTime:2*t.duration-this.loopTime):this.loopTime=this.loopTime+(this.forward?-t.duration:t.duration),t.randomizeEachLoop&&this.generateKeys(!1));const i=ct[t.easing]||ct.linear;for(let e in this.keys){let n=THREE.Math.clamp(this.loopTime/t.duration,0,1);const a=nn(this.keyTypes[e],this.keys[e],n,i);K(this.el,e,a)}}else this.el.sceneEl.removeBehavior(this);this.isStarted&&n&&(this.sendEvent("keyframeend",{name:this.attrName}),this.isStarted=!1)},startKeyframes(){this.isStarted||(this.isStarted=!0,this.el.sceneEl.addBehavior(this),this.sendEvent("keyframestart",{name:this.attrName}))},isComplete(){const e=this.data;return e.duration<=0||e.loops>0&&this.loops>e.loops},generateKeys(e){let t;this.keys={},this.keyTypes={};for(let n in this.rules){this.keys[n]=[];for(let i=0,a=this.rules[n].length;i<a;i++){const s=this.forward?i:a-1-i,r=this.rules[n][s];if(e){const e=r.range&&r.range.includes(""),a=r.options&&r.options.includes("");if(e||a){let s=0==i?C(an(this.el,n)):t;e&&(r.range=r.range.map(e=>""===e?s:e)),a&&(r.options=r.options.map(e=>""===e?s:e))}}t=U(r,this.lcg.random),this.keys[n][s]=t,this.keyTypes[n]=this.keyTypes[n]||typeof t}}},sendEvent(e,t){this.data.debug&&console.log(Z(this.el),this.attrName,"send",e,t,this.data.bubbles),this.el.emit(e,t,this.data.bubbles)},onEvent(e){this.data.debug&&console.log(Z(this.el),this.attrName,"onEvent",e.type),this.delayClock.startTimer(this.data.delay,this.startKeyframes)}});const sn=THREE.Math.degToRad;AFRAME.registerComponent("lathe",{schema:{shape:{default:""},steps:{type:"int",default:1},segments:{type:"int",default:12},phiStart:{default:0},phiEnd:{default:360}},update(){const e=this.data,t=It(e.shape).extractPoints(e.steps).shape,n=new THREE.LatheBufferGeometry(t,e.segments,sn(e.phiStart),sn(e.phiEnd)),i=new THREE.Mesh(n,new THREE.MeshBasicMaterial);this.el.setObject3D("mesh",i)}});const rn={error:"red",warn:"yellow",log:"white",info:"grey"};function on(e){if(0===e.length)return"";let t=1;return e[0].toString().replace(/%(\.(\d+))?([cdfios])/g,(n,i,a,s)=>{let r;switch(s){case"c":return t++,"";case"d":case"i":return r=parseInt(e[t++],10),a?r.toString().padStart(a,"0"):r;case"f":return r=parseFloat(e[t++]),a?r.toFixed(a):r;case"o":return"[object]";case"s":return e[t++]}})+(t<e.length?" "+e.slice(t).join(" "):"")}function ln(e){return e.toLowerCase()}AFRAME.registerSystem("logger",{init(){this.loggers=[],this.isLogging=!1},remove(){this.releaseLogs(),console.assert(0===this.loggers.length)},captureLogs(){this.oldLog=console.log,this.oldError=console.error,this.oldWarn=console.warn,this.oldInfo=console.info,console.log=((...e)=>{this.sendToLogger("log",on(e)),this.oldLog(...e)}),console.error=((...e)=>{this.sendToLogger("error",on(e)),this.oldError(...e)}),console.warn=((...e)=>{this.sendToLogger("warn",on(e)),this.oldWarn(...e)}),console.info=((...e)=>{this.sendToLogger("info",on(e)),this.oldInfo(...e)})},releaseLogs(){console.log=this.oldLog,console.error=this.oldError,console.warn=this.oldWarn,console.info=this.oldInfo},sendToLogger(e,t){if(!this.isLogging){this.isLogging=!0;for(let n of this.loggers)n.showMessage(e,t);this.isLogging=!1}},registerLogger(e){this.loggers.push(e),1===this.loggers.length&&this.captureLogs()},unregisterLogger(e){this.loggers.splice(this.loggers.indexOf(e),1),0===this.loggers.length&&this.releaseLogs()}}),AFRAME.registerComponent("logger",{schema:{maxLines:{default:20},offset:{type:"vec2",default:{x:2,y:2}},lineHeight:{default:12},columnWidth:{default:80},characterWidth:{default:7.3},types:{type:"array",default:["log","error","warn"]},filter:{default:""},font:{default:"1em monospace"}},init(){this.dirty=!0,this.messages=[],this.onObject3DSet=this.onObject3DSet.bind(this),this.system.registerLogger(this),this.createTexture(),this.el.addEventListener("object3dset",this.onObject3DSet)},remove(){this.el.removeEventListener("object3dset",this.onObject3DSet),this.system.unregisterLogger(this)},update(e){const t=this.data;e.filter!==t.filter&&(this.filter=t.filter?new RegExp(t.filter):void 0)},tick(){this.dirty&&this.imageEl.isReady&&this.updateTexture()},createTexture(){this.imageEl=document.createElement("img"),this.imageEl.width=512,this.imageEl.height=512,this.imageEl.isReady=!0;const e=this.texture=new THREE.Texture(this.imageEl);this.imageEl.onload=(()=>{e.needsUpdate=!0}),this.imageEl.onerror=(()=>{e.image.isReady=!0}),e.onUpdate=(()=>{e.image.isReady=!0}),this.showTexture()},updateTexture(){const e=this.imageEl,t=this.data,n=t.columnWidth*t.characterWidth,i=(t.maxLines+1)*t.lineHeight;const a="data:image/svg+xml;utf8,"+function(e){return e.replace(/%/g,"%25").replace(/#/g,"%23")}(`<svg viewBox="0 0 ${n} ${i}" preserveAspectRatio="none" xmlns="http://www.w3.org/2000/svg" version="1.1">\n      <rect x="0" y="0" width="${n}" height="${i}" fill="#111"/>\n      <style> text { font: ${t.font}; }></style>\n      ${this.messages.map((e,n)=>{const i=t.offset.y+t.lineHeight*(n+1),a=t.offset.x,s=e[1].replace(/[^\x20-\x7E\n\t]/g,"").replace(/[&<>'"]/g,e=>"&"===e?"&amp;":"<"===e?"&lt;":">"===e?"&gt;":"'"===e?"&apos;":"&quot;");return`<text x="${a}" y="${i}" fill="${rn[e[0]]}">${s}</text>`}).join("\n")}\n    </svg>`);e.src=a,e.isReady=!1,this.dirty=!1},showTexture(){const e=this.el.getObject3D("mesh");e&&e.material&&(e.material.map=this.texture)},showMessage(e,t){const n=this.data;if(!n.types.includes(e))return;if(this.filter&&!this.filter.test(t))return;const i=t.split("\n");for(let t of i)for(let i=0,a=t.length;i<a;i+=n.columnWidth)this.messages.push([e,t.slice(i,Math.min(a,i+n.columnWidth))]);for(;this.messages.length>=this.data.maxLines;)this.messages.shift();this.dirty=!0},onObject3DSet(e){this.showTexture()}}),AFRAME.registerPrimitive("a-logger",{defaultComponents:{geometry:{primitive:"plane",height:3,width:3},material:{color:"white",shader:"flat",side:"double"},logger:{}},mappings:{types:"logger.types",filter:"logger.filter"}}),AFRAME.registerComponent("manipulate",{schema:{hands:{type:"selectorAll"},oneHanded:{default:"grab"},twoHanded:{default:"grab, uniformscale",parse:ln},pivot:{type:"vec3",default:{x:0,y:0,z:0}},startEvent:{default:"triggerdown",parse:ln},endEvent:{default:"triggerup",parse:ln},enabled:{default:!0},debug:{default:!1}},init(){this.onStartEvent=this.onStartEvent.bind(this),this.onEndEvent=this.onEndEvent.bind(this),this.isEnabled=!1,this.sides=[],this.activeSides=[],this.capture={object3D:void 0,startPosition:new THREE.Vector3,startQuaternion:new THREE.Quaternion,startScale:new THREE.Vector3,handGap:new THREE.Vector3,startGap:new THREE.Vector3,invPivotMatrix:new THREE.Matrix4,startWorldPosition:new THREE.Vector3,pivotPos:new THREE.Vector3,pivotQuat:new THREE.Quaternion}},update(e){const t=this.data;if(t.hands!==e.hands&&(this.sides.length=0,t.hands))for(let e=0;e<t.hands.length;e++)this.sides.push({handEl:t.hands[e],grabPosition:new THREE.Vector3});this.oneHanded=this.parseConstraints(t.oneHanded),this.twoHanded=this.parseConstraints(t.twoHanded),e.enabled!==t.enabled&&(t.enabled?this.enable():this.disable())},play(){this.data.enabled&&this.enable()},pause(){this.disable()},tick(){1===this.activeSides.length?this.tickOneHanded(this.activeSides[0]):2===this.activeSides.length&&this.tickTwoHanded(this.activeSides)},enable(){if(!this.isEnabled){for(let e of this.sides)this.addListeners(e.handEl);this.isEnabled=!0}},disable(){if(this.isEnabled){this.activeSides.length=0;for(let e of this.sides)this.removeListeners(e.handEl);this.isEnabled=!1}},onStartEvent(e){this.data.debug&&console.log(oe(this),"onStartEvent",e.type,Z(e.target));for(let t of this.sides)e.target===t.handEl&&this.activateSide(t)},onEndEvent(e){this.data.debug&&console.log(oe(this),"onEndEvent",e.type,Z(e.target));for(let t of this.sides)e.target===t.handEl&&this.deactivateSide(t)},addListeners(e){e&&(this.data.startEvent||this.data.endEvent)&&(this.data.debug&&console.log(oe(this),"addListeners",this.data.startEvent,this.data.endEvent,Z(e)),e.addEventListener(this.data.startEvent,this.onStartEvent),e.addEventListener(this.data.endEvent,this.onEndEvent))},removeListeners(e){e&&(this.data.startEvent||this.data.endEvent)&&(this.data.debug&&console.log(oe(this),"removeListeners",this.data.startEvent,this.data.endEvent,Z(e)),e.removeEventListener(this.data.startEvent,this.onStartEvent),e.removeEventListener(this.data.endEvent,this.onEndEvent))},activateSide(e){-1===this.activeSides.indexOf(e)&&(this.activeSides.push(e),this.captureStartPositions())},deactivateSide(e){const t=this.activeSides.indexOf(e);-1!==t&&(this.activeSides.splice(t,1),this.captureStartPositions())},captureStartPositions:function(){const e=new THREE.Matrix4,t=new THREE.Vector3(1,1,1);return function(){const n=this.data,i=n.target?n.target.object3D:this.el.object3D;if(this.capture.object3D=i,i){for(let e of this.activeSides)e.handEl.object3D.getWorldPosition(e.grabPosition);i.updateMatrixWorld(),this.capture.startWorldPosition.copy(n.pivot).applyMatrix4(i.matrixWorld),this.capture.startPosition.copy(i.position),this.capture.startQuaternion.copy(i.quaternion),this.capture.startScale.copy(i.scale);const a=this.activeSides.length;if(a>=2){const n=this.activeSides[0].handEl.object3D,a=this.activeSides[1].handEl.object3D;this.capture.handGap.copy(a.position).sub(n.position),this.calcMatrixFromHands(this.capture.pivotPos,this.capture.pivotQuat,n.position,n.quaternion,a.position,a.quaternion),e.compose(this.capture.pivotPos,this.capture.pivotQuat,t),e.getInverse(e),this.capture.startGap.copy(a.position).applyMatrix4(e).normalize(),this.capture.invPivotMatrix.copy(e).multiply(i.matrix)}else if(1===a){const e=this.activeSides[0].handEl.object3D;this.capture.invPivotMatrix.getInverse(e.matrixWorld).multiply(i.matrixWorld)}}else se(`unable to find Object3D for '${n.target}'`)}}(),tickOneHanded:function(){const e=new THREE.Vector3,t=new THREE.Vector3,n=new THREE.Vector3,i=new THREE.Vector3(1,1,1),a=new THREE.Quaternion,s=new THREE.Matrix4,r=new THREE.Matrix4;return function(o){const l=this.capture.object3D;if(l){const c=o.handEl.object3D;if(c.updateMatrixWorld(),l.parent.updateMatrixWorld(!0),t.copy(o.grabPosition).sub(this.capture.startWorldPosition),c.getWorldPosition(n).sub(this.capture.startWorldPosition),this.oneHanded.uniformScale){const e=n.length()/t.length();i.set(e,e,e),l.scale.copy(i.multiply(this.capture.startScale))}this.oneHanded.scale&&(i.copy(n).divide(t),this.applyMask(i,this.oneHanded.scale,1),l.scale.copy(i.multiply(this.capture.startScale))),this.oneHanded.translate&&(c.getWorldPosition(e).sub(o.grabPosition),this.applyMask(e,this.oneHanded.translate,0),l.position.copy(e.add(this.capture.startPosition))),this.oneHanded.rotate&&(this.applyMask(t,this.oneHanded.rotate,0),this.applyMask(n,this.oneHanded.rotate,0),a.setFromUnitVectors(t.normalize(),n.normalize()),l.quaternion.copy(a.multiply(this.capture.startQuaternion))),this.oneHanded.grab&&(s.getInverse(l.parent.matrixWorld),r.multiplyMatrices(c.matrixWorld,this.capture.invPivotMatrix),r.premultiply(s),r.decompose(l.position,l.quaternion,l.scale))}}}(),tickTwoHanded:function(){const e=new THREE.Vector3,t=new THREE.Vector3,n=new THREE.Vector3,i=new THREE.Vector3,a=new THREE.Vector3,s=new THREE.Vector3,r=new THREE.Vector3(1,1,1),o=new THREE.Vector3,l=new THREE.Quaternion,c=new THREE.Matrix4,d=new THREE.Quaternion,h=new THREE.Matrix4,u=new THREE.Vector3(1,1,1);return function(){const m=this.capture.object3D;if(m){const p=this.activeSides[0].handEl.object3D,f=this.activeSides[1].handEl.object3D;if(e.copy(p.position),t.copy(f.position),n.copy(t).sub(e),this.calcMatrixFromHands(s,d,p.position,p.quaternion,f.position,f.quaternion),c.compose(s,d,u),this.twoHanded.uniformScale){const e=n.length()/this.capture.handGap.length();r.set(e,e,e),m.scale.copy(r.multiply(this.capture.startScale))}this.twoHanded.scale&&(r.copy(n).divide(this.capture.handGap),this.applyMask(r,this.twoHanded.scale,1),m.scale.copy(r.multiply(this.capture.startScale))),this.twoHanded.translate&&(o.copy(s).sub(this.capture.pivotPos),this.applyMask(o,this.twoHanded.translate,0),m.position.copy(o.add(this.capture.startPosition))),this.twoHanded.rotate&&(i.copy(this.capture.handGap),this.applyMask(i,this.twoHanded.rotate,0),this.applyMask(n,this.twoHanded.rotate,0),l.setFromUnitVectors(i.normalize(),n.normalize()),m.quaternion.copy(l.multiply(this.capture.startQuaternion))),this.twoHanded.grab&&(h.getInverse(c),a.copy(t).applyMatrix4(h).normalize(),l.setFromUnitVectors(this.capture.startGap,a),d.multiply(l),c.compose(s,d,u),c.multiply(this.capture.invPivotMatrix),c.decompose(s,d,r),m.position.copy(s),m.quaternion.copy(d))}}}(),calcMatrixFromHands(e,t,n,i,a,s){e.copy(n).add(a).multiplyScalar(.5),t.copy(i).slerp(s,.5)},parseConstraints(e){let t={},n=e.split(",").map(e=>e.trim());for(let e of n)switch(e){case"translate":t.translate={x:!0,y:!0,z:!0};break;case"translate-x":t.translate={...t.translate,x:!0};break;case"translate-y":t.translate={...t.translate,y:!0};break;case"translate-z":t.translate={...t.translate,z:!0};break;case"rotate":t.rotate={x:!0,y:!0,z:!0};break;case"rotate-x":t.rotate={x:!1,y:!0,z:!0};break;case"rotate-y":t.rotate={x:!0,y:!1,z:!0};break;case"rotate-z":t.rotate={x:!0,y:!0,z:!1};break;case"scale":t.scale={x:!0,y:!0,z:!0};break;case"scale-x":t.scale={...t.scale,x:!0};break;case"scale-y":t.scale={...t.scale,y:!0};break;case"scale-z":t.scale={...t.scale,z:!0};break;case"uniformscale":t.uniformScale=!0;break;case"grab":t.grab=!0;break;case"":case"none":break;default:se(this,`unknown constraint: ${e}`)}return t},applyMask(e,t,n){for(let i of["x","y","z"])e[i]=t[i]?e[i]:n}}),function(){var e=AFRAME.utils.debug("components:materialx:error"),t=AFRAME.shaders;function n(e,t){e.dispose(),t.unregisterMaterial(e)}function i(e,t,n,i){var a=!1;if(i.length=0,0===n.length)return!0;if(""===t){(s=e.getObject3D("mesh"))&&s.material&&(i.push(s.material),s.material=n[0],a=!0)}else{var s=e.object3D,r=t.replace(/[\.\{\}\(\)\^\[\]\$]/g,"\\$&").replace(/[\*\?]/g,".$&"),o=new RegExp("^"+r+"$"),l=0;s&&s.traverse(function(e){if(e&&e.material)if(a=!0,Array.isArray(e.material))for(var t=0,s=e.material.length;t<s;t++)o.test(e.material[t].name)&&(i.push(e.material[t]),e.material[t]=n[l],l=(l+1)%n.length);else o.test(e.material.name)&&(i.push(e.material),e.material=n[l],l=(l+1)%n.length)})}return a}AFRAME.registerComponent("materialx",{schema:{alphaTest:{default:0,min:0,max:1},depthTest:{default:!0},depthWrite:{default:!0},flatShading:{default:!1},name:{default:""},npot:{default:!1},offset:{type:"vec2",default:{x:0,y:0}},opacity:{default:1,min:0,max:1},remap:{default:""},repeat:{type:"vec2",default:{x:1,y:1}},shader:{default:"standard",oneOf:Object.keys(AFRAME.shaders),schemaChange:!0},side:{default:"front",oneOf:["front","back","double"]},transparent:{default:!1},vertexColors:{type:"string",default:"none",oneOf:["none","face","vertex"]},visible:{default:!0},blending:{default:"normal",oneOf:["none","normal","additive","subtractive","multiply"]}},multiple:!0,init:function(){this.system=this.el.sceneEl.systems.material,this.material=null,this.oldMaterials=[],this.onObject3DSet=this.onObject3DSet.bind(this),this.el.addEventListener("object3dset",this.onObject3DSet)},update:function(e){var t=this.data;this.shader&&t.shader===e.shader||(i(this.el,e.remap,this.oldMaterials,[]),this.updateShader(t.shader)),this.shader.update(this.data),this.updateMaterial(e)},updateSchema:function(n){var i,a,s,r;"string"==typeof n&&e(`invalid properties, expected format <property>:<value>; '${n}'`),a=n&&n.shader,i=this.oldData&&this.oldData.shader,(s=t[r=a||i]&&t[r].schema)||e("Unknown shader schema "+r),i&&a===i||(this.extendSchema(s),this.updateBehavior())},updateBehavior:function(){var e,t,n=this.el.sceneEl,i=this.schema,a=this;function s(e,n){var i;for(i in t)t[i]=e;a.shader.update(t)}for(e in this.tick=void 0,t={},i)"time"===i[e].type&&(this.tick=s,t[e]=!0);n&&(this.tick?n.addBehavior(this):n.removeBehavior(this))},updateShader:function(e){var n,i=this.data,a=t[e]&&t[e].Shader;if(!a)throw new Error("Unknown shader "+e);(n=this.shader=new a).el=this.el,n.init(i),this.setMaterial(n.material),this.updateSchema(i)},updateMaterial:function(e){var t,n=this.data,i=this.material;for(t in i.alphaTest=n.alphaTest,i.depthTest=!1!==n.depthTest,i.depthWrite=!1!==n.depthWrite,i.name=n.name,i.opacity=n.opacity,i.flatShading=n.flatShading,i.side=function(e){switch(e){case"back":return THREE.BackSide;case"double":return THREE.DoubleSide;default:return THREE.FrontSide}}(n.side),i.transparent=!1!==n.transparent||n.opacity<1,i.vertexColors=function(e){switch(e){case"face":return THREE.FaceColors;case"vertex":return THREE.VertexColors;default:return THREE.NoColors}}(n.vertexColors),i.visible=n.visible,i.blending=function(e){switch(e){case"none":return THREE.NoBlending;case"additive":return THREE.AdditiveBlending;case"subtractive":return THREE.SubtractiveBlending;case"multiply":return THREE.MultiplyBlending;default:return THREE.NormalBlending}}(n.blending),e)break;!t||e.alphaTest===n.alphaTest&&e.side===n.side&&e.vertexColors===n.vertexColors||(i.needsUpdate=!0)},remove:function(){this.el.removeEventListener("object3dset",this.onObject3DSet);var e=this.material;i(this.el,this.data.remap,this.oldMaterials,[]),this.oldMaterials.length=0,n(e,this.system)},setMaterial:function(e){var t=this.el,a=this.system;this.material&&n(this.material,a),this.material=e,a.registerMaterial(e),i(t,this.data.remap,[e],this.oldMaterials)},onObject3DSet(e){"mesh"===e.detail.type&&e.target===this.el&&i(this.el,this.data.remap,[this.material],this.oldMaterials)}})}(),AFRAME.registerComponent("merge-geometry",{dependencies:["material"],schema:{keepColor:{default:!0},keepOriginal:{default:!1}},init(){this.mergeGeometry()},mergeGeometry(){const e=this,t=new THREE.Geometry,n=new THREE.Matrix4,i=this.el.object3D;i.updateMatrixWorld(!0),n.getInverse(i.matrixWorld),i.traverse(function(i){if("Mesh"!==i.type)return;const a=i.geometry.isBufferGeometry?(new THREE.Geometry).fromBufferGeometry(i.geometry):i.geometry;if(e.data.keepColor){const e=Array.isArray(i.material)?i.material[0].color:i.material.color;a.faces.forEach(t=>{3===t.vertexColors.length?(t.vertexColors[0].multiply(e),t.vertexColors[1].multiply(e),t.vertexColors[2].multiply(e)):t.color.multiply(e)})}const s=i.matrixWorld.clone().premultiply(n);t.merge(a,s),e.data.keepOriginal||i.parent.remove(i)});const a=new THREE.Mesh((new THREE.BufferGeometry).fromGeometry(t));if(this.el.setObject3D("mesh",a),e.data.keepColor){this.el.getObject3D("mesh").material.vertexColors=THREE.VertexColors}}});const cn=2*Math.PI,dn=.5*Math.PI,hn=new THREE.Vector3(0,1,0),un=THREE.Math.degToRad;function mn(e){return{x:un(e.x),y:un(e.y),z:un(e.z)}}function pn(e){return e.options?Math.max(...e.options):Math.max(...e.range)}function fn(e){return"number"==typeof e}function gn(e){return"object"==typeof e&&"x"in e&&"y"in e&&"z"in e}function vn(e){return"object"==typeof e&&"r"in e&&"g"in e&&"b"in e}function yn(e,t){return e.range?e.range.every(t):!!e.options&&e.options.every(t)}function bn(e){if(!e)return;const t=W(e).flatMap(e=>R(e));if(t.every(e=>yn(e,gn)))return t;se(`unrecognized array of vec3 range options '${e}'`)}function En(e){if(!e)return;const t=W(e).flatMap(e=>R(e));if(t.every(e=>yn(e,fn)))return t;se(`unrecognized array of float range options '${e}'`)}function xn(e){return"number"==typeof e?{x:e,y:e,z:e}:e}const Tn={position:bn,velocity:bn,acceleration:bn,radialPosition:En,radialVelocity:En,radialAcceleration:En,angularVelocity:bn,angularAcceleration:bn,orbitalVelocity:En,orbitalAcceleration:En,scale:function(e){if(!e)return;const t=W(e).flatMap(e=>R(e));if(t.every(e=>yn(e,gn)||yn(e,fn)))return t.map(e=>e.range?{range:e.range.map(xn)}:e.options?{options:e.options.map(xn)}:void 0);se(`unrecognized array of float or vec3 range options '${e}'`)},color:function(e){if(!e)return;const t=W(e.toLowerCase()).flatMap(e=>R(e));if(t.every(e=>yn(e,vn)))return t;se(`unrecognized array of color range options '${e}'`)},rotation:bn,opacity:En};AFRAME.registerComponent("mesh-particles",{schema:{events:{default:""},delay:{default:0},enabled:{default:!0},duration:{default:-1},instancePools:{default:""},spawnRate:{default:"1"},lifeTime:{default:"1"},position:{default:""},velocity:{default:""},acceleration:{default:""},radialType:{default:"circle",oneOf:["circle","sphere","circlexy","circleyz","circlexz"],parse:e=>e.toLowerCase()},radialPosition:{default:""},radialVelocity:{default:""},radialAcceleration:{default:""},angularVelocity:{default:""},angularAcceleration:{default:""},orbitalVelocity:{default:""},orbitalAcceleration:{default:""},scale:{default:""},color:{default:""},rotation:{default:""},opacity:{default:""},source:{type:"string"},destination:{type:"string"},destinationOffset:{type:"vec3"},destinationWeight:{type:"number"},seed:{type:"int",default:-1}},multiple:!0,init(){this.startParticles=this.startParticles.bind(this),this.onEvent=this.onEvent.bind(this),this.isStarted=!1,this.hasListeners=!1,this.spawnID=0,this.spawnCount=0,this.instancePools=[],this.instanceIndices=[],this.particles=[],this.customData={},this.lcg=p(),this.delayClock=ee(),this.eventListener=ne(this.el,this.onEvent)},remove(){this.releaseInstances(),this.eventListener.remove(),this.delayClock.clearAllTimers(),this.source=void 0,this.destination=void 0},play(){this.eventListener.add(),this.delayClock.resume()},pause(){this.eventListener.remove(),this.delayClock.pause()},update(e){const t=this.data;this.lcg.setSeed(t.seed),this.duration=t.duration;for(let n in t)e[n]!==t[n]&&n in Tn&&(this.customData[n]=Tn[n](t[n]));if(t.lifeTime!==e.lifeTime&&(this.lifeTimeRule=R(t.lifeTime),this.maxLifeTime=pn(this.lifeTimeRule),this.particles=[]),t.source!==e.source&&(this.source=this.el.object3D,t.source)){const e=document.querySelector(t.source);e&&e.object3D?this.source=e.object3D:se(`unable to find object3D on source '${t.source}'`)}if(t.destination!==e.destination&&(this.destination=void 0,t.destination)){const e=document.querySelector(t.destination);e&&e.object3D?this.destination=e.object3D:se(`unable to find object3D on destination '${t.destination}'`)}t.spawnRate===e.spawnRate&&t.lifeTime===e.lifeTime||(this.spawnRateRule=R(t.spawnRate),this.maxParticles=pn(this.spawnRateRule)*this.maxLifeTime,this.spawnRate=U(this.spawnRateRule,this.lcg.random)),t.instancePools===e.instancePools&&t.spawnRate===e.spawnRate&&t.lifeTime===e.lifeTime||(this.spawnID=0,this.releaseInstances(),this.instancePools=t.instancePools?[].slice.call(document.querySelectorAll(t.instancePools)).map(e=>e.components?e.components["instance-pool"]:void 0).filter(e=>e):this.el.components["instance-pool"]?[this.el.components["instance-pool"]]:[],0===this.instancePools.length?t.instancePools?se(`no 'instance-pool' on the entities: '${t.instancePools}'`):se("no 'instance-pool' component on this element"):(this.instanceIndices=this.instancePools.map(e=>e.reserveBlock(Math.ceil(this.maxParticles/this.instancePools.length))),this.instanceIndices.forEach((e,t)=>{void 0===e&&se(`unable to reserve blocks for instance '${this.instancePools[t].el.id}'`)}))),t.events!==e.events&&(this.eventListener.set(t.events),t.events||(this.startTime=t.delay,this.startParticles()))},tick(e,t){const n=.001*e,i=Math.min(.1,.001*t),a=this.duration<0||n-this.startTime<this.duration;if(this.isStarted&&a&&this.instancePools.length>0&&this.data.enabled)for(this.spawnCount+=this.spawnRate*i,this.spawnCount>1&&(this.spawnRate=U(this.spawnRateRule,this.lcg.random));this.spawnCount>1;)this.spawn(),this.spawnCount--;else this.isStarted&&!a&&this.stopParticles();this.move(i)},onEvent(e){this.delayClock.startTimer(this.delay,this.startParticles)},startParticles(){this.isStarted=!0,this.startTime=this.el.sceneEl.clock.elapsedTime},stopParticles(){this.isStarted=!1},releaseInstances(){this.instancePools.forEach((e,t)=>e.releaseBlock(this.instanceIndices[t])),this.instanceIndices.length=0,this.particles=[],this.spawnID=0,this.spawnCount=0},configureRandomizer(e){this.data.seed>0&&(this.lcg.setSeed(e+1),this.lcg.setSeed(this.data.seed+12783891*this.lcg.random()))},instanceFromID(e){const t=e%this.maxParticles,n=e%this.instancePools.length,i=this.instancePools[n];return void 0===this.instanceIndices[n]?[void 0,void 0,void 0]:[i,this.instanceIndices[n]+Math.floor(t/this.instancePools.length),t]},spawn(){const e=this.data,t=this.customData,n=this.lcg.random;this.configureRandomizer(this.spawnID);const i={age:0};i.col=new THREE.Color,i.col.a=1,i.pos=new THREE.Vector3(0,0,0),i.vel=new THREE.Vector3(0,0,0),i.acc=new THREE.Vector3(0,0,0),i.angularVel=new THREE.Vector3(0,0,0),i.angularAcc=new THREE.Vector3(0,0,0),i.orbitalVel=0,i.orbitalAcc=0,this.source&&(i.sourcePosition=new THREE.Vector3,i.sourceQuaternion=new THREE.Quaternion,i.sourceScale=new THREE.Vector3,this.source.matrixWorld.decompose(i.sourcePosition,i.sourceQuaternion,i.sourceScale)),i.lifeTime=U(this.lifeTimeRule,n),i.radialPhi="circlexz"!==e.radialType?2*Math.acos(2*n()-1):dn,i.radialTheta="circleyz"===e.radialType?0:"circle"===e.radialType||"circlexy"===e.radialType?dn:n()*cn,t.position&&(i.positions=t.position.map(e=>U(e,n))),t.rotation&&(i.rotations=t.rotation.map(e=>mn(U(e,n)))),t.scale&&(i.scales=t.scale.map(e=>U(e,n))),t.color&&(i.colors=t.color.map(e=>U(e,n))),t.opacity&&(i.opacities=t.opacity.map(e=>U(e,n))),t.velocity&&(i.velocities=t.velocity.map(e=>U(e,n))),t.acceleration&&(i.accelerations=t.acceleration.map(e=>U(e,n))),t.radialPosition&&(i.radialPositions=t.radialPosition.map(e=>U(e,n))),t.radialVelocity&&(i.radialVelocities=t.radialVelocity.map(e=>U(e,n))),t.radialAcceleration&&(i.radialAccelerations=t.radialAcceleration.map(e=>U(e,n))),t.angularVelocity&&(i.angularVelocities=t.angularVelocity.map(e=>mn(U(e,n)))),t.angularAcceleration&&(i.angularAccelerations=t.angularAcceleration.map(e=>mn(U(e,n)))),t.orbitalVelocity&&(i.orbitalVelocities=t.orbitalVelocity.map(e=>un(U(e,n)))),t.orbitalAcceleration&&(i.orbitalAccelerations=t.orbitalAcceleration.map(e=>un(U(e,n)))),i.orbitalAxis=new THREE.Vector3;const a=this.spawnID%this.maxParticles;this.particles[a]=i,this.spawnID++},move:function(){const e=new THREE.Vector3(0,0,0),t=new THREE.Euler(0,0,0,"YXZ"),n=new THREE.Quaternion(0,0,0,1),i=new THREE.Vector3(1,1,1),a=new THREE.Color(0,0,0),s=new THREE.Vector3(0,0,0);return function(r){const o=this.data;for(let l=Math.max(0,this.spawnID-this.maxParticles);l<this.spawnID;l++){const[c,d,h]=this.instanceFromID(l);if(void 0===c)continue;const u=this.particles[h],m=u.age/u.lifeTime,p=0===m;let f=!1,g=!1;if(m>1){c.setScaleAt(d,{x:0,y:0,z:0});continue}const v=u.age;if(u.age+=r,u.positions&&(p||u.positions.length>1)&&u.pos.copy(this.lerpVector(u.positions,m)),u.radialPositions&&(p||u.radialPositions.length>1)&&u.pos.setFromSphericalCoords(this.lerpFloat(u.radialPositions,m),u.radialPhi,u.radialTheta),u.accelerations&&(p||u.accelerations.length>1)&&u.acc.copy(this.lerpVector(u.accelerations,m)),u.radialAccelerations&&(p||u.radialAccelerations.length>1)&&u.acc.setFromSphericalCoords(this.lerpFloat(u.radialAccelerations,m),u.radialPhi,u.radialTheta),u.velocities&&(p||u.velocities.length>1)&&u.vel.copy(this.lerpVector(u.velocities,m)),u.radialVelocities&&(p||u.radialVelocities.length>1)&&u.vel.setFromSphericalCoords(this.lerpFloat(u.radialVelocities,m),u.radialPhi,u.radialTheta),u.accelerations||u.radialAccelerations||u.velocities||u.radialVelocities?(e.copy(u.acc).multiplyScalar(.5*v).add(u.vel).multiplyScalar(v).add(u.pos),f=!0):u.positions||u.radialPositions?e.copy(u.pos):e.set(0,0,0),u.orbitalAccelerations&&(p||u.orbitalAccelerations.length>1)&&(u.orbitalAcc=this.lerpFloat(u.orbitalAccelerations,m)),u.orbitalVelocities&&(p||u.orbitalVelocities.length>1)&&(u.orbitalVel=this.lerpFloat(u.orbitalVelocities,m)),u.orbitalAccelerations||u.orbitalVelocities){p&&u.orbitalAxis.copy(s.copy(u.pos).normalize().cross(hn).normalize());const t=(u.orbitalVel+.5*v*u.orbitalAcc)*v;n.setFromAxisAngle(u.orbitalAxis,t),e.applyQuaternion(n),f=!0}u.angularAccelerations&&(p||u.angularAccelerations.length>1)&&u.angularAcc.copy(this.lerpVector(u.angularAccelerations,m)),u.angularVelocities&&(p||u.angularVelocities.length>1)&&u.angularVel.copy(this.lerpVector(u.angularVelocities,m)),(u.angularAccelerations||u.angularVelocities)&&(s.copy(u.angularAcc).multiplyScalar(.5*v).add(u.angularVel).multiplyScalar(v),t.set(s.x,s.y,s.z,"YXZ"),n.setFromEuler(t),e.applyQuaternion(n),f=!0),(p||f||this.destination)&&(e.add(u.sourcePosition),this.destination&&(s.copy(o.destinationOffset).applyMatrix4(this.destination.matrixWorld),e.copy(Xe(e,s,o.destinationWeight*m))),c.setPositionAt(d,e.x,e.y,e.z)),u.opacities&&(p||u.opacities.length>1)&&(u.col.a=this.lerpFloat(u.opacities,m),g=!0),u.colors&&(p||u.colors.length>1)&&(a.copy(this.lerpVector(u.colors,m)),u.col.setRGB(a.r,a.g,a.b),g=!0),(p||g)&&c.setColorAt(d,u.col.r,u.col.g,u.col.b,u.col.a),u.rotations&&(p||u.rotations.length>1)&&(u.rotations.length>0?(t.setFromVector3(this.lerpVector(u.rotations,m)),n.setFromEuler(t),n.premultiply(u.sourceQuaternion)):n.copy(u.sourceQuaternion),c.setQuaternionAt(d,n.x,n.y,n.z,n.w)),u.scales&&(p||u.scales.length>1)&&(i.copy(u.sourceScale),u.scales.length>0&&i.multiply(s.copy(this.lerpVector(u.scales,m))),c.setScaleAt(d,i.x,i.y,i.z)),!u.scales&&p&&c.setScaleAt(d,1,1,1)}}}(),lerpFloat(e,t){const[n,i]=Ze(e,t);return Ye(e[n],e[n+1],i)},lerpVector(e,t){const[n,i]=Ze(e,t);return Xe(e[n],e[n+1],i)}});const wn=function(e=((e,t)=>void 0),t=w){const n=new Map;let i=[];function a(e,t,n){e.length=0;for(let i=0,a=0;i<t.length;i++){const s=t[i];if(s.attribute===n)if(e[a]=i,s.mode===X)a++;else if(s.mode===Y&&s.source!==Q)break}return e}return{set:function(s,r,o,l,c=$){n.has(r)||n.set(r,new Array);const d=n.get(r);0===a(i,d,o).length&&d.push({source:Q,mode:c,attribute:o,value:e(r,o)});const h=i.find(e=>d[e].source===s);t===w?d.push({source:s,mode:c,attribute:o,value:l}):void 0===h?d.push({source:s,mode:c,attribute:o,value:l}):d[h].value=l,a(i,d,o),console.assert(i.length>0);const u=i[0];return 1===i.length?d[u].value:i.map(e=>d[e].value)},unset:function(e,t,s){if(n.has(t)){const r=n.get(t);for(let t=r.length-1;t>=0;t--){const n=r[t];if(n.attribute===s&&n.source===e){r.splice(t,1);break}}if((i=a(i,r,s)).length>0){const e=i[0],t=1===i.length?r[e].value:i.map(e=>r[e].value);return 1===i.length&&r[e].source===Q&&r.splice(e,1),t}}},APPEND:X,FIRST:Y,LAST:$}}((e,t)=>J(e,t),w);function An(e,t,n){return e.replace(/\$([\.\w]+)/g,(e,i)=>(function(e,t,n){let i=e;0===e.indexOf("event")?n?i=G(x(n,e.slice(6).split("."))):console.log("value of $event but no event received"):i=G(J(t,e.slice(1)));return i})(i,t,n))}AFRAME.registerComponent("modifier",{schema:{startEvents:{default:""},endEvents:{default:""},source:{default:""},sourceScope:{default:"document",oneOf:["parent","self","document"]},target:{default:""},targetScope:{default:"document",oneOf:["parent","self","document","event"]},seed:{type:"int",default:-1},debug:{default:!1}},multiple:!0,init(){this.onStartEvent=this.onStartEvent.bind(this),this.onEndEvent=this.onEndEvent.bind(this),this.setProperties=this.setProperties.bind(this),this.rules={},this.startEventListener=ne(this.el,this.onStartEvent),this.endEventListener=ne(this.el,this.onEndEvent),this.lcg=p()},remove(){this.startEventListener.remove(),this.endEventListener.remove()},updateSchema(e){"object"!=typeof e&&re(this,`invalid properties, expected format <property>:<value>; '${e}'`);const t=AFRAME.components[this.name].schema;let n={};for(let i in e)i in t||(n[i]={default:""});Object.keys(n).length>0&&this.extendSchema(n)},update(e){const t=AFRAME.components[this.name].schema,n=this.data;n.seed!==e.seed&&this.lcg.setSeed(n.seed);for(let e in this.rules)e in n||delete this.rules[e];for(let i in n)i in t||n[i]===e[i]||(this.rules[i]=R(n[i]));n.startEvents===e.startEvents&&n.endEvents===e.endEvents&&n.source===e.source&&n.sourceScope===e.sourceScope||(this.startEventListener.set(n.startEvents,n.source,n.sourceScope),this.endEventListener.set(n.endEvents,n.source,n.sourceScope))},pause(){this.startEventListener.remove(),this.endEventListener.remove()},play(){this.startEventListener.add(),this.endEventListener.add()},setProperties(e){const t=An(this.data.target,this.el,e),n=te(this.el,t,this.data.targetScope,e?e.target:void 0);this.data.debug&&console.log(Z(this.el),this.attrName,"setProperties","target=",t);for(let t of n)for(let n in this.rules){const i=G(U(this.rules[n],this.lcg.random)),a=An(i,this.el,e);this.data.debug&&console.log(Z(this.el),this.attrName,"setProperties","element=",Z(t),"property=",n,"value=",i,"$event=",e);const s=wn.set(this,t,n,a);K(t,n,s)}},clearProperties(e){const t=An(this.data.target,this.el,e),n=te(this.el,t,this.data.targetScope,e?e.target:void 0);this.data.debug&&console.log(Z(this.el),this.attrName,"clearProperties","target=",t);for(let e of n)for(let t in this.rules){const n=wn.unset(this,e,t);K(e,t,n)}},onStartEvent(e){this.data.debug&&console.log(Z(this.el),this.attrName,"onStartEvent",e.type,e),this.setProperties(e)},onEndEvent(e){this.data.debug&&console.log(Z(this.el),this.attrName,"onEndEvent",e.type,e),this.clearProperties(e)}}),AFRAME.registerComponent("outline",{schema:{color:{type:"color",default:"purple"},width:{default:.01},meshName:{default:"mesh"},style:{oneOf:["screenspace","3dspace"],default:"3dspace",parse:e=>e.toLowerCase()},enabled:{default:!0}},init(){this.onObject3DSet=this.onObject3DSet.bind(this),this.el.addEventListener("object3dset",this.onObject3DSet),this.color=new THREE.Color,this.material=this.createMaterial();const e=this.el.getObject3D(this.data.meshName);this.outline=this.createOutline(e,this.material)},remove(){this.el.removeEventListener("object3dset",this.onObject3DSet)},update(e){const t=this.data;if(t.color!==e.color&&(this.color.set(t.color),this.material.uniforms.color.value.set(this.color.r,this.color.g,this.color.b)),t.style!==e.style)switch(t.style){case"screenspace":this.material.defines={USE_SCREEN_SPACE:!0};break;default:this.material.defines={USE_THREED_SPACE:!0}}this.material.uniforms.width.value="screenspace"===t.style?t.width:10*t.width,this.outline&&(this.outline.visible=this.data.enabled)},createMaterial:()=>new THREE.ShaderMaterial({uniforms:{color:{value:new THREE.Vector3},width:{value:.1}},depthWrite:!0,transparent:!1,side:THREE.BackSide,vertexShader:"\nuniform float width;\nvoid main() {\n\n  float outlineWidth = width;\n\n  vec3 modelScale = vec3( \n    length( modelMatrix[0].xyz ), \n    length( modelMatrix[1].xyz ), \n    length( modelMatrix[2].xyz )\n  );\n\n#if defined(USE_SCREEN_SPACE)\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n  \n  outlineWidth *= gl_Position.w;\n#endif // defined(USE_THREED_SPACE)\n\n  vec3 widthScale = outlineWidth / modelScale;\n\n  mat4 scaleMatrix = mat4(1.);\n  scaleMatrix[0][0] = widthScale.x;\n  scaleMatrix[1][1] = widthScale.y;\n  scaleMatrix[2][2] = widthScale.z;\n\n  vec4 widthOffset = scaleMatrix * vec4( normalize( position ), 1. );\n  gl_Position = projectionMatrix * modelViewMatrix * vec4( position + widthOffset.xyz, 1.0 );\n}",fragmentShader:"\nuniform vec3 color;\nvoid main() {\n  gl_FragColor = vec4( color, 1. );\n}"}),createOutline(e,t){if(e){e.updateMatrixWorld(!0);const n=this.createHullOutline(e,t);return n&&(n.visible=this.data.enabled,this.el.setObject3D("outline",n)),n}},createHullOutline(e,t){let n=0;e.traverse(e=>{const t=e.geometry&&e.geometry.getAttribute("position");t&&3===t.itemSize&&(n+=t.array.length)});const i=new Float32Array(n);let a=0;const s=e.parent;e.parent=null,e.updateMatrixWorld(!0),e.traverse(e=>{const t=e.geometry&&e.geometry.getAttribute("position");if(t&&3===t.itemSize){i.set(t.array,a);for(let n=0;n<t.count;n++){const t=a+3*n;je(i,i,e.matrixWorld.elements,t,t)}a+=3*t.count}}),e.parent=s,e.updateMatrixWorld(!0);const r=_e(i);if(r){const e=r.slice().sort((e,t)=>e-t).filter((e,t,n)=>0===t||e!==n[t-1]),n=new THREE.BufferGeometry,a=new Float32Array(e.flatMap(e=>[i[e],i[e+1],i[e+2]]));return n.setAttribute("position",new THREE.BufferAttribute(a,3)),n.setIndex(r.map(t=>e.indexOf(t))),new THREE.Mesh(n,t)}},onObject3DSet(e){e.detail.type===this.data.meshName&&(this.outline=this.createOutline(e.detail.object,this.material))}});new THREE.DataTexture(new Uint8Array(3).fill(255),1,1,THREE.RGBFormat);AFRAME.registerComponent("picture",{dependencies:["material "],schema:{src:{type:"string"},side:{oneOf:["front","back","double"],default:"double"}},init(){this.geo=void 0,this.mesh=void 0,this.material=void 0,this.onMaterialTextureLoaded=this.onMaterialTextureLoaded.bind(this),this.el.addEventListener("materialtextureloaded",this.onMaterialTextureLoaded)},remove(){this.el.removeEventListener("materialtextureloaded",this.onMaterialTextureLoaded)},update(e){const t=this.data;this.mesh||this.createMesh(),t.src!==e.src&&(this.el.setAttribute("material","src",t.src),this.el.setAttribute("material","side",t.side))},createMesh(){this.geo=new THREE.PlaneBufferGeometry,this.material=new THREE.MeshStandardMaterial({side:THREE.DoubleSide}),this.mesh=new THREE.Mesh(this.geo,this.material),this.el.setObject3D("mesh",this.mesh)},resizeMesh(e,t){const n=Math.max(e,t),i=this.geo.getAttribute("position"),a=.5*e/n,s=.5*t/n;i.setXYZ(0,-a,s,0),i.setXYZ(1,a,s,0),i.setXYZ(2,-a,-s,0),i.setXYZ(3,a,-s,0),i.needsUpdate=!0},onMaterialTextureLoaded(e){const t=e.detail.src;e.target===this.el&&t&&t.height>0&&t.width>0&&this.resizeMesh(t.width,t.height)}}),AFRAME.registerComponent("pixel-color",{schema:{src:{type:"map"},canvas:{type:"selector"},color:{type:"color"},minSlope:{default:0},maxSlope:{default:90},bottomLeft:{type:"vec2",default:{x:0,y:0}},topRight:{type:"vec2",default:{x:1,y:1}},minIntensity:{default:0},maxIntensity:{default:1}},multiple:!0,init(){this.color=new THREE.Color},update(){const e=this.data;let t=!0;e.src instanceof HTMLCanvasElement||e.src instanceof HTMLImageElement||e.src instanceof SVGImageElement||(t=!1,console.error(`unable to derive an image from 'src' - ${e.src}`)),e.canvas instanceof HTMLCanvasElement||(t=!1,console.error(`unable to find output 'canvas' - ${e.canvas}`)),this.color.set(e.color),t&&this.paintCanvas()},paintCanvas(){const e=this.data,t=e.src.width,n=e.src.height;let i;if(e.src instanceof HTMLCanvasElement)i=e.src.getContext("2d");else if(e.src instanceof HTMLImageElement||e.src instanceof SVGImageElement){const a=document.createElement("canvas");a.width=t,a.height=n,(i=a.getContext("2d")).drawImage(e.src,0,0)}const a=i.getImageData(0,0,t,n),s=a.data,r=Float32Array.from({length:s.length/4},(e,t)=>(s[4*t]+s[4*t+1]+s[4*t+2])/765),o=document.createElement("canvas");o.width=t,o.height=n;const l=o.getContext("2d"),c=l.createImageData(a),d=c.data,h={r:255*this.color.r,g:255*this.color.g,b:255*this.color.b},u=Math.tan(THREE.Math.degToRad(Math.max(0,e.minSlope))),m=Math.tan(THREE.Math.degToRad(Math.max(0,e.maxSlope))),p={x:e.bottomLeft.x*t,y:e.bottomLeft.y*n},f={x:e.topRight.x*t,y:e.topRight.y*n};for(let i=0;i<t;i++)for(let a=0;a<n;a++){const s=a*t+i,o=4*s,l=r[s];let c=i>=p.x&&i<=f.x&&a>=p.y&&a<=f.y;if(c=c&&l>=e.minIntensity&&l<=e.maxIntensity){const e=(0===i?l-r[s+1]:r[s-1]-l)*t,o=(0===a?l-r[s+t]:r[s-t]-l)*n,d=Math.max(Math.abs(e),Math.abs(o));c=d>=u&&d<=m}c?(d[o]=h.r,d[o+1]=h.g,d[o+2]=h.b,d[o+3]=255):d[o+3]=0}l.putImageData(c,0,0),e.canvas.getContext("2d").drawImage(o,0,0,e.canvas.width,e.canvas.height),Et(this.el.sceneEl.object3D,e.canvas)}}),AFRAME.registerSystem("procedural-texture",{init(){this.renderer=void 0,this.proceduralTextureComponents=[]},registerComponent(e){this.proceduralTextureComponents.push(e),this.renderer||this.createRenderer()},unregisterComponent(e){const t=this.proceduralTextureComponents.indexOf(e);-1!==t&&this.proceduralTextureComponents.slice(t,1)},updateProceduralTexturesUsingThisCanvas(e,t){for(let n of this.proceduralTextureComponents)t!==n&&Object.keys(n.uniforms).some(t=>{const i=n.uniforms[t];return"texture"===i.type&&(Array.isArray(i.value)?i.value.any(t=>t.image===e):i.value.image===e)})&&n.update(n.data)},createRenderer(){this.renderer=new THREE.WebGLRenderer({alpha:!0,premultipliedAlpha:!1}),this.renderer.setPixelRatio(window.devicePixelRatio),this.renderer.autoClear=!0,this.renderer.setClearColor(new THREE.Color("purple"),1)}}),AFRAME.registerComponent("procedural-texture",{dependencies:["geometry"],schema:{shader:{type:"string"},canvas:{type:"selector"}},multiple:!0,init(){this.canvas=void 0,this.system.registerComponent(this)},remove(){this.system.unregisterComponent(this)},updateSchema(e){var t=!1;"object"!=typeof e&&console.error(`invalid properties, expected format <property>:<value>; '${e}'`),this.data&&this.data.shader===e.shader||(this.shaderProgram="",this.uniforms={},e.shader&&ie(e.shader,"main(",e=>{this.shaderProgram=e,this.uniforms=this.parseShaderUniforms(this.shaderProgram),t&&this.updateProceduralTexture()}));let n=this.uniformsToSchema(this.uniforms);e.canvas||(n.width={type:"int",value:256},n.height={type:"int",value:256}),Object.keys(n).length>0&&this.extendSchema(n),t=!0},update(e){const t=this.data;if(t.canvas!==e.canvas&&(this.canvas=t.canvas&&t.canvas instanceof HTMLCanvasElement?t.canvas:void 0),!t.canvas&&!this.canvas){this.canvas=document.createElement("canvas"),this.canvas.width=t.width||256,this.canvas.height=t.height||256;const e=this.el.getObject3D("mesh");e&&e.material&&(e.material.map=new THREE.CanvasTexture(this.canvas))}this.canvas&&this.shaderProgram&&this.updateProceduralTexture(),this.usesComponentTime()&&this.el.sceneEl.addBehavior(this)},updateProceduralTexture(){this.scene||this.setupScene(this.canvas,this.shaderProgram),this.updateUniforms(this.uniforms,this.data),this.renderScene(),Et(this.el.sceneEl.object3D,this.canvas),this.system.updateProceduralTexturesUsingThisCanvas(this.canvas),this.canvas.dispatchEvent(new CustomEvent("loaded",{bubbles:!1}))},usesComponentTime(){return"time"in this.uniforms&&!("time"in this.attrValue)},tick(e){this.usesComponentTime()?(this.uniforms.time.value=.001*e,this.renderScene()):this.el.sceneEl.removeBehavior(this)},setupScene(e,t){this.scene=new THREE.Scene,this.camera=new THREE.Camera,this.camera.position.z=1,this.uniforms=this.parseShaderUniforms(t);const n=t.replace(/#include\s*<procedural-ext>/,Rn);var i=new THREE.RawShaderMaterial({uniforms:this.uniforms,vertexShader:Sn,fragmentShader:n});const a=new THREE.Mesh(new THREE.PlaneBufferGeometry(2,2),i);this.scene.add(a),this.ctx=e.getContext("2d")},renderScene(){const e=this.ctx.canvas,t=e.width,n=e.height,i=this.system.renderer;i.setSize(t,n),i.render(this.scene,this.camera),this.ctx.clearRect(0,0,t,n),this.ctx.drawImage(this.system.renderer.domElement,0,0)},parseShaderUniforms(e){const t=/uniform (vec2|vec3|vec4|float|int|uint|bool|sampler2D) ([a-zA-Z0-9_]+)(\[(\d+)\])?;/;let n={};return e.split("\n").forEach(e=>{const i=t.exec(e);if(i){const e=i[1],t=i[2],a=void 0!==i[4]?parseInt(i[4],10):0;if(t){const i=n[t]||this.allocateUniform(e,a);n[t]=i}}}),n},uniformsToSchema(e){let t=[];for(let n in e){const i=e[n];switch(i.type){case"texture":t[n]={type:"string"};break;case"float32array":case"int32array":t[n]={type:"string"};break;default:t[n]={type:i.count>1?"string":i.type}}}return t},updateUniforms:function(){let e=new Array(4);const t=e=>Number(e),n=e=>!isNaN(e);function i(i,a,s,r){switch(i){case"texture":const c=r.sceneEl.systems.material,d=document.querySelector(a),h=d||a;c.loadTexture(h,{src:h},e=>{s(e)});break;case"number":s(parseFloat(a));break;case"boolean":s(!!a);break;case"float32array":case"int32array":let u=a.split(" ").map(t).filter(n);if(0==u.length){let t=E(a);t&&(e.fill(1),l=t,(o=e)[0]=l.r,o[1]=l.g,o[2]=l.b,void 0!==l.a&&(o[3]=l.a),u=o)}u.length>0&&s(u)}var o,l}return function(e,t){for(let n in e){const a=t[n],s=e[n];if(void 0===a)se(`no attribute for uniform: ${n}`);else{const e=("string"==typeof a?W(a):[a.toString()]).map(e=>e.trim());if(s.arrayCount>0)for(let t=0;t<e.length;t++){const n=e[t];switch(s.type){case"texture":i(s.type,n,e=>s.value[t]=e,this.el);break;case"number":case"boolean":i(s.type,n,e=>s.value[t]=e,this.el);break;case"float32array":case"in32array":i(s.type,n,e=>s.value.set(e.slice(0,s.size),t*s.size))}}else switch(s.type){case"texture":case"number":case"boolean":i(s.type,e[0],e=>s.value=e,this.el);break;case"float32array":case"in32array":i(s.type,e[0],e=>s.value.set(e.slice(0,s.size)))}}}}}(),allocateUniform(e,t){const n=Math.max(1,t);switch(e){case"sampler2D":return{type:"texture",value:t>0?new Array(t).fill(void 0):void 0,arrayCount:t};case"float":case"int":return{type:"number",value:t>0?new Array(t).fill(0):0,arrayCount:t};case"bool":return{type:"boolean",value:t>0&&new Array(t).fill(!1),arrayCount:t};case"ivec2":case"bvec2":case"vec2":return{type:"float32array",value:new Float32Array(2*n),size:2,arrayCount:t};case"vec3":return{type:"float32array",value:new Float32Array(3*n),size:3,arrayCount:t};case"vec4":return{type:"float32array",value:new Float32Array(4*n),size:4,arrayCount:t};case"ivec3":case"bvec3":return{type:"int32array",value:new Int32Array(3*n),size:3,arrayCount:t};case"ivec4":case"bvec4":return{type:"int32array",value:new Int32Array(4*n),size:4,arrayCount:t};default:se(`unknown uniform type ${e}`)}}});const Sn="\nprecision highp float;\n\nattribute vec3 position;\nattribute vec2 uv;\n\nvarying vec2 vUv;\nvoid main()\n{\n  vUv = uv;\n  gl_Position = vec4( position, 1.0 );\n}",Rn="\nprecision highp float;\nprecision highp int;\n\n// FLOAT -> FLOAT\n// could use levels low, high, mid, black, white (mid maps to (black + white)/2)\nfloat remap(float v, float amin, float amax, float bmin, float bmax)\n{\n  return (v - amin)*(bmax - bmin)/(amax - amin) + bmin;\n}\n\nfloat roundF(const float number)\n{\n  return sign(number)*floor(abs(number)+0.5);\n}\n\nfloat quantize(const float v, const float quanta) {\n  return floor(v/quanta)*quanta;\n}\n\n// VEC2 -> VEC2\nvec2 uvBrick(const vec2 uv, const float numberOfBricksWidth, const float numberOfBricksHeight)\n{\n  float yi=uv.y*numberOfBricksHeight;\n  float nyi=roundF(yi);\n  float xi=uv.x*numberOfBricksWidth;\n  if (mod(floor(yi),2.0) == 0.0)\n  {\n    xi=xi-0.5;\n  }\n  float nxi=roundF(xi);\n\n  return vec2((xi-floor(xi))*numberOfBricksHeight,(yi-floor(yi))*numberOfBricksWidth);\n}\n\nvec2 uvTransform(const vec2 uv, const vec2 center, const vec2 scale, const float rad, const vec2 translate) \n{\n  float c = cos(-rad);\n  float s = sin(-rad);\n  float x = (uv.x - translate.x - center.x);\n  float y = (uv.y - translate.y - center.y);\n  float x2 = (x*c + y*s)/scale.x + center.x;\n  float y2 = (-x*s + y*c)/scale.y + center.y;\n  return vec2(x2, y2);\n}\n\nvec2 uvCrop(const vec2 uv, const vec2 uvMin, const vec2 uvMax) \n{\n  vec2 scale = 1./(uvMax - uvMin);\n  return uvTransform(uv, vec2(0.), scale, 0., -uvMin*scale);\n}\n\n\n// SAMPLER2D -> VEC4\nfloat normpdf(const float x, const float sigma)\n{\n  return .39894*exp(-.5*x*x/(sigma*sigma))/sigma;\n}\n\nvec4 blur13(const sampler2D image, const vec2 uv, const vec2 resolution, const float sigma)\n{\n  const int kernelWidth = 13;\n  const int kSize = kernelWidth/2 - 1;\n  float kernel[kernelWidth];\n\n  float Z = 0.;\n\n  for (int j = 0; j <= kSize; j++)\n  {\n    kernel[kSize + j] = kernel[kSize - j] = normpdf(float(j), sigma);\n  }\n  for (int j = 0; j < kernelWidth; j++)\n  {\n    Z += kernel[j];\n  }\n\n  vec4 color = vec4(0.);\n  for (int i = -kSize; i <= kSize; i++)\n  {\n    for (int j = -kSize; j <= kSize; j++)\n    {\n      color += kernel[kSize + j]*kernel[kSize + i]*texture2D( image, uv + vec2(float(i), float(j))/resolution );\n    }\n  }\n\n  return color/(Z*Z);\n}\n\nvec4 terrase13(const sampler2D image, const vec2 uv, const vec2 resolution)\n{\n  const int kernelWidth = 13; // this must be const for webgl1\n  const int kSize = kernelWidth/2 - 1;\n\n  vec4 color = vec4(0.);\n  for (int i = -kSize; i <= kSize; i++)\n  {\n    for (int j = -kSize; j <= kSize; j++)\n    {\n      color = max( color, texture2D( image, uv + vec2(float(i), float(j))/resolution ) );\n    }\n  }\n\n  return color;\n}\n\nvec4 terrase5(const sampler2D image, const vec2 uv, const vec2 resolution)\n{\n  const int kernelWidth = 5; // this must be const for webgl1\n  const int kSize = kernelWidth/2 - 1;\n\n  vec4 color = vec4(0.);\n  for (int i = -kSize; i <= kSize; i++)\n  {\n    for (int j = -kSize; j <= kSize; j++)\n    {\n      color = max( color, texture2D( image, uv + vec2(float(i), float(j))/resolution ) );\n    }\n  }\n\n  return color;\n}\n\nvec4 terrase27(const sampler2D image, const vec2 uv, const vec2 resolution)\n{\n  const int kernelWidth = 27; // this must be const for webgl1\n  const int kSize = kernelWidth/2 - 1;\n\n  vec4 color = vec4(0.);\n  for (int i = -kSize; i <= kSize; i++)\n  {\n    for (int j = -kSize; j <= kSize; j++)\n    {\n      color = max( color, texture2D( image, uv + vec2(float(i), float(j))/resolution ) );\n    }\n  }\n\n  return color;\n}\n\n// VEC2 -> FLOAT\nfloat rand(const vec2 n)\n{\n  return fract(cos(dot(n,vec2(12.9898,4.1414)))*43758.5453);\n}\n\nfloat noise(const vec2 n)\n{\n  const vec2 d=vec2(0.0,1.0);\n  vec2 b=floor(n), f=smoothstep(vec2(0.0), vec2(1.0), fract(n));\n  return mix( mix( rand(b), rand(b+d.yx), f.x ), mix( rand(b+d.xy), rand(b+d.yy), f.x ), f.y );\n}\n\nfloat fbm(vec2 n) {\n  float total=0.0,amplitude=1.0;\n\n  for (int i=0; i<4; i++)\n  {\n    total+=noise(n)*amplitude;\n    n+=n;\n    amplitude*=0.5;\n  }\n\n  return total;\n}\n\nfloat turbulence(const vec2 P)\n{\n  float val=0.0;\n  float freq=1.0;\n\n  for (int i=0; i<4; i++)\n  {\n    val+=abs(noise(P*freq)/freq);\n    freq*=2.07;\n  }\n\n  return val;\n}\n\nfloat brick(const vec2 uv, const float numberOfBricksWidth, const float numberOfBricksHeight, const float jointWidthPercentage, const float jointHeightPercentage)\n{\n  float yi=uv.y*numberOfBricksHeight;\n  float nyi=roundF(yi);\n  float xi=uv.x*numberOfBricksWidth;\n  if (mod(floor(yi),2.0) == 0.0) { xi = xi - 0.5; } // offset every second brick\n  float nxi=roundF(xi);\n  xi = abs(xi - nxi);\n  yi = abs(yi - nyi);\n\n  return 1. - clamp( min(yi/jointHeightPercentage, xi/jointWidthPercentage) + 0.2, 0., 1. );\n}\n\nfloat marble(const vec2 uv, float amplitude, float k)\n{\n  k = 6.28*uv.x/k;\n  k += amplitude*turbulence(uv.xy);\n  k = sin(k);\n  k = .5*(k + 1.);\n  k = sqrt( sqrt( sqrt(k) ) ); \n  return .2 + .75*k;\n}\n\nfloat checkerboard(const vec2 uv, const float numCheckers)\n{\n  float cx = floor(numCheckers * uv.x);\n  float cy = floor(numCheckers * uv.y);\n  return sign( mod(cx + cy, 2.) );\n}\n\nfloat gaussian(const vec2 uv)\n{\n  vec2 xy = (mod(uv, vec2(1.,1.)) - .5)*2.;\n  float exponent = dot(xy,xy)/0.31831;\n  return exp(-exponent);\n}\n\n// from glsl-voronoi-noise\nconst mat2 myt = mat2(.12121212, .13131313, -.13131313, .12121212);\nconst vec2 mys = vec2(1e4, 1e6);\n\nvec2 rhash(vec2 uv) {\n  uv *= myt;\n  uv *= mys;\n  return fract(fract(uv / mys) * uv);\n}\n\nvec3 hash(const vec3 p) {\n  return fract(sin(vec3(dot(p, vec3(1.0, 57.0, 113.0)),\n    dot(p, vec3(57.0, 113.0, 1.0)),\n    dot(p, vec3(113.0, 1.0, 57.0)))) *\n  43758.5453);\n}\n\nfloat voronoi2d(const in vec2 point) {\n  vec2 p = floor(point);\n  vec2 f = fract(point);\n  float res = 0.0;\n  for (int j = -1; j <= 1; j++) {\n    for (int i = -1; i <= 1; i++) {\n      vec2 b = vec2(i, j);\n      vec2 r = vec2(b) - f + rhash(p + b);\n      res += 1. / pow(dot(r, r), 8.);\n    }\n  }\n  return pow(1. / res, 0.0625);\n}\n\n// from glsl-worley\n// Permutation polynomial: (34x^2 + x) mod 289\nvec3 permute(const vec3 x) {\n  return mod((34.0 * x + 1.0) * x, 289.0);\n}\n\nvec3 dist(const vec3 x, const vec3 y) {\n  return (x * x + y * y);\n}\n\nvec2 worley(const vec2 P, const float jitter) {\n  float K= 0.142857142857; // 1/7\n  float Ko= 0.428571428571 ;// 3/7\n  vec2 Pi = mod(floor(P), 289.0);\n  vec2 Pf = fract(P);\n  vec3 oi = vec3(-1.0, 0.0, 1.0);\n  vec3 of = vec3(-0.5, 0.5, 1.5);\n  vec3 px = permute(Pi.x + oi);\n  vec3 p = permute(px.x + Pi.y + oi); // p11, p12, p13\n  vec3 ox = fract(p*K) - Ko;\n  vec3 oy = mod(floor(p*K),7.0)*K - Ko;\n  vec3 dx = Pf.x + 0.5 + jitter*ox;\n  vec3 dy = Pf.y - of + jitter*oy;\n  vec3 d1 = dist(dx,dy); // squared\n  p = permute(px.y + Pi.y + oi); // p21, p22, p23\n  ox = fract(p*K) - Ko;\n  oy = mod(floor(p*K),7.0)*K - Ko;\n  dx = Pf.x - 0.5 + jitter*ox;\n  dy = Pf.y - of + jitter*oy;\n  vec3 d2 = dist(dx,dy); // squared\n  p = permute(px.z + Pi.y + oi); // p31, p32, p33\n  ox = fract(p*K) - Ko;\n  oy = mod(floor(p*K),7.0)*K - Ko;\n  dx = Pf.x - 1.5 + jitter*ox;\n  dy = Pf.y - of + jitter*oy;\n  vec3 d3 = dist(dx,dy); // squared\n\n  // Sort out the two smallest distances (F1, F2)\n  vec3 d1a = min(d1, d2);\n  d2 = max(d1, d2); // Swap to keep candidates for F2\n  d2 = min(d2, d3); // neither F1 nor F2 are now in d3\n  d1 = min(d1a, d2); // F1 is now in d1\n  d2 = max(d1a, d2); // Swap to keep candidates for F2\n  d1.xy = (d1.x < d1.y) ? d1.xy : d1.yx; // Swap if smaller\n  d1.xz = (d1.x < d1.z) ? d1.xz : d1.zx; // F1 is in d1.x\n  d1.yz = min(d1.yz, d2.yz); // F2 is now not in d2.yz\n  d1.y = min(d1.y, d1.z); // nor in  d1.z\n  d1.y = min(d1.y, d2.x); // F2 is in d1.y, we're done.\n  return sqrt(d1.xy);\n}\n";AFRAME.registerComponent("prefab",{schema:{template:{default:""},debug:{default:!1}},init(){this.templateContent=void 0,this.hasPrefab=!1},remove(){this.destroyPrefab()},updateSchema(e){"object"!=typeof e&&console.error(`invalid properties, expected format <property>:<value>; '${e}'`);const t=AFRAME.components[this.name].schema;let n={};for(let i in e)i in t||(n[i]={type:"string"});Object.keys(n).length>0&&this.extendSchema(n)},update(e){const t=this.data;e.template!==t.template&&ie(t.template,"",e=>{this.templateContent=e,this.destroyPrefab(),this.createPrefab()})},createPrefab(){if(!this.hasPrefab){const e=this.processTemplate(this.templateContent);this.el.innerHTML=e,this.hasPrefab=!0,this.data.debug&&console.log(e)}},destroyPrefab(){if(this.hasPrefab){for(;this.el.lastChild;)this.el.removeChild(this.el.lastChild);this.hasPrefab=!1}},processTemplate(e){const t=Object.keys(this.data).concat("return `"+e+"`");return new Function(...t)(...Object.values(this.data))}}),AFRAME.registerComponent("rumble",{schema:{events:{default:""},delay:{default:0},duration:{default:.1},force:{default:1},controllers:{default:""},enabled:{default:!0}},multiple:!0,init(){this.delayClock=ee(),this.eventListener=ne(this.el,this.onEvent.bind(this)),this.pulses=[]},remove(){this.eventListener.remove(),this.stopAllActuators()},play(){this.eventListener.add()},pause(){this.eventListener.remove(),this.stopAllActuators()},update(e){const t=this.data;t.events!==e.events&&this.eventListener.set(t.events),t.controllers!==e.controllers&&(this.stopAllActuators(),this.actuators=[]),t.enabled!==e.enabled&&(t.enabled||this.stopAllActuators())},onEvent(e){const t=this.data;if(!t.enabled)return;const n=this.getActuators(e);if(0===n.length)return;const i=this;var a;this.delayClock.startTimer(t.delay,()=>(a=i.pulses,a=[],void n.map(e=>{a.push(e),e.pulse(t.force,1e3*t.duration).then(()=>{a.splice(a.indexOf(e),1)},t=>{a.splice(a.indexOf(e),1),console.error(t)})})))},stopAllActuators(){this.delayClock.clearAllTimers();for(let e of this.pulses)e.pulse(0,0);this.pulses.length=0},getActuators(e){if(this.actuators.length>0)return this.actuators;const t=this.data,n=t.controllers?document.querySelectorAll(t.controllers):[this.el];let i=[];if(0===n.length)se(this,"no controller elements found");else{for(let e of n)if(e.components["tracked-controls"]&&e.components["tracked-controls"].controller){const t=e.components["tracked-controls"].controller;t.hapticActuators.length>0&&i.push(...t.hapticActuators)}0===i.length&&se(this,"no tracked-controls found")}return this.actuators=i,i}});var Cn=["attribute vec3 position;","attribute vec2 uv;","uniform mat4 projectionMatrix;","uniform mat4 modelViewMatrix;","varying vec2 vUv;","void main()  {","  vUv = vec2( 1.- uv.x, uv.y );","  gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );","}"].join("\n"),kn=["precision mediump float;","uniform samplerCube map;","varying vec2 vUv;","#define M_PI 3.141592653589793238462643383279","void main() {","  vec2 uv = vUv;","  float longitude = uv.x * 2. * M_PI + .5 * M_PI;","  float latitude = uv.y * M_PI;","  vec3 dir = vec3(","    - sin( longitude ) * sin( latitude ),","    cos( latitude ),","    - cos( longitude ) * sin( latitude )","  );","  normalize( dir );","  gl_FragColor = vec4( textureCube( map, dir ).rgb, 1.0 );","}"].join("\n"),Mn=["varying vec2 vUv;","void main() {","  vUv = uv;","  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);","}"].join("\n"),In=["#include <packing>","varying vec2 vUv;","uniform sampler2D tDepth;","uniform float cameraNear;","uniform float cameraFar;","uniform float maxDepth;","float readDepth( sampler2D depthSampler, vec2 coord ) {","  float fragCoordZ = texture2D( depthSampler, coord ).x;","  float z_n = 2.0 * fragCoordZ - 1.0;","  float z_e = 2.0 * cameraNear * cameraFar / (cameraFar + cameraNear - z_n * (cameraFar - cameraNear));","  return clamp(z_e/maxDepth, 0., 1.);","}","void main() {","  //gl_FragColor.rgb = vec3(vUv.x, vUv.y, 0.0);","  //gl_FragColor.rgb = texture2D( tDepth, vUv ).rgb;","  float depth = readDepth( tDepth, vUv );","  gl_FragColor.rgb = 1.0 - vec3( depth );","  gl_FragColor.a = 1.0;","}"].join("\n");AFRAME.registerComponent("screenshotx",{schema:{width:{default:4096},height:{default:2048},camera:{type:"selector"},maxDepth:{default:10}},init:function(){this.setup=this.setup.bind(this),this.onKeyDown=this.onKeyDown.bind(this);const e=this.el;e.renderer?this.setup():e.addEventListener("render-target-loaded",this.setup)},setup(){var e=this.el.renderer.getContext();if(!e)return;this.cubeMapSize=e.getParameter(e.MAX_CUBE_MAP_TEXTURE_SIZE),this.orthographicCamera=new THREE.OrthographicCamera(-1,1,1,-1,0,1),this.screenshot={},this.screenshot.canvas=document.createElement("canvas"),this.screenshot.ctx=this.screenshot.canvas.getContext("2d"),this.equirectangular={},this.equirectangular.material=new THREE.RawShaderMaterial({uniforms:{map:{type:"t",value:null}},vertexShader:Cn,fragmentShader:kn,side:THREE.DoubleSide});const t=new THREE.Mesh(new THREE.PlaneBufferGeometry(2,2),this.equirectangular.material);this.equirectangular.scene=new THREE.Scene,this.equirectangular.scene.add(t),this.depth={},this.depth.canvas=document.createElement("canvas"),this.depth.ctx=this.depth.canvas.getContext("2d"),this.depth.material=new THREE.ShaderMaterial({vertexShader:Mn,fragmentShader:In,uniforms:{cameraNear:{value:0},cameraFar:{value:0},maxDepth:{value:0},tDepth:{type:"t",value:null}}});const n=new THREE.Mesh(new THREE.PlaneBufferGeometry(2,2),this.depth.material);this.depth.scene=new THREE.Scene,this.depth.scene.add(n)},createRenderTarget:function(e,t){const n=new THREE.WebGLRenderTarget(e,t,{minFilter:THREE.LinearFilter,magFilter:THREE.LinearFilter,wrapS:THREE.ClampToEdgeWrapping,wrapT:THREE.ClampToEdgeWrapping,format:THREE.RGBAFormat,type:THREE.UnsignedByteType});return n.stencilBuffer=!1,n.depthBuffer=!0,n},play:function(){window.addEventListener("keydown",this.onKeyDown)},pause:function(){window.removeEventListener("keydown",this.onKeyDown)},onKeyDown:function(e){const t=83===e.keyCode&&e.ctrlKey&&e.altKey;if(this.data&&t){const t=`screenshot${document.title?"+"+document.title.toLowerCase():""}-${Date.now()}`;this.capture(e.shiftKey?"equirectangular":"perspective",t)}},capture(e,t){const n=this.el.renderer,i=n.vr.enabled;n.vr.enabled=!1;const a=this.data.camera&&this.data.camera.components.camera.camera||this.el.camera,s={width:this.data.width,height:this.data.height};return"perspective"===e?this.capturePerspective(a,s):this.captureEquirectangular(a,s),t&&(this.saveCapture(this.screenshot.canvas,t+".png"),"perspective"===e&&this.saveCapture(this.depth.canvas,t+"_depth.png")),n.vr.enabled=i,this.screenshot.canvas},capturePerspective(e,t){const n=this.el.renderer,i=this.createRenderTarget(t.width,t.height);i.depthTexture=new THREE.DepthTexture,i.depthTexture.type=THREE.UnsignedShortType,n.clear(),n.setRenderTarget(i),n.render(this.el.object3D,e),this.screenshot.canvas.width=t.width,this.screenshot.canvas.height=t.height,this.copyRenderTargetToCanvas(n,i,this.screenshot.ctx,t,!0);const a=this.depth.material.uniforms;a.tDepth.value=i.depthTexture,a.cameraNear.value=e.near,a.cameraFar.value=e.far,a.maxDepth.value=this.data.maxDepth;const s=this.createRenderTarget(t.width,t.height);n.setRenderTarget(s),n.render(this.depth.scene,this.orthographicCamera),this.depth.canvas.width=t.width,this.depth.canvas.height=t.height,this.copyRenderTargetToCanvas(n,s,this.depth.ctx,t,!0),n.setRenderTarget(null)},captureEquirectangular(e,t){const n=this.el,i=n.renderer;var a=new THREE.CubeCamera(e.near,e.far,Math.min(this.cubeMapSize,2048));e.getWorldPosition(a.position),e.getWorldQuaternion(a.quaternion),a.update(n.renderer,n.object3D);const s=this.createRenderTarget(t.width,t.height);this.equirectangular.material.uniforms.map.value=a.renderTarget.texture,i.clear(),i.setRenderTarget(s),i.render(this.equirectangular.scene,this.orthographicCamera),this.screenshot.canvas.width=t.width,this.screenshot.canvas.height=t.height,this.copyRenderTargetToCanvas(i,s,this.screenshot.ctx,t,!1),i.setRenderTarget(null)},flipPixelsVertically:function(e,t,n){for(var i=e.slice(0),a=0;a<t;++a)for(var s=0;s<n;++s)i[4*a+s*t*4]=e[4*a+(n-s)*t*4],i[4*a+1+s*t*4]=e[4*a+1+(n-s)*t*4],i[4*a+2+s*t*4]=e[4*a+2+(n-s)*t*4],i[4*a+3+s*t*4]=e[4*a+3+(n-s)*t*4];return i},saveCapture:function(e,t){e.toBlob(function(e){var n=document.createElement("a"),i=URL.createObjectURL(e);n.href=i,n.setAttribute("download",t),n.innerHTML="downloading...",n.style.display="none",document.body.appendChild(n),setTimeout(function(){n.click(),document.body.removeChild(n)},1)},"image/png")},copyRenderTargetToCanvas(e,t,n,i,a){let s=new Uint8Array(4*i.width*i.height);e.readRenderTargetPixels(t,0,0,i.width,i.height,s),a&&(s=this.flipPixelsVertically(s,i.width,i.height));const r=new ImageData(new Uint8ClampedArray(s),i.width,i.height);n.putImageData(r,0,0)}});var On=new function(){var e,t,n,i,a,s,r,o,l,c,d,h;this._params=new function(){this.setSettings=function(e){for(var t=0;t<24;t++)this[String.fromCharCode(97+t)]=e[t]||0;this.c<.01&&(this.c=.01);var n=this.b+this.c+this.e;if(n<.18){var i=.18/n;this.b*=i,this.c*=i,this.e*=i}}},this.reset=function(){var e=this._params;i=100/(e.f*e.f+.001),a=100/(e.g*e.g+.001),s=1-e.h*e.h*e.h*.01,r=-e.i*e.i*e.i*1e-6,e.a||(d=.5-e.n/2,h=5e-5*-e.o),o=1+e.l*e.l*(e.l>0?-.9:10),l=0,c=1==e.m?0:(1-e.m)*(1-e.m)*2e4+32},this.totalReset=function(){this.reset();var i=this._params;return e=i.b*i.b*1e5,t=i.c*i.c*1e5,n=i.e*i.e*1e5+12,3*((e+t+n)/3|0)},this.synthWave=function(u,m){var p=this._params,f=1!=p.s||p.v,g=p.v*p.v*.1,v=1+3e-4*p.w,y=p.s*p.s*p.s*.1,b=1+1e-4*p.t,E=1!=p.s,x=p.x*p.x,T=p.g,w=p.q||p.r,A=p.r*p.r*p.r*.2,S=p.q*p.q*(p.q<0?-1020:1020),R=p.p?32+((1-p.p)*(1-p.p)*2e4|0):0,C=p.d,k=p.j/2,M=p.k*p.k*.01,I=p.a,O=e,P=1/e,F=1/t,D=1/n,L=5/(1+p.u*p.u*20)*(.01+y);L>.8&&(L=.8),L=1-L;for(var H,j,_,z,N,B,V=!1,U=0,q=0,G=0,W=0,Q=0,$=0,Y=0,X=0,Z=0,K=0,J=new Array(1024),ee=new Array(32),te=J.length;te--;)J[te]=0;for(te=ee.length;te--;)ee[te]=2*Math.random()-1;for(te=0;te<m;te++){if(V)return te;if(R&&++Z>=R&&(Z=0,this.reset()),c&&++l>=c&&(c=0,i*=o),(i*=s+=r)>a&&(i=a,T>0&&(V=!0)),j=i,k>0&&(K+=M,j*=1+Math.sin(K)*k),(j|=0)<8&&(j=8),I||((d+=h)<0?d=0:d>.5&&(d=.5)),++q>O)switch(q=0,++U){case 1:O=t;break;case 2:O=n}switch(U){case 0:G=q*P;break;case 1:G=1+2*(1-q*F)*C;break;case 2:G=1-q*D;break;case 3:G=0,V=!0}w&&((_=0|(S+=A))<0?_=-_:_>1023&&(_=1023)),f&&v&&((g*=v)<1e-5?g=1e-5:g>.1&&(g=.1)),B=0;for(var ne=8;ne--;){if(++Y>=j&&(Y%=j,3==I))for(var ie=ee.length;ie--;)ee[ie]=2*Math.random()-1;switch(I){case 0:N=Y/j<d?.5:-.5;break;case 1:N=1-Y/j*2;break;case 2:N=.225*(((N=1.27323954*(z=6.28318531*((z=Y/j)>.5?z-1:z))+.405284735*z*z*(z<0?1:-1))<0?-1:1)*N*N-N)+N;break;case 3:N=ee[Math.abs(32*Y/j|0)]}f&&(H=$,(y*=b)<0?y=0:y>.1&&(y=.1),E?(Q+=(N-$)*y,Q*=L):($=N,Q=0),W+=($+=Q)-H,N=W*=1-g),w&&(J[X%1024]=N,N+=J[(X-_+1024)%1024],X++),B+=N}B*=.125*G*x,u[te]=B>=1?32767:B<=-1?-32768:32767*B|0}return m}};const Pn=["square","saw","sine","noise"],Fn=Object.fromEntries(Object.entries({blip:"1,0.0763,0.2818,0.016,0.0863,0.5084,,0.1299,0.0055,-0.9082,0.129,-0.0591,-0.2874,0.394,0.0001,0.9773,0.0273,-0.2397,0.9997,0.0216,,0.049,0.0001,0.5",blip2:"2,,0.1774,0.3425,0.2543,0.5001,,,-0.1253,,-0.6326,0.0511,0.6321,0.5733,0.2467,,0.347,0.0153,0.8671,-0.025,-0.7166,0.0822,,0.5",blip3:"1,,0.01,0.466,0.2176,0.2082,,-0.0277,0.1473,,0.0722,0.7231,-0.5943,0.1948,-0.0661,,0.1636,0.2965,0.0806,-0.001,0.8212,0.1233,-0.0013,0.5",blip4:"1,,0.1965,,0.1281,0.2741,,,,,,,,,,,,,1,,,0.1,,0.5",bounce:"2,0.0007,0.0948,0.0201,0.1347,0.1747,,0.0545,0.0153,-0.0796,-0.4931,0.8874,-0.3721,0.1246,0.8612,0.6185,-0.1477,-0.6924,0.4851,0.3104,0.1193,0.2017,0.0358,0.5",chime:"0,0.1383,0.651,0.467,0.3914,0.5016,,,0.0655,,0.064,-0.7934,,0.4441,0.0266,0.3182,-0.1779,0.2923,0.3721,-0.0176,,0.6679,0.6276,0.5",coin:"0,,0.0471,0.4724,0.3068,0.7881,,,,,,0.5963,0.5726,,,,,,1,,,,,0.5",explosion:"3,,0.3436,0.6166,0.4478,0.0417,,0.2933,,,,,,,,0.5993,-0.1521,-0.0133,1,,,,,0.5",hit:"3,0.0072,0.1912,0.4453,0.6026,0.5006,,0.5214,-0.0019,0.2952,,-0.4769,,,-0.4262,-0.8242,-0.0544,-0.1995,0.8669,-0.7538,0.4002,0.32,-0.0006,0.5",jump:"0,,0.3617,,0.1015,0.4239,,0.2121,,,,,,0.1629,,,,,0.6555,,,,,0.5",laser:"1,,0.2965,0.2824,0.0465,0.6897,0.3877,-0.2884,,,,,,0.8732,-0.4466,,,,1,,,0.0907,,1",laser2:"3,0.0059,0.5443,0.2928,0.6031,0.5,,,-0.0187,,,0.9508,,0.6631,-0.5569,0.7418,0.0444,-0.7924,0.6592,-0.1598,-0.133,0.0128,,0.5",laser3:"3,0.0496,0.01,0.0659,0.918,0.5014,,0.5792,-0.0029,-0.0049,0.8602,0.118,,,-0.0042,0.1187,-0.0236,0.6263,0.752,-0.6478,-0.8254,0.0664,-0.1286,0.5",powerup:"0,,0.1917,,0.4356,0.3114,,0.0918,,,,,,0.4176,,,,,1,,,,,1",pulse:"0,0.3134,0.7096,0.0081,0.4655,0.2789,,-0.102,0.0261,0.1236,0.8212,0.4089,,,-0.116,,0.1212,0.0429,0.978,-0.3121,,,-0.1077,0.5",pulse2:",0.1637,0.6944,0.8905,0.741,0.5745,,-0.0833,0.7298,0.2642,0.3181,0.1227,0.5693,0.1215,0.1114,0.5623,0.5974,0.8682,0.793,-0.2755,0.0143,0.7865,0.2557,0.5",pulse3:"1,0.2058,0.0697,0.0369,0.9649,0.4779,,,-0.0495,0.661,,-0.4738,0.5435,0.7119,-0.0316,0.2556,-0.9952,0.4666,0.1608,-0.038,0.4537,0.097,,0.5",pulse4:"0,0.0008,0.01,0.1728,0.4637,0.5029,,0.2054,,0.6654,0.0841,0.7765,0.7312,0.8236,-0.3597,0.7258,0.0674,-0.0745,0.1646,0.0361,0.1764,,-0.2647,0.5",thump:"3,0.145,0.2908,0.597,0.542,0.001,,0.0014,0.0367,0.1754,0.8581,0.3987,,0.1379,-0.759,,-0.3583,0.0593,0.185,-0.9675,0.7929,0.0065,-0.2162,0.5"}).map(e=>[e[0],Ln(e[1])]));function Dn(e,t,n){return e<t?t:e>n?n:e}function Ln(e){return e.split(",").map(e=>Number(e))}function Hn(){return Math.random()}AFRAME.registerComponent("sfxr",{schema:{_play:{default:!1},_random:{default:!1},as3fxr:{default:""},preset:{oneOf:Object.keys(Fn),default:""},events:{default:""},delay:{default:0},waveType:{oneOf:Pn,default:"square",parse:function(e){return e.toLowerCase()}},attackTime:{default:0,min:0,max:1},sustainTime:{default:.18,min:.18,max:1},sustainPunch:{default:0,min:0,max:1},decayTime:{default:0,min:0,max:1},startFrequency:{default:0,min:0,max:1},minFrequency:{default:0,min:0,max:1},slide:{default:0,min:-1,max:1},deltaSlide:{default:0,min:-1,max:1},vibratoDepth:{default:0,min:0,max:1},vibratoSpeed:{default:0,min:0,max:1},changeAmount:{default:0,min:-1,max:1},changeSpeed:{default:0,min:0,max:1},squareDuty:{default:0,min:0,max:1},dutySweep:{default:0,min:-1,max:1},repeatSpeed:{default:0,min:0,max:1},phaserOffset:{default:0,min:-1,max:1},phaserSweep:{default:0,min:-1,max:1},lpFilterCutoff:{default:0,min:0,max:1},lpFilterCutoffSweep:{default:0,min:-1,max:1},lpFilterResonance:{default:0,min:0,max:1},hpFilterCutoff:{default:0,min:0,max:1},hpFilterCutoffSweep:{default:0,min:-1,max:1},masterVolume:{default:0,min:0,max:1},enabled:{default:!0},playOnChange:{default:!1}},multiple:!0,init(){this.onEvent=this.onEvent.bind(this),this.playSound=this.playSound.bind(this),this.player=new Audio,this.delayClock=ee(),this.eventListener=ne(this.el,this.onEvent)},remove(){this.eventListener.remove(),this.delayClock.clearAllTimeouts(),this.player.stop()},pause(){this.eventListener.remove(),this.delayClock.pause()},play(){this.eventListener.add(),this.delayClock.resume()},update(e){const t=this.data;if(void 0!==e._play&&t._play!==e._play)this.playSound();else if(void 0!==e._random&&t._random!==e._random){const t=[Math.trunc(Hn()*Pn.length),Hn(),Hn(),Hn(),Hn(),Hn(),0,2*Hn()-1,2*Hn()-1,Hn(),Hn(),2*Hn()-1,Hn(),Hn(),2*Hn()-1,Hn(),Hn(),2*Hn()-1,Hn(),2*Hn()-1,Hn(),Hn(),2*Hn()-1,.5];this.sendToPlayer(t),this.setData(t),this.setASFXData(t),this.data.preset="",void 0!==e.preset&&this.player.play()}else if(e.preset!==t.preset&&t.preset){const n=Fn[t.preset]||Fn[0];this.sendToPlayer(n),this.setData(n),this.setASFXData(n),void 0!==e.preset&&this.player.play()}else if(t.as3fxr!==e.as3fxr&&t.as3fxr){const e=Ln(t.as3fxr);this.sendToPlayer(e),this.setData(e)}else this.sendToPlayer([Pn.indexOf(t.waveType),t.attackTime,t.sustainTime,t.sustainPunch,t.decayTime,t.startFrequency,t.minFrequency,t.slide,t.deltaSlide,t.vibratoDepth,t.vibratoSpeed,t.changeAmount,t.changeSpeed,t.squareDuty,t.dutySweep,t.repeatSpeed,t.phaserOffset,t.phaserSweep,t.lpFilterCutoff,t.lpFilterCutoffSweep,t.lpFilterResonance,t.hpFilterCutoff,t.hpFilterCutoffSweep,t.masterVolume]),t.playOnChange&&this.player.play();t.events!==e.events&&(t.events?this.eventListener.set(t.events,"","self"):this.delayClock.startTimer(this.data.delay,this.playSound))},setData(e){const t=this.data;t.waveType=Pn[e[0]],t.attackTime=e[1],t.sustainTime=e[2],t.sustainPunch=e[3],t.decayTime=e[4],t.startFrequency=e[5],t.minFrequency=e[6],t.slide=e[7],t.deltaSlide=e[8],t.vibratoDepth=e[9],t.vibratoSpeed=e[10],t.changeAmount=e[11],t.changeSpeed=e[12],t.squareDuty=e[13],t.dutySweep=e[14],t.repeatSpeed=e[15],t.phaserOffset=e[16],t.phaserSweep=e[17],t.lpFilterCutoff=e[18],t.lpFilterCutoffSweep=e[19],t.lpFilterResonance=e[20],t.hpFilterCutoff=e[21],t.hpFilterCutoffSweep=e[22],t.masterVolume=e[23]},setASFXData(e){this.data.as3fxr=e.map(e=>0!=e?e.toFixed(4).replace(/0+$/,""):"").join(",")},sendToPlayer(e){this.player.src=function(e){On._params.setSettings(e);var t=On.totalReset(),n=new Uint8Array(4*((t+1)/2|0)+44),i=2*On.synthWave(new Uint16Array(n.buffer,44),t),a=new Uint32Array(n.buffer,0,44);a[0]=1179011410,a[1]=i+36,a[2]=1163280727,a[3]=544501094,a[4]=16,a[5]=65537,a[6]=44100,a[7]=88200,a[8]=1048578,a[9]=1635017060,a[10]=i,i+=44;for(var s=0,r="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",o="data:audio/wav;base64,";s<i;s+=3){var l=n[s]<<16|n[s+1]<<8|n[s+2];o+=r[l>>18]+r[l>>12&63]+r[l>>6&63]+r[63&l]}return o}([Dn(e[0],0,Pn.length-1),Dn(e[1],0,1),Dn(e[2],0,1),Dn(e[3],0,1),Dn(e[4],0,1),Dn(e[5],0,1),Dn(e[6],0,1),Dn(e[7],-1,1),Dn(e[8],-1,1),Dn(e[9],0,1),Dn(e[10],0,1),Dn(e[11],-1,1),Dn(e[12],0,1),Dn(e[13],0,1),Dn(e[14],-1,1),Dn(e[15],0,1),Dn(e[16],-1,1),Dn(e[17],-1,1),Dn(e[18],0,1),Dn(e[19],-1,1),Dn(e[20],0,1),Dn(e[21],0,1),Dn(e[22],-1,1),Dn(e[23],0,1)])},onEvent(e){this.delayClock.startTimer(this.data.delay,this.playSound)},playSound(){this.data.enabled&&(this.player.currentTime=0,this.player.play())}});const jn=THREE.Math.degToRad,_n=new THREE.Vector3(0,0,0),zn={geometrytriangle:Ot,geometryedge:Pt,geometryvertex:function(e,t){let n=3*Math.floor(Math.random()*e.length/3);t.fromArray(e,n)}},Nn=["sequence","randomsequence","random"];function Bn(e){return e.toLowerCase()}AFRAME.registerComponent("simple-emitter",{schema:{enabled:{default:!0},count:{default:100},particles:{default:"particles"},textureFrame:{type:"vec2",default:{x:0,y:0}},lifeTime:{default:"1"},loopTime:{default:"0"},colors:{default:""},rotations:{default:""},scales:{default:""},opacities:{default:""},frames:{default:""},frameStyle:{default:"sequence",oneOf:Nn,parse:Bn},velocity:{default:"0 0 0"},acceleration:{default:"0 0 0"},radialVelocity:{default:"0"},radialAcceleration:{default:"0"},angularVelocity:{default:"0 0 0"},angularAcceleration:{default:"0 0 0"},orbitalVelocity:{default:"0"},orbitalAcceleration:{default:"0"},spawnShape:{default:"point",oneOf:["point","geometrytriangle","geometryedge","geometryvertex","circle","sphere","box","insidecircle","insidesphere","insidebox"],parse:Bn},spawnGeometry:{type:"selector"}},multiple:!0,init(){this.particleSystem=this.el.sceneEl.systems["simple-particles"].getParticles(this.data.particles),this.startIndex=void 0,this.endIndex=void 0,this.maxLifeTime=void 0,this.spawnCount=0,this.particles=[],this.enabled=!0,this.spawnOffsets=void 0},remove(){this.startIndex&&this.particleSystem.releaseParticles(this.startIndex)},update(e){const t=this.data;if("string"==typeof t)return void se(this,`attributes are incorrectly formatted '${t}'`);this.lifeTime=_(t.lifeTime),this.loopTime=_(t.loopTime),this.rotations=z(t.rotations,jn),this.scales=z(t.scales),this.opacities=z(t.opacities),this.colors=j(t.colors),this.frames=z(t.frames),this.frameStyle=Nn.indexOf(t.frameStyle)?Nn.indexOf(t.frameStyle):0,this.velocity=N(t.velocity),this.acceleration=N(t.acceleration),this.radialVelocity=_(t.radialVelocity),this.radialAcceleration=_(t.radialAcceleration),this.angularVelocity=N(t.angularVelocity),this.angularAcceleration=N(t.angularAcceleration),this.orbitalVelocity=_(t.orbitalVelocity),this.orbitalAcceleration=_(t.orbitalAcceleration),zn[t.spawnShape]&&t.spawnGeometry!==e.spawnGeometry?(this.spawnGeometryFunction=zn[t.spawnShape],this.spawnOffsets=this.calcSpawnOffsetsFromGeometry(t.spawnGeometry||this.el)):(this.spawnGeometryFunction=void 0,this.spawnOffsets=void 0),(t.textureFrame.x>64||t.textureFrame.y>64||t.textureFrame.x<0||t.textureFrame.y<0)&&re(this,`textureFrame (${t.textureFrame.x},${t.textureFrame.y}) is expected in the range (0,64) x (0,64)`),t.textureFrame.x===~~t.textureFrame.x&&t.textureFrame.y===~~t.textureFrame.y||re(this,"textureFrame must be an integer value");const n=this.particleSystem;n?(this.maxLifeTime=B(this.lifeTime),this.startIndex&&(n.releaseParticles(this.startIndex),this.startIndex=void 0,this.endIndex=void 0),this.startIndex=n.allocateParticles(t.count),void 0!==this.startIndex&&(this.endIndex=this.startIndex+t.count),this.enabled=this.data.enabled,this.createParticles(0)):this.enabled=!1},createParticles(e){const t=this.data,n=Math.max(U(this.loopTime),B(this.lifeTime)),i=n/t.count;this.el.object3D.updateMatrixWorld();for(let t=this.startIndex;t<this.endIndex;t++)this.spawn(t,e+t*i,n);this.particleSystem.needsUpdate()},spawn:function(){const e=new THREE.Vector3;return function(t,n,i){const a=this.data,s=q(this.scales),r=q(this.rotations),o=q(this.colors),l=q(this.opacities),c=q(this.frames),d=U(this.lifeTime),h=U(this.velocity),u=U(this.acceleration),m=U(this.radialVelocity),p=U(this.radialAcceleration),f=U(this.angularVelocity),g=U(this.angularAcceleration),v=U(this.orbitalVelocity),y=U(this.orbitalAcceleration);this.spawnGeometryFunction&&this.spawnOffsets?this.spawnGeometryFunction(this.spawnOffsets,e):e.copy(_n);const b=this.particleSystem;b.setMatrixAt(t,this.el.object3D.matrixWorld),b.setPositionAt(t,e.x,e.y,e.z),b.setScalesAt(t,s),b.setColorsAt(t,o),b.setRotationsAt(t,r),b.setOpacitiesAt(t,l);const E=c.length>0?c[0]:0,x=c.length>1?c[1]:E;b.setFrameAt(t,this.frameStyle,E,x,a.textureFrame.x,a.textureFrame.y),b.setTimingsAt(t,n,d,i),b.setVelocityAt(t,h.x,h.y,h.z,m),b.setAccelerationAt(t,u.x,u.y,u.z,p),b.setAngularVelocityAt(t,f.x,f.y,f.z,v),b.setAngularAccelerationAt(t,g.x,g.y,g.z,y)}}(),calcSpawnOffsetsFromGeometry(e){if(!e||!e.object3D)return;let t=[];const n=new THREE.Vector3,i=new THREE.Matrix4,a=new THREE.Matrix4;return e.object3D.updateMatrixWorld(),i.getInverse(e.object3D.matrixWorld),e.object3D.traverse(e=>{if(!e.geometry||!e.geometry.getAttribute)return;const s=e.geometry.getAttribute("position");if(s&&3===s.itemSize)for(let r=0;r<s.count;r++)a.copy(e.matrixWorld).multiply(i),n.fromBufferAttribute(s,r).applyMatrix4(a),t.push(n.x,n.y,n.z)}),Float32Array.from(t)}});const Vn=new THREE.DataTexture(new Uint8Array(3).fill(255),1,1,THREE.RGBFormat);Vn.needsUpdate=!0;const Un={none:THREE.NoBlending,normal:THREE.NormalBlending,additive:THREE.AdditiveBlending,subtractive:THREE.SubtractiveBlending,multiply:THREE.MultiplyBlending};AFRAME.registerSystem("simple-particles",{schema:{enabled:{default:!0}},init(){this.simpleParticles={}},registerParticles(e,t){this.simpleParticles[e]?re(`name '${e}' already in use`):this.simpleParticles[e]=t},unregisterParticles(e,t){this.simpleParticles[e]!==t?re(`could not find particles '${e}'`):this.simpleParticles[e]=void 0},getParticles(e){return this.simpleParticles[e]}}),AFRAME.registerComponent("simple-particles",{schema:{name:{default:"particles"},count:{default:1e3},texture:{type:"map"},textureFrame:{type:"vec2",default:{x:1,y:1}},particleType:{default:"particle",oneOf:["particle","ribbon"]},particleSize:{default:10},transparent:{default:!1},alphaTest:{default:0},depthWrite:{default:!0},depthTest:{default:!0},blending:{default:"normal",oneOf:["none","normal","additive","subtractive","multiply"],parse:function(e){return e.toLowerCase()}},fog:{default:!0},usePerspective:{default:!0},useLinearMotion:{default:!0},useOrbitalMotion:{default:!0},useAngularMotion:{default:!0},useRadialMotion:{default:!0},useFramesOrRotation:{default:!0}},multiple:!0,init(){this.mesh=void 0,this.material=void 0,this.geometry=void 0,this.system.registerParticles(this.data.name,this),this.blocks=function(e){const t=[{index:0,size:e}],n=[];function i(e){let n=!1;for(let i=0;!n&&i<t.length;i++){const a=t[i];if(a.index==e.index+e.size)a.index=e.index,a.size+=e.size,n=!0;else if(a.index+a.size===e.index){a.size+=e.size;const s=t[i+1];s&&s.index===a.index+a.size&&(a.size+=s.size,t.splice(i+1,1)),n=!0}else a.index>e.index&&(t.splice(i,0,e),n=!0)}n||t.push(e)}return{allocate:function(e){for(let i=t.length-1;i>=0;i--){const a=t[i],s=a.size-e;if(s>=0){let r;return s>0?(r={index:a.index,size:e},a.index+=e,a.size=s):(r=a,t.splice(i,1)),n.push(r),r.index}}},release:function(e){for(let t=0;t<n.length;t++){const a=n[t];if(a.index===e){const e=a.size;return n.splice(t,1),i(a),e}}return 0},maxUsed:function(){return n.reduce((e,t)=>Math.max(e,t.index+t.size),0)}}}(this.data.count),this.createMesh(this.data.count)},remove(){this.system.unregisterParticles(this.data.name,this)},update(e){const t=this.data;t.texture!==e.texture&&this.loadTexture(t.texture),(t.textureFrame.x>64||t.textureFrame.y>64||t.textureFrame.x<1||t.textureFrame.y<1)&&re(this,`textureFrame (${t.textureFrame.x},${t.textureFrame.y}) is expected in the range (1,64) x (1,64)`),t.textureFrame.x===~~t.textureFrame.x&&t.textureFrame.y===~~t.textureFrame.y||re(this,"textureFrame must be an integer value"),this.updateMaterial(this.material)},tick(e,t){this.material&&(this.material.uniforms.t.value=e/1e3)},createMesh(e){this.geometry=new THREE.BufferGeometry,this.updateGeometry(this.geometry,e),this.material=new THREE.RawShaderMaterial({uniforms:{map:{type:"t",value:Vn},textureFrame:{value:new THREE.Vector2(1,1)},particleSize:{value:10},usePerspective:{value:1},t:{value:0},fogDensity:{value:25e-5},fogNear:{value:1},fogFar:{value:2e3},fogColor:{value:new THREE.Color(16777215)}},fragmentShader:Gn,vertexShader:qn,defines:{}}),this.mesh=new THREE.Points(this.geometry,this.material),this.mesh.frustumCulled=!1,this.el.sceneEl.object3D.add(this.mesh)},updateGeometry(e,t){e.addAttribute("row1",new THREE.Float32BufferAttribute(new Float32Array(4*t),4)),e.addAttribute("row2",new THREE.Float32BufferAttribute(new Float32Array(4*t),4)),e.addAttribute("row3",new THREE.Float32BufferAttribute(new Float32Array(4*t),4)),e.addAttribute("position",new THREE.Float32BufferAttribute(new Float32Array(3*t),3)),e.addAttribute("scales",new THREE.Float32BufferAttribute(new Float32Array(3*t),3)),e.addAttribute("rotations",new THREE.Float32BufferAttribute(new Float32Array(3*t),3)),e.addAttribute("colors",new THREE.Float32BufferAttribute(new Float32Array(3*t),3)),e.addAttribute("opacities",new THREE.Float32BufferAttribute(new Float32Array(3*t).fill(1),3)),e.addAttribute("frame",new THREE.Float32BufferAttribute(new Float32Array(2*t),2)),e.addAttribute("timings",new THREE.Float32BufferAttribute(new Float32Array(4*t),4)),e.addAttribute("velocity",new THREE.Float32BufferAttribute(new Float32Array(4*t),4)),e.addAttribute("acceleration",new THREE.Float32BufferAttribute(new Float32Array(4*t),4)),e.addAttribute("angularvelocity",new THREE.Float32BufferAttribute(new Float32Array(4*t),4)),e.addAttribute("angularacceleration",new THREE.Float32BufferAttribute(new Float32Array(4*t),4));const n=new THREE.Matrix4;for(let e=0;e<t;e++)this.setMatrixAt(e,n)},updateMaterial(e){const t=this.data;e.uniforms.particleSize.value=t.particleSize,e.uniforms.textureFrame.value.x=t.textureFrame.x,e.uniforms.textureFrame.value.y=t.textureFrame.y,e.uniforms.usePerspective.value=t.usePerspective?1:0,e.transparent=t.transparent,e.alphaTest=t.alphaTest,e.blending=Un[t.blending],e.fog=t.fog,e.depthWrite=t.depthWrite,e.depthTest=t.depthTest;const n={};t.useAngularMotion&&(n.USE_ANGULAR_MOTION=!0),t.useRadialMotion&&(n.USE_RADIAL_MOTION=!0),t.useOrbitalMotion&&(n.USE_ORBITAL_MOTION=!0),t.useLinearMotion&&(n.USE_LINEAR_MOTION=!0),t.useFramesOrRotation&&(n.USE_FRAMES_OR_ROTATION=!0),t.fog&&(n.USE_FOG=!0),e.defines=n,e.needsUpdate=!0},loadTexture(e){if(e){this.el.sceneEl.systems.material.loadTexture(e,{src:e},e=>{this.material.uniforms.map.value=e})}else this.material.uniforms.map.value=Vn},setMatrixAt(e,t){const n=t.elements,i=this.geometry.getAttribute("row1"),a=this.geometry.getAttribute("row2"),s=this.geometry.getAttribute("row3");i.setXYZW(e,n[0],n[4],n[8],n[12]),a.setXYZW(e,n[1],n[5],n[9],n[13]),s.setXYZW(e,n[2],n[6],n[10],n[14])},setPositionAt(e,t,n,i){const a=this.geometry.getAttribute("position");Array.isArray(t)?(i=t[2],n=t[1],t=t[0]):"object"==typeof t&&(i=t.z,n=t.y,t=t.x),a.setXYZ(e,t,n,i)},setColorsAt(e,t){function n(e,t,n){return~~(255*e)/256+~~(255*t)/65536+~~(255*n)/16777216}const i=this.geometry.getAttribute("colors"),a=t[0],s=t[1],r=t[2];let o,l,c;switch(t.length){case 0:o=l=c=n(1,1,1);break;case 1:o=n(a.r,a.r,a.r),l=n(a.g,a.g,a.g),c=n(a.b,a.b,a.b);break;case 2:o=n(a.r,.5*(a.r+s.r),s.r),l=n(a.g,.5*(a.g+s.g),s.g),c=n(a.b,.5*(a.b+s.b),s.b);break;default:o=n(a.r,s.r,r.r),l=n(a.g,s.g,r.g),c=n(a.b,s.b,r.b)}i.setXYZ(e,o,l,c)},setOpacitiesAt(e,t){const n=this.geometry.getAttribute("opacities");this.setKeyframesAt(n,e,t,1)},setTimingsAt(e,t,n,i,a=Math.random()){this.geometry.getAttribute("timings").setXYZW(e,t,n,i,a)},setFrameAt(e,t,n,i,a=0,s=0){const r=~~(a=a||this.data.textureFrame.x)+.015625*~~(s=s||this.data.textureFrame.y)+3814697265625e-18*~~n,o=t+3814697265625e-18*~~i;this.geometry.getAttribute("frame").setXY(e,r,o)},setScalesAt(e,t){const n=this.geometry.getAttribute("scales");this.setKeyframesAt(n,e,t,1)},setRotationsAt(e,t){const n=this.geometry.getAttribute("rotations");this.setKeyframesAt(n,e,t,0)},setVelocityAt(e,t,n,i,a=0){this.geometry.getAttribute("velocity").setXYZW(e,t,n,i,a)},setAccelerationAt(e,t,n,i,a=0){this.geometry.getAttribute("acceleration").setXYZW(e,t,n,i,a)},setAngularVelocityAt(e,t,n,i,a=0){this.geometry.getAttribute("angularvelocity").setXYZW(e,t,n,i,a)},setAngularAccelerationAt(e,t,n,i,a=0){this.geometry.getAttribute("angularacceleration").setXYZW(e,t,n,i,a)},setKeyframesAt(e,t,n,i){const a=n[0],s=n[1],r=n[2];switch(n.length){case 0:e.setXYZ(t,i,i,i);break;case 1:e.setXYZ(t,a,a,a);break;case 2:e.setXYZ(t,a,.5*(a+s),s);break;default:e.setXYZ(t,a,s,r)}},needsUpdate(){this.geometry.getAttribute("row1").needsUpdate=!0,this.geometry.getAttribute("row2").needsUpdate=!0,this.geometry.getAttribute("row3").needsUpdate=!0,this.geometry.getAttribute("position").needsUpdate=!0,this.geometry.getAttribute("scales").needsUpdate=!0,this.geometry.getAttribute("colors").needsUpdate=!0,this.geometry.getAttribute("opacities").needsUpdate=!0,this.geometry.getAttribute("rotations").needsUpdate=!0,this.geometry.getAttribute("timings").needsUpdate=!0,this.geometry.getAttribute("frame").needsUpdate=!0,this.geometry.getAttribute("velocity").needsUpdate=!0,this.geometry.getAttribute("acceleration").needsUpdate=!0},multipleNeedsUpdate(e){for(let t of e)this.needsUpdate(t)},allocateParticles(e){return this.blocks.allocate(e)},releaseParticles(e){const t=this.blocks.release(e);if(t>0){const n=this.geometry.getAttribute("scales");for(let i=e;i<e+t;i++)n.setXYZ(i,0,0,0)}return t}});const qn="\nprecision highp float;\nprecision highp int;\n\nattribute vec4 row1;\nattribute vec4 row2;\nattribute vec4 row3;\nattribute vec3 position;\nattribute vec3 scales;\nattribute vec3 rotations;\nattribute vec3 colors;\nattribute vec3 opacities;\nattribute vec4 timings;\nattribute vec2 frame;\nattribute vec4 velocity;\nattribute vec4 acceleration;\nattribute vec4 angularvelocity;\nattribute vec4 angularacceleration;\n\nuniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\nuniform vec2 textureFrame;\nuniform float particleSize;\nuniform float usePerspective;\nuniform float t;\n\nvarying mat3 vUvTransform;\nvarying vec4 vParticleColor;\nvarying vec2 vUv;\nvarying float vFogDepth;\n\nfloat pseudoRandom( const float seed )\n{\n  return mod( 1664525.*seed + 1013904223., 4294967296. )/4294967296.;\n}\n\nvec3 unpackFrame( float pack )\n{\n  float y = fract( pack ) * 64.;\n  return floor( vec3( pack, y, fract( y ) * 4096. ) );\n}\n\nvec3 unpackRGB( float pack )\n{\n  vec3 enc = fract( pack * vec3( 1., 256., 65536. ) );\n  enc -= enc.yzz * vec3( 1./256., 1./256., 0. );\n  return enc;\n}\n\nfloat interpolate( const vec3 keys, const float r )\n{\n  float k = r*2.;\n  return k < 1. ? mix( keys.x, keys.y, k ) : mix( keys.y, keys.z, k - 1. );\n}\n\n// assumes euler order is YXZ\nvec4 eulerToQuaternion( const vec3 euler )\n{\n  // from https://github.com/mrdoob/three.js/blob/master/src/math/Quaternion.js\n\n  vec3 c = cos( euler * .5 );\n  vec3 s = sin( euler * .5 );\n\n  return vec4(\n    s.x * c.y * c.z + c.x * s.y * s.z,\n    c.x * s.y * c.z - s.x * c.y * s.z,\n    c.x * c.y * s.z - s.x * s.y * c.z,\n    c.x * c.y * c.z + s.x * s.y * s.z\n  );\n}\n\n// from http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm\nvec4 axisAngleToQuaternion( const vec3 axis, const float angle ) \n{\n  return vec4( axis * sin( angle*.5 ), cos( angle*.5 ) );\n}\n\nvec3 applyQuaternion( const vec3 v, const vec4 q )\n{\n  return v + 2. * cross( q.xyz, cross( q.xyz, v ) + q.w * v );\n}\n\nvoid main()\n{\n  float spawnTime = timings.x;\n  float lifeTime = timings.y;\n  float loopTime = timings.z;\n  float seed = timings.w;\n  float age = mod( t - spawnTime, loopTime );\n  float timeRatio = age / lifeTime;\n\n  float scale = interpolate( scales, timeRatio );\n  float rotation = interpolate( rotations, timeRatio );\n  float opacity = interpolate( opacities, timeRatio );\n  vec3 color = vec3(\n    interpolate( unpackRGB( colors.x ), timeRatio ),\n    interpolate( unpackRGB( colors.y ), timeRatio ),\n    interpolate( unpackRGB( colors.z ), timeRatio )\n  );\n\n  mat4 particleMatrix = mat4(\n    vec4( row1.x, row2.x, row3.x, 0. ),\n    vec4( row1.y, row2.y, row3.y, 0. ),\n    vec4( row1.z, row2.z, row3.z, 0. ),\n    vec4( row1.w, row2.w, row3.w, 1. )\n  );\n\n  float distance = length( position );\n  vec3 direction = distance == 0. ? position : position / distance;\n\n#if defined(USE_RADIAL_MOTION)\n  distance += ( .5 * acceleration.w * age + velocity.w ) * age;\n#endif\n\n#if defined(USE_ANGULAR_MOTION)\n  if ( length( angularacceleration.xyz ) > 0. || length( angularvelocity.xyz ) > 0. )\n  {\n    vec3 angularMotion = ( .5 * angularacceleration.xyz * age + angularvelocity.xyz ) * age;\n    direction = applyQuaternion( direction, eulerToQuaternion( angularMotion ) );\n  }\n#endif\n\n#if defined(USE_ORBITAL_MOTION)\n  if ( angularacceleration.w != 0. || angularvelocity.w != 0. ) \n  {\n    float orbitalMotion = ( .5 * angularacceleration.w * age + angularvelocity.w ) * age;\n    vec3 axis;\n    axis.x = pseudoRandom(spawnTime + loopTime);\n    axis.y = pseudoRandom(axis.x);\n    axis.z = pseudoRandom(axis.y);\n    normalize(axis);\n    direction = applyQuaternion( direction, axisAngleToQuaternion( axis, orbitalMotion ) );\n  }\n#endif\n\n  vec3 motion = direction * distance;\n  \n#if defined(USE_LINEAR_MOTION)\n  motion += ( .5 * acceleration.xyz * age + velocity.xyz ) * age;\n#endif\n\n  vec4 mvPosition = modelViewMatrix * particleMatrix * vec4( motion, 1. );\n\n  vParticleColor = vec4( color, opacity );\n  vUv = vec2( 0. );\n  vFogDepth = -mvPosition.z;\n\n  vUvTransform = mat3( 1. );\n\n#if defined(USE_FRAMES_OR_ROTATION)\n\n  vec3 frameInfoA = unpackFrame( frame.x );\n  vec3 frameInfoB = unpackFrame( frame.y );\n\n  float frameWidth = frameInfoA.x;\n  float frameHeight = frameInfoA.y;\n  float startFrame = frameInfoA.z;\n  float endFrame = frameInfoB.z;\n  float frameStyle = frameInfoB.x;\n  float invFrameWidth = 1./frameWidth;\n  float invFrameHeight = 1./frameHeight;\n  float numFrames = endFrame - startFrame + 1.;\n  float currentFrame = floor( mix( startFrame, endFrame + .99999, timeRatio ) );\n\n  currentFrame = frameStyle == 0. ? currentFrame \n    : frameStyle == 1. ? ( floor( pseudoRandom( currentFrame * 6311. + seed ) * numFrames ) + startFrame  )\n    : ( floor( seed * numFrames ) + startFrame );\n\n  float tx = mod( currentFrame, frameWidth ) * invFrameWidth;\n  float ty = 1. - floor( currentFrame * invFrameWidth ) * invFrameHeight;\n  float sx = invFrameWidth;\n  float sy = invFrameHeight;\n  float cx = .5 * sx;\n  float cy = -.5 * sy;\n  float c = cos( rotation );\n  float s = sin( rotation );\n\n  mat3 uvrot = mat3( vec3( c, -s, 0. ), vec3( s, c, 0. ), vec3( 0., 0., 1.) );\n  mat3 uvtrans = mat3( vec3( 1., 0., 0. ), vec3( 0., 1., 0. ), vec3( tx + cx, ty + cy, 1. ) );\n  mat3 uvscale = mat3( vec3( sx, 0., 0. ), vec3( 0., sy, 0. ), vec3( 0., 0., 1.) );\n  mat3 uvcenter = mat3( vec3( 1., 0., 0. ), vec3( 0., 1., 0. ), vec3( -cx / sx, cy / sy, 1. ) );  \n\n  vUvTransform = uvtrans * uvscale * uvrot * uvcenter;\n\n#endif // USE_FRAMES_OR_ROTATION\n\n#if defined(USE_RIBBON)\n#else\n  gl_PointSize = scale * particleSize * mix( 1., 1. / - mvPosition.z, usePerspective );\n#endif // USE_RIBBON\n\n  gl_Position = projectionMatrix * mvPosition;\n\n  if (scale <= 0. || timeRatio < 0. || timeRatio > 1. )\n  {\n    gl_Position.w = -2.; // don't draw\n  }\n}",Gn="\nprecision highp float;\nprecision highp int;\n\nuniform sampler2D map;\nuniform vec3 fogColor;\nuniform float fogNear;\nuniform float fogFar;\n\nvarying mat3 vUvTransform;\nvarying vec4 vParticleColor;\nvarying vec2 vUv;\nvarying float vFogDepth;\n\nvoid main()\n{\n\n#if defined(USE_RIBBON)\n  vec2 uv = ( vUvTransform * vec3( vUv, 1. ) ).xy;\n#else\n  vec2 uv = ( vUvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1. ) ).xy;\n#endif // USE_RIBBON\n\n  vec4 diffuseColor = vParticleColor;\n\n  vec4 mapTexel = texture2D( map, uv );\n  // diffuseColor *= mapTexelToLinear( mapTexel );\n  diffuseColor *= mapTexel;\n\n#if defined(ALPHATEST)\n  if ( diffuseColor.a < ALPHATEST ) {\n    discard;\n  }\n#endif // ALPHATEST\n\n  gl_FragColor = diffuseColor;\n\n#if defined(USE_FOG)\n  float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );\n\n  gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif // USE_FOG\n}",Wn=THREE.Math.degToRad,Qn={acceleration:"USE_PARTICLE_ACCELERATION",angularAcceleration:"USE_PARTICLE_ANGULAR_ACCELERATION",angularVelocity:"USE_PARTICLE_ANGULAR_VELOCITY",color:"USE_PARTICLE_COLOR",textureFrame:"USE_PARTICLE_FRAMES",textureCount:"USE_PARTICLE_FRAMES",textureLoop:"USE_PARTICLE_FRAMES",position:"USE_PARTICLE_OFFSET",opacity:"USE_PARTICLE_OPACITY",radialAcceleration:"USE_PARTICLE_RADIAL_ACCELERATION",radialPosition:"USE_PARTICLE_RADIAL_OFFSET",radialVelocity:"USE_PARTICLE_RADIAL_VELOCITY",scale:"USE_PARTICLE_SCALE",velocity:"USE_PARTICLE_VELOCITY",orbitalVelocity:"USE_PARTICLE_ORBITAL",orbitalAcceleration:"USE_PARTICLE_ORBITAL",drag:"USE_PARTICLE_DRAG",destinationWeight:"USE_PARTICLE_DESTINATION",screenDepthOffset:"USE_PARTICLE_SCREEN_DEPTH_OFFSET",source:"USE_PARTICLE_SOURCE",model:"USE_PARTICLE_SOURCE"},$n=["overtime","interval"],Yn=["newest","oldest","any"],Xn=["x","y","z"],Zn=e=>e.reduce((e,t)=>Array.isArray(t)?e.concat(Zn(t)):e.concat(t),[]),Kn=(e,t)=>{let n=e.split("->").map(e=>e.trim().split(" ").map(e=>{const t=Number(e);return isNaN(t)?void 0:t}));return 1===n.length&&(n[1]=n[0]),n.length=2,Zn(n.map(e=>t.map((t,n)=>void 0===e[n]?t:e[n])))},Jn=(e,t)=>Zn(e.split(",").map(e=>Kn(e,t)));function ei(e){return e.toLowerCase()}let ti=new THREE.DataTexture(new Uint8Array(3).fill(255),1,1,THREE.RGBFormat);ti.needsUpdate=!0;const ni={none:THREE.NoBlending,normal:THREE.NormalBlending,additive:THREE.AdditiveBlending,subtractive:THREE.SubtractiveBlending,multiply:THREE.MultiplyBlending},ii={double:THREE.DoubleSide,front:THREE.FrontSide,back:THREE.BackSide};AFRAME.registerComponent("sprite-particles",{schema:{texture:{type:"map"},delay:{default:0},duration:{default:-1},spawnType:{default:"continuous",oneOf:["continuous","burst"],parse:ei},spawnRate:{default:10},source:{type:"selector"},textureFrame:{type:"vec2",default:{x:1,y:1}},textureCount:{type:"int",default:0},textureLoop:{default:1},randomizeFrames:{default:!1},trailInterval:{default:0},trailLifeTime:{default:"0"},trailType:{default:"particle",oneOf:["particle","ribbon","ribbon3d"]},ribbonWidth:{default:1},ribbonShape:{default:"flat",oneOf:["flat","taperin","taperout","taper"],parse:ei},ribbonUVType:{default:"overtime",oneOf:$n,parse:ei},emitterColor:{type:"color"},lifeTime:{default:"1"},position:{default:"0 0 0"},velocity:{default:"0 0 0"},acceleration:{default:"0 0 0"},radialType:{default:"circle",oneOf:["circle","sphere","circlexy","circlexz"],parse:ei},radialPosition:{default:"0"},radialVelocity:{default:"0"},radialAcceleration:{default:"0"},angularVelocity:{default:"0 0 0"},angularAcceleration:{default:"0 0 0"},orbitalVelocity:{default:"0"},orbitalAcceleration:{default:"0"},scale:{default:"1"},color:{default:"white",parse:ei},rotation:{default:"0"},opacity:{default:"1"},velocityScale:{default:0},velocityScaleMinMax:{type:"vec2",default:{x:0,y:3}},drag:{default:0},destination:{type:"selector"},destinationOffset:{default:"0 0 0"},destinationWeight:{default:"0"},events:{default:""},enabled:{default:!0},emitterTime:{default:0},model:{type:"selector"},modelFill:{default:"triangle",oneOf:["triangle","edge","vertex"],parse:ei},direction:{default:"forward",oneOf:["forward","backward"],parse:ei},particleOrder:{default:"any",oneOf:Yn},ribbonUVMultiplier:{default:1},materialSide:{default:"double",oneOf:["double","front","back"],parse:ei},screenDepthOffset:{default:0},alphaTest:{default:0},fog:{default:!0},depthWrite:{default:!1},depthTest:{default:!0},blending:{default:"normal",oneOf:["none","normal","additive","subtractive","multiply"],parse:ei},transparent:{default:!0},particleSize:{default:100},usePerspective:{default:!0},seed:{type:"number",default:-1},overTimeSlots:{type:"int",default:5},frustumCulled:{default:!0},editorObject:{default:!0}},multiple:!0,help:"https://github.com/harlyq/aframe-sprite-particles-component",init(){this.handleObject3DSet=this.handleObject3DSet.bind(this),this.count=0,this.trailCount=0,this.overTimeArrayLength=0,this.emitterTime=0,this.delayTime=0,this.lifeTime=[1,1],this.trailLifeTime=[0,0],this.paused=!1,this.textureFrames=new Float32Array(4),this.offset=new Float32Array(8),this.velocity=new Float32Array(8),this.acceleration=new Float32Array(8),this.angularVelocity=new Float32Array(8),this.angularAcceleration=new Float32Array(8),this.orbital=new Float32Array(4),this.colorOverTime,this.rotationScaleOverTime,this.params=new Float32Array(20),this.velocityScale=new Float32Array(3),this.emitterColor=new THREE.Vector3,this.destination=new Float32Array(8),this.destinationOffset,this.destinationWeight,this.nextID=0,this.nextTime=0,this.startDisabled=!this.data.enabled||!!this.data.events,this.manageIDs=!1,this.params[1]=-1,this.eventListener=ne(this.el,this.onEvent.bind(this)),this.delayClock=ee()},remove(){this.mesh&&this.el.removeObject3D(this.mesh.name),this.data.model&&this.data.model.removeEventListener("object3dset",this.handleObject3DSet),this.eventListener.remove(),this.delayClock.clearAllTimers()},update(e){const t=this.data;let n=t.particleSize!==e.particleSize,i=!1;if(t.overTimeSlots===e.overTimeSlots||this.isPlaying||(this.overTimeArrayLength=2*this.data.overTimeSlots+1,this.colorOverTime=new Float32Array(4*this.overTimeArrayLength),this.rotationScaleOverTime=new Float32Array(2*this.overTimeArrayLength),i=!0),this.params[8]=t.particleSize,this.params[9]=t.usePerspective?1:0,this.params[10]="forward"===t.direction?0:1,this.params[11]=THREE.Math.clamp(t.drag,0,1),this.params[15]=1e-5*t.screenDepthOffset,this.params[16]=t.ribbonWidth,this.params[17]=t.ribbonUVMultiplier,this.textureFrames[0]=t.textureFrame.x,this.textureFrames[1]=t.textureFrame.y,this.textureFrames[2]=t.textureCount>0?t.textureCount:t.textureFrame.x*t.textureFrame.y,this.textureFrames[3]=t.textureLoop,this.velocityScale[0]=t.velocityScale,this.velocityScale[1]=t.velocityScaleMinMax.x,this.velocityScale[2]=t.velocityScaleMinMax.y,this.material&&(this.material.alphaTest=t.alphaTest,this.material.depthTest=t.depthTest,this.material.depthWrite=t.depthWrite,this.material.blending=ni[t.blending],this.material.fog=t.fog),t.seed!==e.seed&&(this.seed=t.seed,this.params[6]=t.seed>=0?t.seed:Math.random()),t.ribbonUVType!==e.ribbonUVType&&(this.params[18]=-1===$n.indexOf(t.ribbonUVType)?0:$n.indexOf(t.ribbonUVType)),t.radialType!==e.radialType&&(this.params[2]=["sphere","circlexy","circle"].includes(t.radialType)?1:0,this.params[19]=["sphere","circlexz"].includes(t.radialType)?1:0),this.mesh&&t.frustumCulled!==e.frustumCulled&&(this.mesh.frustumCulled=t.frustumCulled),t.emitterColor!==e.emitterColor){const e=new THREE.Color(t.emitterColor);this.emitterColor.set(e.r,e.g,e.b)}if(t.position===e.position&&t.radialPosition===e.radialPosition||(this.updateVec4XYZRange(t.position,"offset"),this.updateVec4WRange(t.radialPosition,[0],"offset"),n=!0),t.velocity===e.velocity&&t.radialVelocity===e.radialVelocity||(this.updateVec4XYZRange(t.velocity,"velocity"),this.updateVec4WRange(t.radialVelocity,[0],"velocity"),n=!0),t.acceleration===e.acceleration&&t.radialAcceleration===e.radialAcceleration||(this.updateVec4XYZRange(t.acceleration,"acceleration"),this.updateVec4WRange(t.radialAcceleration,[0],"acceleration"),n=!0),(t.rotation!==e.rotation||t.scale!==e.scale||i)&&(this.updateRotationScaleOverTime(),n=!0),(t.color!==e.color||t.opacity!==e.opacity||i)&&this.updateColorOverTime(),t.lifeTime!==e.lifeTime&&(this.lifeTime=this.updateVec4WRange(t.lifeTime,[1],"angularVelocity")),t.angularVelocity!==e.angularVelocity&&this.updateAngularVec4XYZRange(t.angularVelocity,"angularVelocity"),t.trailLifeTime!==e.trailLifeTime&&(this.trailLifeTime=Kn(t.trailLifeTime,[0]).map((e,t)=>e>0?e:this.lifeTime[t]),this.angularAcceleration[3]=this.trailLifeTime[0],this.angularAcceleration[7]=this.trailLifeTime[1]),t.angularAcceleration!==e.angularAcceleration&&this.updateAngularVec4XYZRange(t.angularAcceleration,"angularAcceleration"),t.orbitalVelocity!==e.orbitalVelocity&&this.updateAngularVec2PartRange(t.orbitalVelocity,[0],"orbital",0),t.orbitalAcceleration!==e.orbitalAcceleration&&this.updateAngularVec2PartRange(t.orbitalAcceleration,[0],"orbital",1),t.destinationOffset!==e.destinationOffset&&(this.destinationOffset=this.updateVec4XYZRange(t.destinationOffset,"destination")),t.destinationWeight!==e.destinationWeight&&(this.destinationWeight=this.updateVec4WRange(t.destinationWeight,[0],"destination")),t.duration===e.duration&&t.delay===e.delay&&t.emitterTime===e.emitterTime||(this.params[3]=t.duration,this.emitterTime=t.emitterTime,this.delayTime=t.delay),t.spawnType!==e.spawnType||t.spawnRate!==e.spawnRate||t.lifeTime!==e.lifeTime||t.trailInterval!==e.trailInterval){const e=this.lifeTime[1],n=t.trailInterval>0?this.trailLifeTime[1]:0,i=e+n,a=Math.max(1,Math.ceil(i*t.spawnRate));this.trailCount=1+(t.trailInterval>0?Math.ceil(Math.min(n,e)/t.trailInterval):0),this.isRibbon()?(this.trailCount++,this.count=a*this.trailCount*2):this.count=a*this.trailCount,this.params[4]="burst"===t.spawnType?0:1,this.params[5]=t.spawnRate,this.params[7]=this.count,this.params[13]=a,this.params[12]=t.trailInterval,this.params[14]=this.trailCount,this.updateAttributes()}t.enabled&&this.startDisabled&&!t.events&&(this.startDisabled=!1),t.model!==e.model&&t.model&&"getObject3D"in t.model&&(e.model&&e.model.removeEventListener("object3dset",this.handleObject3DSet),this.updateModelMesh(t.model.getObject3D("mesh")),t.model&&t.model.addEventListener("object3dset",this.handleObject3DSet)),this.mesh?this.updateDefines():this.createMesh(),t.materialSide!==e.materialSide&&(this.material.side=ii[t.materialSide]),n&&this.updateBounds(),this.paused&&t.editorObject!==e.editorObject&&this.enableEditorObject(t.editorObject),this.manageIDs=this.manageIDs||!t.enabled||!!t.events||t.source||void 0!==this.el.getDOMAttribute(this.attrName).enabled||t.model||t.delay>0,t.texture!==e.texture&&this.loadTexture(t.texture),t.events!==e.events&&this.eventListener.set(t.events)},tick(e,t){const n=this.data;if(this.startDisabled)return;t>100&&(t=100);const i=t/1e3;n.enabled&&(this.delayTime-=i),this.delayTime>=0||n.model&&!this.modelVertices||(this.emitterTime+=i,this.params[0]=this.emitterTime,this.geometry&&this.manageIDs?this.spawnParticles(this.emitterTime):this.params[1]=-1,n.destination&&n.destination.object3D&&(this.destinationWeight[0]>0||this.destinationWeight[1]>0)&&this.updateDestinationEntity())},pause(){this.paused=!0,this.enableEditorObject(this.data.editorObject),this.eventListener.remove(),this.delayClock.pause()},play(){this.paused=!1,this.enableEditorObject(!1),this.eventListener.add(),this.delayClock.resume()},onEvent(){const e=this,t=this.data;this.delayClock.startTimer(t.delay,()=>{e.emitterTime=t.emitterTime,e.nextTime=0,e.nextID=0,e.delayTime=0,e.startDisabled=!1})},handleObject3DSet(e){e.target===this.data.model&&"mesh"===e.detail.type&&this.updateModelMesh(this.data.model.getObject3D("mesh"))},loadTexture(e){if(e){this.el.sceneEl.systems.material.loadTexture(e,{src:e},e=>{this.isRibbon()&&(e.wrapS=THREE.RepeatWrapping),this.material.uniforms.map.value=e})}else this.material.uniforms.map.value=ti},isRibbon(){return this.data.trailInterval>0&&"particle"!==this.data.trailType},createMesh(){const e=this.data;this.geometry=new THREE.BufferGeometry,this.updateAttributes(),this.material=new THREE.ShaderMaterial({uniforms:{map:{type:"t",value:ti},textureFrames:{value:this.textureFrames},params:{value:this.params},offset:{value:this.offset},velocity:{value:this.velocity},acceleration:{value:this.acceleration},angularVelocity:{value:this.angularVelocity},angularAcceleration:{value:this.angularAcceleration},orbital:{value:this.orbital},colorOverTime:{value:this.colorOverTime},rotationScaleOverTime:{value:this.rotationScaleOverTime},velocityScale:{value:this.velocityScale},emitterColor:{value:this.emitterColor},destination:{value:this.destination},fogDensity:{value:25e-5},fogNear:{value:1},fogFar:{value:2e3},fogColor:{value:new THREE.Color(16777215)}},fragmentShader:ci,vertexShader:li,transparent:e.transparent,alphaTest:e.alphaTest,blending:ni[e.blending],fog:e.fog,depthWrite:e.depthWrite,depthTest:e.depthTest,defines:{}}),this.updateDefines(),this.isRibbon()?this.mesh=new THREE.Mesh(this.geometry,[this.material]):this.mesh=new THREE.Points(this.geometry,this.material),this.mesh.frustumCulled=e.frustumCulled,this.mesh.name=this.attrName,this.material.name=this.mesh.name,this.el.setObject3D(this.mesh.name,this.mesh)},updateColorOverTime(){let e=(e=>Zn(e.split(",").map(e=>{let t=e.split("->");return 1===t.length&&(t[1]=t[0]),t.length=2,t.map(e=>new THREE.Color(e.trim()))})))(this.data.color),t=Jn(this.data.opacity,[1]);const n=this.data.overTimeSlots;e.length>2*n&&(e.length=2*n),t.length>2*n&&(t.length=2*n),this.colorOverTime.fill(0),this.colorOverTime[0]=e.length/2,this.colorOverTime[1]=t.length/2;let i=e.length;for(let t=0,n=4;t<i;t++,n+=4){let i=e[t];this.colorOverTime[n]=i.r,this.colorOverTime[n+1]=i.g,this.colorOverTime[n+2]=i.b}i=t.length;for(let e=0,n=4;e<i;e++,n+=4){let i=t[e];this.colorOverTime[n+3]=i}},updateRotationScaleOverTime(){const e=this.data.overTimeSlots;let t=Jn(this.data.rotation,[0]),n=Jn(this.data.scale,[1]);t.length>2*e&&(t.length=2*e),n.length>2*e&&(n.length=2*e),this.rotationScaleOverTime.fill(0),this.rotationScaleOverTime[0]=t.length/2,this.rotationScaleOverTime[1]=n.length/2;let i=t.length;for(let e=0,n=2;e<i;e++,n+=2)this.rotationScaleOverTime[n]=Wn(t[e]);i=n.length;for(let e=0,t=2;e<i;e++,t+=2)this.rotationScaleOverTime[t+1]=n[e]},updateVec4XYZRange(e,t){const n=Kn(e,[0,0,0]);for(let e=0,i=0;e<n.length;)this[t][i++]=n[e++],this[t][i++]=n[e++],this[t][i++]=n[e++],i++;return n},updateAngularVec4XYZRange(e,t){const n=Kn(e,[0,0,0]);for(let e=0,i=0;e<n.length;)this[t][i++]=Wn(n[e++]),this[t][i++]=Wn(n[e++]),this[t][i++]=Wn(n[e++]),i++},updateAngularVec2PartRange(e,t,n,i){const a=Kn(e,t);this[n][i]=Wn(a[0]),this[n][i+2]=Wn(a[1])},updateVec4WRange(e,t,n){let i=Kn(e,t);return this[n][3]=i[0],this[n][7]=i[1],i},updateBounds(){const e=this.data;let t=Math.max(this.lifeTime[0],this.lifeTime[1]);let n=[new Array(4),new Array(4)];e.drag>0&&(t*=1-.5*e.drag);for(let e=0;e<2;e++){const i=0===e?Math.min:Math.max;for(let a=0;a<4;a++){const s=i(this.offset[a],this.offset[a+4]),r=i(this.velocity[a],this.velocity[a+4]),o=i(this.acceleration[a],this.acceleration[a+4]);n[e][a]=s+(r+.5*o*t)*t,n[e][a]=i(n[e][a],s);const l=-r/o;l>0&&l<t&&(n[e][a]=i(n[e][a],s-.5*r*r/o))}}this.modelBounds&&(n[0][0]+=this.modelBounds.min.x,n[0][1]+=this.modelBounds.min.y,n[0][2]+=this.modelBounds.min.z,n[1][0]+=this.modelBounds.max.x,n[1][1]+=this.modelBounds.max.y,n[1][2]+=this.modelBounds.max.z);const i=this.el.getDOMAttribute(this.attrName),a=this.rotationScaleOverTime.reduce((e,t,n)=>1&n?Math.max(e,t):e,0),s=Math.max(Math.abs(n[0][3]),Math.abs(n[1][3]))+45e-5*e.particleSize*a,r="sphere"===e.radialType||i.angularVelocity||i.angularAcceleration||i.orbitalVelocity||i.orbitalAcceleration;n[0][0]-=s,n[0][1]-=s,n[0][2]-=r?s:0,n[1][0]+=s,n[1][1]+=s,n[1][2]+=r?s:0,n[0].length=3,n[0].length=3;const o=Math.max(...n[0].map(Math.abs),...n[1].map(Math.abs));this.geometry.boundingSphere||(this.geometry.boundingSphere=new THREE.Sphere),this.geometry.boundingSphere.radius=o,this.geometry.boundingBox||(this.geometry.boundingBox=new THREE.Box3),this.geometry.boundingBox.min.set(...n[0]),this.geometry.boundingBox.max.set(...n[1]);const l=this.el.getObject3D("mesh");l&&l.isParticlesEditorObject&&this.enableEditorObject(!0)},updateDestinationEntity:function(){let e=new THREE.Vector3,t=new THREE.Vector3;return function(){this.data.destination.object3D.getWorldPosition(e),this.el.object3D.getWorldPosition(t),e.sub(t);for(let t=0,n=Xn.length;t<n;t++)this.destination[t]=e[Xn[t]]+this.destinationOffset[t],this.destination[t+4]=e[Xn[t]]+this.destinationOffset[t+3]}}(),enableEditorObject(e){const t=this.el.getObject3D("mesh");if(!e||t&&!t.isParticlesEditorObject)!e&&t&&t.isParticlesEditorObject&&this.el.removeObject3D("mesh");else{const e=.25,t=new THREE.Vector3(e,e,e).max(this.geometry.boundingBox.max),n=new THREE.Vector3(-e,-e,-e).min(this.geometry.boundingBox.min);let i=new THREE.Box3(n,t),a=new THREE.Box3Helper(i,8421376);a.isParticlesEditorObject=!0,a.visible=!1,this.el.setObject3D("mesh",a)}},updateAttributes(){if(this.geometry){const e=this.count;let t=new Float32Array(e);if(this.startDisabled||this.data.delay>0||this.data.model)t.fill(-1);else for(let n=0;n<e;n++)t[n]=n;if(this.geometry.setAttribute("vertexID",new THREE.Float32BufferAttribute(t,1)),this.geometry.setAttribute("position",new THREE.Float32BufferAttribute(new Float32Array(3*e),3)),this.data.source&&this.geometry.setAttribute("quaternion",new THREE.Float32BufferAttribute(new Float32Array(4*e),4)),this.isRibbon()){this.geometry.clearGroups();const e=this.count/2/this.trailCount,t=6*(this.trailCount-1),n=2*this.trailCount,i=e*t,a=new Array(i);for(let e=0,s=0;e<i;e+=t,s++){this.geometry.addGroup(e,t,0);for(let i=0,r=0;i<t;i+=6,r+=2){const t=s*n+r;a[e+i]=t,a[e+i+1]=t+2,a[e+i+2]=t+3,a[e+i+3]=t,a[e+i+4]=t+3,a[e+i+5]=t+1}}this.geometry.setIndex(a)}}},updateDefines(){const e=this.data,t=Object.keys(this.el.getDOMAttribute(this.attrName)),n=t.map(e=>Qn[e]).filter(e=>e);let i={PARAMS_LENGTH:5,OVER_TIME_ARRAY_LENGTH:this.overTimeArrayLength,RANDOM_REPEAT_COUNT:131072,USE_MAP:!0};for(let e of n)i[e]=!0;e.velocityScale>0&&(i.USE_PARTICLE_VELOCITY_SCALE=!0),e.trailInterval>0&&(this.isRibbon()?"ribbon"===e.trailType?i.USE_RIBBON_TRAILS=!0:i.USE_RIBBON_3D_TRAILS=!0:i.USE_PARTICLE_TRAILS=!0),e.randomizeFrames&&(i.USE_PARTICLE_RANDOMIZE_FRAMES=!0),t.includes("rotation")&&(this.isRibbon()?i.USE_RIBBON_ROTATION=!0:i.USE_PARTICLE_ROTATION=!0);let a="1.";if("taperout"===e.ribbonShape?a="1. - p":"taperin"===e.ribbonShape?a="p":"taper"===e.ribbonShape?a="2. * ( p < .5 ? p : 1. - p )":"="===e.ribbonShape[0]&&(a=e.ribbonShape.slice(1)),i.RIBBON_SHAPE_FUNCTION=a,e.source?i.PARTICLE_ORDER=2:i.PARTICLE_ORDER=Yn.indexOf(e.particleOrder),i.PARTICLE_TRAIL_ORDER=Yn.indexOf(e.particleOrder),Object.keys(i).filter(e=>this.material.defines[e]!==i[e]).length>0)if(this.isPlaying){const e=t.filter(e=>{const t=Qn[e];return t&&!this.material.defines[t]});console.error(`cannot add attributes (${e.join(",")}) at run-time`)}else this.material.defines=i,this.material.needsUpdate=!0},updateModelMesh(e){if(!e)return;this.modelBounds=new THREE.Box3,this.modelVertices;let t=0,n=0,i=0;const a=e=>{if(!e.geometry)return;let a=e.geometry.getAttribute("position");a&&3!==a.itemSize||(0==i?n+=a.array.length:(this.modelVertices.set(a.array,t),t+=a.array.length))};i=0,e.traverse(a),n>0&&(i=1,this.modelVertices=new Float32Array(n),e.traverse(a),ai(this.modelVertices,e.el.object3D.scale),this.modelBounds.setFromArray(this.modelVertices),this.updateBounds())},spawnParticles:function(){let e=new THREE.Vector3,t=new THREE.Quaternion,n=new THREE.Vector3,i=new THREE.Vector3,a=new THREE.Matrix4;return function(s){const r=this.data,o=this.count,l=this.data.spawnRate,c="burst"===r.spawnType,d=c?0:1/l,h=r.source&&null!=r.source.object3D,u=this.modelVertices&&this.modelVertices.length,m=this.isRibbon(),p=u||h;let f=this.geometry.getAttribute("vertexID"),g=this.geometry.getAttribute("position"),v=this.geometry.getAttribute("quaternion");h&&(this.el.object3D.updateMatrixWorld(),r.source.object3D.updateMatrixWorld(),a.getInverse(this.el.object3D.matrixWorld),a.multiply(r.source.object3D.matrixWorld),a.decompose(e,t,n),this.geometry.boundingSphere.center.copy(e));let y=this.nextID%o,b=0,E=y,x=this.nextID,T=si;switch(r.modelFill){case"edge":T=ri;break;case"vertex":T=oi}for(;this.nextTime<s&&b<this.count;){u&&T(this.modelVertices,i);for(let n=0;n<this.trailCount;n++)for(let n=0,a=m?2:1;n<a;n++)x=this.nextID,u&&g.setXYZ(E,i.x,i.y,i.z),h&&(g.setXYZ(E,e.x,e.y,e.z),v.setXYZW(E,t.x,t.y,t.z,t.w)),f.setX(E,r.enabled?x:-1),E=(E+1)%o,b++,p?this.nextID++:this.nextID=E;this.nextTime+=d}if(b>0){const e=this.trailCount*(m?2:1);this.params[1]=Math.floor(x/e),c&&(this.nextTime+=this.lifeTime[1],r.trailInterval>0&&(this.nextTime+=this.trailLifeTime[1])),E<y&&(y=0,b=this.count),(h||u)&&(g.updateRange.offset=3*y,g.updateRange.count=3*b,g.needsUpdate=!0),h&&(v.updateRange.offset=4*y,v.updateRange.count=4*b,v.needsUpdate=!0),f.updateRange.offset=y,f.updateRange.count=b,f.needsUpdate=!0,this.nextID=this.nextID%131072}}}()});const ai=(e,t)=>{if(1!==t.x&&1!==t.y&&1!==t.z)for(let n=0,i=e.length;n<i;n+=3)e[n]*=t.x,e[n+1]*=t.y,e[n+2]*=t.z},si=function(){let e=new THREE.Vector3,t=new THREE.Vector3;return function(n,i){let a,s,r=9*Math.floor(Math.random()*n.length/9);e.fromArray(n,r),t.fromArray(n,r+3),i.fromArray(n,r+6);do{a=Math.random(),s=Math.random()}while(a+s>1);t.sub(e).multiplyScalar(a),i.sub(e).multiplyScalar(s).add(t).add(e)}}(),ri=function(){let e=new THREE.Vector3,t=new THREE.Vector3,n=new THREE.Vector3;return function(i,a){let s=9*Math.floor(Math.random()*i.length/9);e.fromArray(i,s),t.fromArray(i,s+3),n.fromArray(i,s+6);let r=Math.random();r>2/3?a.copy(e).sub(n).multiplyScalar(3*r-2).add(n):r>1/3?a.copy(n).sub(t).multiplyScalar(3*r-1).add(t):a.copy(t).sub(e).multiplyScalar(3*r).add(e)}}();function oi(e,t){let n=3*Math.floor(Math.random()*e.length/3);t.fromArray(e,n)}const li="\n#include <common>\n// #include <color_pars_vertex>\n#include <fog_pars_vertex>\n// #include <morphtarget_pars_vertex>\n// #include <logdepthbuf_pars_vertex>\n// #include <clipping_planes_pars_vertex>\n\nattribute float vertexID;\n\n#if defined(USE_PARTICLE_SOURCE)\nattribute vec4 quaternion;\n#endif\n\nuniform vec4 params[PARAMS_LENGTH];\nuniform vec4 offset[2];\nuniform vec4 velocity[2];\nuniform vec4 acceleration[2];\nuniform vec4 angularVelocity[2];\nuniform vec4 angularAcceleration[2];\nuniform vec2 orbital[2];\nuniform vec4 colorOverTime[OVER_TIME_ARRAY_LENGTH];\nuniform vec2 rotationScaleOverTime[OVER_TIME_ARRAY_LENGTH];\nuniform vec4 textureFrames;\nuniform vec3 velocityScale;\nuniform vec4 destination[2];\n\nvarying mat3 vUvTransform;\nvarying vec4 vParticleColor;\nvarying vec2 vUv;\nvarying float vOverTimeRatio;\n\nfloat VERTS_PER_RIBBON = 2.;\n\n// alternative random algorithm, used for the initial seed.  Provides a better\n// result than using rand()\nfloat pseudoRandom( const float seed )\n{\n  return mod( 1664525.*seed + 1013904223., 4294967296. )/4294967296.; // we don't have enough precision in 32-bit float, but results look ok\n}\n\n// each call to random will produce a different result by varying randI\nfloat randI = 0.;\nfloat random( const float seed )\n{\n  randI += 0.001;\n  return rand( vec2( seed, randI ));\n}\n\nvec3 randVec3Range( const vec3 range0, const vec3 range1, const float seed )\n{\n  vec3 lerps = vec3( random( seed ), random( seed ), random( seed ) );\n  return mix( range0, range1, lerps );\n}\n\nvec2 randVec2Range( const vec2 range0, const vec2 range1, const float seed )\n{\n  vec2 lerps = vec2( random( seed ), random( seed ) );\n  return mix( range0, range1, lerps );\n}\n\nfloat randFloatRange( const float range0, const float range1, const float seed )\n{\n  float lerps = random( seed );\n  return mix( range0, range1, lerps );\n}\n\n// theta.x is the angle in XY, theta.y is the angle in XZ\nvec3 radialToVec3( const float r, const vec2 theta )\n{\n  vec2 cosTheta = cos(theta);\n  vec2 sinTheta = sin(theta);\n  float rc = r * cosTheta.x;\n  float x = rc * cosTheta.y;\n  float y = r * sinTheta.x;\n  float z = rc * sinTheta.y;\n  return vec3( x, y, z );\n}\n\n// array lengths are stored in the first slot, followed by actual values from slot 1 onwards\n// colors are packed min,max,min,max,min,max,...\n// color is packed in xyz and opacity in w, and they may have different length arrays\n\nvec4 calcColorOverTime( const float r, const float seed )\n{\n  vec3 color = vec3(1.);\n  float opacity = 1.;\n\n#if defined(USE_PARTICLE_COLOR)\n  int colorN = int( colorOverTime[0].x );\n  if ( colorN == 1 )\n  {\n    color = randVec3Range( colorOverTime[1].xyz, colorOverTime[2].xyz, seed );\n  }\n  else if ( colorN > 1 )\n  {\n    float ck = r * ( float( colorN ) - 1. );\n    float ci = floor( ck );\n    int i = int( ci )*2 + 1;\n    vec3 sColor = randVec3Range( colorOverTime[i].xyz, colorOverTime[i + 1].xyz, seed );\n    vec3 eColor = randVec3Range( colorOverTime[i + 2].xyz, colorOverTime[i + 3].xyz, seed );\n    color = mix( sColor, eColor, ck - ci );\n  }\n#endif\n\n#if defined(USE_PARTICLE_OPACITY)\n  int opacityN = int( colorOverTime[0].y );\n  if ( opacityN == 1 )\n  {\n    opacity = randFloatRange( colorOverTime[1].w, colorOverTime[2].w, seed );\n  }\n  else if ( opacityN > 1 )\n  {\n    float ok = r * ( float( opacityN ) - 1. );\n    float oi = floor( ok );\n    int j = int( oi )*2 + 1;\n    float sOpacity = randFloatRange( colorOverTime[j].w, colorOverTime[j + 1].w, seed );\n    float eOpacity = randFloatRange( colorOverTime[j + 2].w, colorOverTime[j + 3].w, seed );\n    opacity = mix( sOpacity, eOpacity, ok - oi );\n  }\n#endif\n\n  return vec4( color, opacity );\n}\n\n// as per calcColorOverTime but euler rotation is packed in xyz and scale in w\n\nvec2 calcRotationScaleOverTime( const float r, const float seed )\n{\n  float rotation = 0.;\n  float scale = 1.;\n\n#if defined(USE_PARTICLE_ROTATION) || defined(USE_RIBBON_ROTATION)\n  int rotationN = int( rotationScaleOverTime[0].x );\n  if ( rotationN == 1 )\n  {\n    rotation = randFloatRange( rotationScaleOverTime[1].x, rotationScaleOverTime[2].x, seed );\n  }\n  else if ( rotationN > 1 )\n  {\n    float rk = r * ( float( rotationN ) - 1. );\n    float ri = floor( rk );\n    int i = int( ri )*2 + 1; // *2 because each range is 2 vectors, and +1 because the first vector is for the length info\n    float sRotation = randFloatRange( rotationScaleOverTime[i].x, rotationScaleOverTime[i + 1].x, seed );\n    float eRotation = randFloatRange( rotationScaleOverTime[i + 2].x, rotationScaleOverTime[i + 3].x, seed );\n    rotation = mix( sRotation, eRotation, rk - ri );\n  }\n#endif\n\n#if defined(USE_PARTICLE_SCALE)\n  int scaleN = int( rotationScaleOverTime[0].y );\n  if ( scaleN == 1 )\n  {\n    scale = randFloatRange( rotationScaleOverTime[1].y, rotationScaleOverTime[2].y, seed );\n  }\n  else if ( scaleN > 1 )\n  {\n    float sk = r * ( float( scaleN ) - 1. );\n    float si = floor( sk );\n    int j = int( si )*2 + 1; // *2 because each range is 2 vectors, and +1 because the first vector is for the length info\n    float sScale = randFloatRange( rotationScaleOverTime[j].y, rotationScaleOverTime[j + 1].y, seed );\n    float eScale = randFloatRange( rotationScaleOverTime[j + 2].y, rotationScaleOverTime[j + 3].y, seed );\n    scale = mix( sScale, eScale, sk - si );\n  }\n#endif\n\n  return vec2( rotation, scale );\n}\n\n// assumes euler order is YXZ (standard convention for AFrame)\nvec4 eulerToQuaternion( const vec3 euler )\n{\n  // from https://github.com/mrdoob/three.js/blob/master/src/math/Quaternion.js\n\n  vec3 c = cos( euler * .5 );\n  vec3 s = sin( euler * .5 );\n\n  return vec4(\n    s.x * c.y * c.z + c.x * s.y * s.z,\n    c.x * s.y * c.z - s.x * c.y * s.z,\n    c.x * c.y * s.z - s.x * s.y * c.z,\n    c.x * c.y * c.z + s.x * s.y * s.z\n  );\n}\n\n// from http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm\nvec4 axisAngleToQuaternion( const vec3 axis, const float angle ) \n{\n  return vec4( axis * sin( angle*.5 ), cos( angle*.5 ) );\n}\n\nvec3 applyQuaternion( const vec3 v, const vec4 q )\n{\n  return v + 2. * cross( q.xyz, cross( q.xyz, v ) + q.w * v );\n}\n\nvec3 displacement( const vec3 v, const vec3 a, const float t )\n{\n  return (v + 0.5 * a * t) * t;\n}\n\nfloat displacement1D( const float v, const float a, const float t )\n{\n  return (v + 0.5 * a * t) * t;\n}\n\nfloat ribbonShape( const float p )\n{\n  return RIBBON_SHAPE_FUNCTION;\n}\n\nvec3 particleMotion( const vec3 p, const vec3 v, const vec3 a, const vec3 av, const vec3 aa, const vec3 axis, const float ov, const float oa, const vec3 dest, const float weight, const float t )\n{\n  vec3 pos = p + displacement(v, a, t);\n\n#if defined(USE_PARTICLE_ANGULAR_VELOCITY) || defined(USE_PARTICLE_ANGULAR_ACCELERATION)\n  pos = applyQuaternion( pos, eulerToQuaternion( displacement(av, aa, t) ) );\n#endif\n\n#if defined(USE_PARTICLE_ORBITAL)\n  pos = applyQuaternion( pos, axisAngleToQuaternion( axis, displacement1D(ov, oa, t) ) );\n#endif\n\n#if defined(USE_PARTICLE_SOURCE)\n  pos = applyQuaternion( pos, quaternion );\n#endif\n\npos += position;\n\n#if defined(USE_PARTICLE_DESTINATION)\n  pos = mix( pos, dest, weight );\n#endif\n\n  return pos;\n}\n\nvec2 toScreen( const vec4 clipSpacePos )\n{\n  return clipSpacePos.xy / clipSpacePos.w;\n}\n\nvoid main() {\n\n  float time = params[0].x;\n  float cpuID = params[0].y;\n  float radialTypeX = params[0].z;\n  float radialTypeY = params[4].w;\n  float duration = params[0].w;\n  float spawnType = params[1].x;\n  float spawnRate = params[1].y;\n  float baseSeed = params[1].z;\n  float vertexCount = params[1].w;\n  float direction = params[2].z; // 0 is forward, 1 is backward  \n  float trailInterval = params[3].x;\n  float particleCount = params[3].y;\n  float trailCount = params[3].z;\n  float maxParticleLifeTime = angularVelocity[1].w; // lifeTime packed into w component of angularVelocity\n  float maxTrailLifeTime = angularAcceleration[1].w; // trailLifeTime packed into angularAcceleration.w\n  float particleLoopTime = particleCount / spawnRate;\n  float motionAge = -1.; // used to determine the age for particle movement\n\n#if defined(USE_PARTICLE_TRAILS) || defined(USE_RIBBON_TRAILS) || defined(USE_RIBBON_3D_TRAILS)\n  float maxAge = maxParticleLifeTime + maxTrailLifeTime;\n#else\n  float maxAge = maxParticleLifeTime;\n#endif\n\n  // the CPU manages IDs if it sets the position or disables particles, otherwise cpuID is -1\n  float particleID0 = cpuID > -EPSILON ? cpuID : floor( mod( time, particleLoopTime ) * spawnRate ); // this will lose precision eventually\n\n  vOverTimeRatio = -1.; // the vOverTimeRatio will be used for the lerps on over-time attributes\n\n  // particles are either emitted in a burst (spawnType == 0) or spread evenly\n  // throughout 0->particleLoopTime (spawnType == 1).  We calculate the ID of the last spawned particle particleID0 \n  // for this frame, any vertex IDs after particleID0 are assumed to belong to the previous loop\n\n  // vertex 0 = trail0 of particle0, vertex 1 = trail1 of particle0, ..., vertex k = trail0 of particle1, ...\n#if defined(USE_RIBBON_TRAILS) || defined(USE_RIBBON_3D_TRAILS)\n  float rawParticleID = floor( vertexID / VERTS_PER_RIBBON / trailCount );\n#else\n  float rawParticleID = floor( vertexID / trailCount );\n#endif\n\n  float particleLoop = floor( time / particleLoopTime );\n\n#if defined(USE_PARTICLE_SOURCE)\n  // find particleID relative to the last loop\n  float particleID = rawParticleID - floor( particleID0 / particleCount ) * particleCount;\n#else // defined(USE_PARTICLE_SOURCE)\n\n#if PARTICLE_ORDER == 0\n  float particleID = particleID0 - (particleCount - 1. - rawParticleID); // newest last\n#elif PARTICLE_ORDER == 1\n  float particleID = particleID0 - rawParticleID; // oldest last\n#else\n  float particleID = rawParticleID > particleID0 ? rawParticleID - particleCount : rawParticleID; // cyclic (any)\n#endif\n\n#endif // defined(USE_PARTICLE_SOURCE)\n\n  // for burst mode we use the rawParticleID, because the concept of particleID0 is irrelevant\n  particleID = mix( rawParticleID, particleID, spawnType ); \n\n  float particleStartTime = particleLoop * particleLoopTime + particleID / spawnRate * spawnType;\n\n  // we use the id as a seed for the randomizer, but because the IDs are fixed in \n  // the range 0->particleCount we calculate a virtual ID by taking into account\n  // the number of loops that have occurred (note, particles from the previous \n  // loop will have a negative particleID). We use the modoulo of the RANDOM_REPEAT_COUNT \n  // to ensure that the virtualID doesn't exceed the floating point precision\n\n  float virtualID = mod( particleID + particleLoop * particleCount, float( RANDOM_REPEAT_COUNT ) );\n  float seed = pseudoRandom( virtualID*baseSeed*110. );\n\n  float particleLifeTime = randFloatRange( angularVelocity[0].w, angularVelocity[1].w, seed );\n\n  float particleAge = time - particleStartTime;\n  particleAge = particleAge + direction * ( particleLoopTime - 2. * particleAge );\n\n  // don't show particles that would be emitted after the duration\n  if ( duration > 0. && time - particleAge >= duration ) \n  {\n    particleAge = -1.;\n  } \n\n  // always calculate the trailLifeTime, even if we don't use it, so the particles\n  // with the same seed give consistent results\n  float trailLifeTime = randFloatRange( angularAcceleration[0].w, angularAcceleration[1].w, seed );\n\n#if defined(USE_PARTICLE_TRAILS)\n\n  // +1 beceause we show both the lead particle and the first trail at the start\n  // we cap the particleAge to ensure it never goes past the particleLifeTime\n  float cappedParticleAge = min( particleLifeTime - trailInterval, particleAge );\n  float trailID0 = floor( cappedParticleAge / trailInterval ) + 1.;\n  float rawTrailID = mod( vertexID, trailCount );\n\n#if PARTICLE_TRAIL_ORDER == 0\n  float trailID = trailID0 - ( trailCount - 1. - rawTrailID ); // newest last\n#elif PARTICLE_TRAIL_ORDER == 1\n  float trailID = trailID0 - rawTrailID; // oldest last\n#else\n  float trailID = floor( trailID0 / trailCount ) * trailCount;\n  trailID += rawTrailID > mod( trailID0, trailCount ) ? rawTrailID - trailCount : rawTrailID; // cyclic (any order)\n#endif\n\n  float trailStartAge = trailID * trailInterval;\n  \n  if (particleAge > -EPSILON && trailStartAge > -EPSILON && trailStartAge < particleLifeTime + EPSILON)\n  {\n    if (particleAge < trailStartAge)\n    {\n      motionAge = particleAge;\n      vOverTimeRatio = 0.;\n    }\n    else if (particleAge < trailStartAge + trailLifeTime)\n    {\n      motionAge = trailStartAge;\n      vOverTimeRatio = (particleAge - trailStartAge)/trailLifeTime;\n    }\n  }\n\n#elif defined(USE_RIBBON_TRAILS) || defined(USE_RIBBON_3D_TRAILS)\n\n  // +1 to the trailID0 because the ribbon needs two elements to start\n  // we cap the particleAge to ensure it never goes past the particleLifeTime\n  float cappedParticleAge = min( particleLifeTime - trailInterval, particleAge );\n  float trailID0 = floor( cappedParticleAge / trailInterval ) + 1.;\n  float rawTrailID = floor( mod( vertexID / VERTS_PER_RIBBON, trailCount ) );\n  float trailID = max( 0., trailID0 - ( trailCount - 1. - rawTrailID ) ); // newest last\n\n  float trailStartAge = trailID * trailInterval;\n\n  if (particleAge > -EPSILON && trailStartAge > -EPSILON && trailStartAge < particleLifeTime + EPSILON)\n  {\n    // motionAge will typically be the trailStartAge, but the lead particle will be the \n    // cappedParticleAge, and the last particle will be the particleAge - trailLifeTime\n\n    motionAge = min( cappedParticleAge, max( particleAge - trailLifeTime, trailStartAge ) );\n    vOverTimeRatio = ( particleAge - motionAge ) / trailLifeTime;\n  }\n  else\n  {\n    motionAge = particleLifeTime;\n    vOverTimeRatio = 1.0;\n  }\n\n#else // defined(USE_PARTICLE_TRAILS) || defined(USE_RIBBON_TRAILS) || defined(USE_RIBBON_3D_TRAILS)\n\n  motionAge = particleAge;\n  vOverTimeRatio = particleAge/particleLifeTime;\n\n#endif // defined(USE_PARTICLE_TRAILS) || defined(USE_RIBBON_TRAILS) || defined(USE_RIBBON_3D_TRAILS)\n\n  // these checks were around large blocks of code above, but this caused instability\n  // in some of the particle systems, so instead we do all of the work, then cancel \n  // it out here\n  if ( particleStartTime < 0. || vertexID < 0. )\n  {\n    vOverTimeRatio = -1.;\n  }\n\n#if defined(USE_PARTICLE_DRAG)\n  // simulate drag by blending the motionAge to (1-.5*drag)*particleLifeTime\n  float drag = params[2].w;\n  motionAge = mix( .5*drag*vOverTimeRatio, 1. - .5*drag, vOverTimeRatio ) * particleLifeTime;\n#endif\n\n  vec3 p = vec3(0.); // position\n  vec3 v = vec3(0.); // velocity\n  vec3 a = vec3(0.); // acceleration\n  vec3 av = vec3(0.); // angular velocity\n  vec3 aa = vec3(0.); // angular acceleration\n  vec3 axis = vec3( 1., 0., 0. ); // axis of orbital motion\n  float ov = 0.; // orbital velocity\n  float oa = 0.; // orbital acceleration\n  vec3 dest = vec3(0.); // destination position\n  float destWeight = 0.; // destination weighting\n\n#if defined(USE_PARTICLE_OFFSET)\n  p = randVec3Range( offset[0].xyz, offset[1].xyz, seed );\n#endif\n\n#if defined(USE_PARTICLE_VELOCITY)\n  v = randVec3Range( velocity[0].xyz, velocity[1].xyz, seed );\n#endif\n\n#if defined(USE_PARTICLE_ACCELERATION)\n  a = randVec3Range( acceleration[0].xyz, acceleration[1].xyz, seed );\n#endif\n\n#if defined(USE_PARTICLE_RADIAL_OFFSET) || defined(USE_PARTICLE_RADIAL_VELOCITY) || defined(USE_PARTICLE_RADIAL_ACCELERATION)\n  vec2 ANGLE_RANGE[2];\n  vec2 radialDir = vec2( radialTypeX, radialTypeY );\n  ANGLE_RANGE[0] = vec2( 0., 0. ) * radialDir;\n  ANGLE_RANGE[1] = vec2( 2.*PI, 2.*PI ) * radialDir;\n\n  vec2 theta = randVec2Range( ANGLE_RANGE[0], ANGLE_RANGE[1], seed );\n#endif\n\n#if defined(USE_PARTICLE_RADIAL_OFFSET)\n  float pr = randFloatRange( offset[0].w, offset[1].w, seed );\n  vec3 p2 = radialToVec3( pr, theta );\n  p += p2;\n#endif\n\n#if defined(USE_PARTICLE_RADIAL_VELOCITY)\n  float vr = randFloatRange( velocity[0].w, velocity[1].w, seed );\n  vec3 v2 = radialToVec3( vr, theta );\n  v += v2;\n#endif\n\n#if defined(USE_PARTICLE_RADIAL_ACCELERATION)\n  float ar = randFloatRange( acceleration[0].w, acceleration[1].w, seed );\n  vec3 a2 = radialToVec3( ar, theta );\n  a += a2;\n#endif\n\n#if defined(USE_PARTICLE_ANGULAR_VELOCITY)\n  av = randVec3Range( angularVelocity[0].xyz, angularVelocity[1].xyz, seed );\n#endif\n\n#if defined(USE_PARTICLE_ANGULAR_ACCELERATION)\n  aa = randVec3Range( angularAcceleration[0].xyz, angularAcceleration[1].xyz, seed );\n#endif\n\n#if defined(USE_PARTICLE_ORBITAL)\n  if ( length(p) > EPSILON ) {\n    ov = randFloatRange( orbital[0].x, orbital[1].x, seed );\n    float oa = randFloatRange( orbital[0].y, orbital[1].y, seed );\n    float angle = displacement1D(ov, oa, motionAge);\n\n    vec3 randomOribit = vec3( random( seed ), random( seed ), random( seed ) ); // should never equal p or 0,0,0\n    axis = normalize( cross( normalize( p ), normalize( randomOribit ) ) );\n  }\n#endif\n\n#if defined(USE_PARTICLE_DESTINATION)\n  destWeight = randFloatRange( destination[0].w, destination[1].w, seed );\n  dest = randVec3Range( destination[0].xyz, destination[1].xyz, seed );\n#endif\n\n  vec3 transformed = particleMotion( p, v, a, av, aa, axis, ov, oa, dest, motionAge/particleLifeTime*destWeight, motionAge );\n\n  vec2 rotScale = calcRotationScaleOverTime( vOverTimeRatio, seed );\n  float particleScale = rotScale.y;\n  float c = cos( rotScale.x );\n  float s = sin( rotScale.x );\n\n  vParticleColor = calcColorOverTime( vOverTimeRatio, seed ); // rgba format\n\n#if defined(USE_PARTICLE_VELOCITY_SCALE)\n  // We repeat all of the displacement calculations at motionAge + a small amount (velocityScaleDelta).\n  // We convert the current position and the future position in screen space and determine\n  // the screen space velocity. VelocityScaleDelta is reasonably small to give better\n  // results for the angular and orbital displacement, and when drag is applied the effective\n  // velocity will tend to 0 as the vOverTimeRatio increases\n\n  float velocityScaleDelta = .02;\n\n#if defined(USE_PARTICLE_DRAG)\n  float futureT = motionAge + velocityScaleDelta*mix(1., 1. - drag, vOverTimeRatio);\n#else\n  float futureT = motionAge + velocityScaleDelta;\n#endif\n\n  vec4 pos2D = projectionMatrix * modelViewMatrix * vec4( transformed, 1. );\n\n  // use min(1) to ensure the particle stops at the destination position\n  vec3 transformedFuture = particleMotion( p, v, a, av, aa, axis, ov, oa, dest, min( 1., futureT/particleLifeTime )*destWeight, futureT );\n\n  vec4 pos2DFuture = projectionMatrix * modelViewMatrix * vec4( transformedFuture, 1. );\n\n  vec2 screen = pos2DFuture.xy / pos2DFuture.z - pos2D.xy / pos2D.z; // TODO divide by 0?\n  screen /= velocityScaleDelta; // gives screen units per second\n\n  float lenScreen = length( screen );\n  vec2 sinCos = vec2(screen.x, screen.y)/max( EPSILON, lenScreen); // 0 degrees is y == 1, x == 0\n  float c2 = c*sinCos.y + s*sinCos.x; // cos(a-b)\n  float s2 = s*sinCos.y - c*sinCos.x; // sin(a-b)\n\n  // replace rotation with our new rotation\n  c = c2;\n  s = s2;\n\n  // rescale the particle length by the z depth, because perspective will be applied later\n  float screenScale = clamp( lenScreen * pos2D.z * velocityScale.x, velocityScale.y, velocityScale.z );\n\n  particleScale *= screenScale;\n\n#endif // defined(USE_PARTICLE_VELOCITY_SCALE)\n\n  // #include <color_vertex>\n  // #include <begin_vertex> replaced by code above\n  // #include <morphtarget_vertex>\n  // #include <project_vertex> replaced below\n\n#if defined(USE_RIBBON_3D_TRAILS)\n  float ribbonID = mod( vertexID, VERTS_PER_RIBBON );\n  \n  {\n    float nextT = motionAge + trailInterval;\n    float ribbonWidth = params[4].x * ribbonShape( vOverTimeRatio );\n\n    vec3 nextPosition = particleMotion( p, v, a, av, aa, axis, ov, oa, dest, min( 1., nextT/particleLifeTime )*destWeight, nextT );\n    vec3 dir = nextPosition - transformed;\n    float dirLen = length( dir );\n\n    vec3 normal = dir;\n    vec3 up = vec3( 0., c, -s ); // rotation in YZ\n    if ( dirLen > EPSILON && abs( dot( dir, up ) ) < dirLen * 0.99 ) {\n      normal = normalize( cross( up, dir ) );\n    }\n\n    transformed += ribbonWidth * normal * ( 0.5 - ribbonID );  // +normal for ribbonID 0, -normal for ribbonID 1\n  }\n#endif\n\n  vec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );\n  gl_Position = projectionMatrix * mvPosition;\n\n  float usePerspective = params[2].y;\n\n#if defined(USE_RIBBON_TRAILS)\n  float ribbonID = mod( vertexID, VERTS_PER_RIBBON );\n  \n  {\n    mat4 m = projectionMatrix * modelViewMatrix;\n    vec2 curr = toScreen( gl_Position );\n\n    float nextT = motionAge + trailInterval;\n    vec3 nextPosition = particleMotion( p, v, a, av, aa, axis, ov, oa, dest, min( 1., nextT/particleLifeTime )*destWeight, nextT );\n    vec2 next2D = toScreen( m * vec4( nextPosition, 1. ) ) - curr;\n\n    vec2 dir = normalize( next2D );\n    vec2 normal = vec2( -dir.y, dir.x );\n\n    float ribbonWidth = params[4].x * ribbonShape( vOverTimeRatio );\n    float halfWidth = .5 * ribbonWidth * mix( 1., 1. / - mvPosition.z, usePerspective );\n  \n    gl_Position.xy += halfWidth * normal * ( 1. - ribbonID * 2. ); // +normal for ribbonID 0, -normal for ribbonID 1\n  }\n#endif\n\n#if defined(USE_PARTICLE_SCREEN_DEPTH_OFFSET)\n  float screenDepthOffset = params[3].w;\n\n#if defined(USE_PARTICLE_TRAILS) || defined(USE_RIBBON_TRAILS) || defined(USE_RIBBON_3D_TRAILS)\n  // multiply trailCount by 2 because trailID ranges from [-trailCount, trailCount]\n  gl_Position.z -= (particleID*trailCount*2. + trailID - trailID0)*gl_Position.w*screenDepthOffset/vertexCount;\n#else\n  gl_Position.z -= particleID*gl_Position.w*screenDepthOffset/vertexCount;\n#endif\n\n#endif // defined(USE_PARTICLE_SCREEN_DEPTH_OFFSET)\n\n#if defined(USE_PARTICLE_RANDOMIZE_FRAMES)\n  float frame = floor ( random( seed ) * textureFrames.z );\n#else\n  float textureCount = textureFrames.z;\n  float textureLoop = textureFrames.w;\n\n  float frame = floor( mod( vOverTimeRatio * textureCount * textureLoop, textureCount ) );\n#endif\n\n#if !defined(USE_RIBBON_TRAILS) && !defined(USE_RIBBON_3D_TRAILS)\n  float particleSize = params[2].x;\n\n  gl_PointSize = particleSize * particleScale * mix( 1., 1. / - mvPosition.z, usePerspective );\n#endif\n\n  // #include <logdepthbuf_vertex>\n  // #include <clipping_planes_vertex>\n  // #include <worldpos_vertex>\n  #include <fog_vertex>\n\n#if defined(USE_RIBBON_TRAILS) || defined(USE_RIBBON_3D_TRAILS)\n  float ribbonUVMultiplier = params[4].y;\n  float ribbonUVType = params[4].z;\n\n  vUv = vec2( mix( 1. - vOverTimeRatio, motionAge/trailInterval, ribbonUVType ) * ribbonUVMultiplier, 1. - ribbonID );\n#endif\n\nvUvTransform = mat3(1.);\n\n#if defined(USE_PARTICLE_ROTATION) || defined(USE_PARTICLE_FRAMES) || defined(USE_PARTICLE_VELOCITY_SCALE)\n  {\n    vec2 invTextureFrame = 1. / textureFrames.xy;\n    float textureCount = textureFrames.z;\n    float textureLoop = textureFrames.w;\n\n    float tx = mod( frame, textureFrames.x ) * invTextureFrame.x;\n    float ty = (textureFrames.y - 1. - floor( frame * invTextureFrame.x )) * invTextureFrame.y; // assumes textures are flipped on y\n    float sx = invTextureFrame.x;\n    float sy = invTextureFrame.y;\n    float cx = tx + invTextureFrame.x * .5;\n    float cy = ty + invTextureFrame.y * .5;\n  \n    vUvTransform[0][0] = sx * c;\n    vUvTransform[0][1] = -sx * s;\n    vUvTransform[1][0] = sy * s;\n    vUvTransform[1][1] = sy * c;\n    vUvTransform[2][0] = c * tx + s * ty - ( c * cx + s * cy ) + cx;\n    vUvTransform[2][1] = -s * tx + c * ty - ( -s * cx + c * cy ) + cy;\n  }\n#endif // defined(USE_PARTICLE_ROTATION) || defined(USE_PARTICLE_FRAMES) || defined(USE_PARTICLE_VELOCITY_SCALE)\n\n}",ci="\n#include <common>\n#include <packing>\n// #include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n// #include <logdepthbuf_pars_fragment>\n// #include <clipping_planes_pars_fragment>\n\nuniform vec4 textureFrames;\nuniform vec3 emitterColor;\n\nvarying mat3 vUvTransform;\nvarying vec4 vParticleColor;\nvarying vec2 vUv;\nvarying float vOverTimeRatio;\n\nvoid main() {\n  if ( vOverTimeRatio < 0. || vOverTimeRatio > 1. ) {\n    discard;\n  }\n\n  #include <clipping_planes_fragment>\n\n  vec3 outgoingLight = vec3( 0. );\n  vec4 diffuseColor = vec4( emitterColor, 1. );\n\n  // #include <logdepthbuf_fragment>\n  // #include <map_particle_fragment>\n  // #include <color_fragment>\n\n#ifdef USE_MAP\n\n#if defined(USE_RIBBON_TRAILS) || defined(USE_RIBBON_3D_TRAILS)\n  vec2 uv = ( vUvTransform * vec3( vUv, 1. ) ).xy;\n#else\n  vec2 uv = ( vUvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1. ) ).xy;\n#endif\n\n  vec4 mapTexel = texture2D( map, uv );\n  diffuseColor *= mapTexelToLinear( mapTexel );\n#endif // USE_MAP\n\n  #include <alphatest_fragment>\n\n  diffuseColor *= vParticleColor;\n  outgoingLight = diffuseColor.rgb;\n\n  gl_FragColor = diffuseColor;\n\n  // #include <premultiplied_alpha_fragment>\n  // #include <tonemapping_fragment>\n  // #include <encodings_fragment>\n  #include <fog_fragment>\n}";AFRAME.registerComponent("store",{schema:{type:{default:"temporary",oneOf:["temporary","local","session"],parse:function(e){return"string"==typeof e?e.toLowerCase():e}}},multiple:!0,updateSchema(e){"object"!=typeof e&&console.error(`invalid properties, expected format <property>:<value>; '${e}'`);const t=AFRAME.components[this.name].schema;let n={};for(let i in e)i in t||(n[i]={type:"string"});Object.keys(n).length>0&&this.extendSchema(n)},init(){this.binds=[],this.firstTime=!0,this.loadStorage(),this.el.emit("store-loaded",{store:this,name:this.attrName})},update(e){const t=this.data;for(let n of this.binds){const i=n.key;t[i]!==e[i]&&K(n.target,n.prop,t[i])}this.firstTime||this.saveStorage(),this.firstTime=!1},loadStorage(){const e=AFRAME.components[this.name].schema,t=this.data;if("temporary"!==t.type)for(let n in this.data)if(!(n in e)){let e=null;"local"===t.type?e=localStorage.getItem(n):"session"===t.type&&(e=sessionStorage.getItem(n)),null!==e&&(t[n]=e)}},saveStorage(){const e=AFRAME.components[this.name].schema,t=this.data;if("temporary"!==t.type)for(let n in this.data)n in e||("local"===t.type?localStorage.setItem(n,t[n]):"session"===t.type&&sessionStorage.setItem(n,t[n]))},bind(e,t,n){this.binds.find(e=>e.target===t&&e.prop===n)&&se(`bind '${t}.${n}' already exists`),this.binds.push({key:e,target:t,prop:n})},unbind(e,t,n){const i=this.binds.findIndex(i=>i.target===t&&i.prop===n&&i.key===e);i>=0?this.binds.splice(i,1):se(`unable to find bind '${t}.${n}' for store key '${e}'`)}}),AFRAME.registerComponent("store-bind",{schema:{store:{type:"selector"},from:{default:""},to:{default:""}},multiple:!0,init(){this.onStoreLoaded=this.onStoreLoaded.bind(this)},remove(){const e=this.data;this.removeListeners(e.store),this.unbind(e.store,e.from,e.to)},update(e){const t=this.data;this.unbind(e.store,e.from,e.to),this.bind(t.store,t.from,t.to),e.store!==t.store&&(this.removeListeners(e.store),this.addListeners(t.store))},addListeners(e){e&&e.addEventListener("store-loaded",this.onStoreLoaded)},removeListeners(e){e&&e.removeEventListener("store-loaded",this.onStoreLoaded)},onStoreLoaded(e){const t=this.data;this.bind(t.store,t.from,t.to)},bind(e,t,n){if(e&&t&&n){const[i,a]=t.split("."),s=e.components[i];s&&"bind"in s&&s.bind(a,this.el,n)}},unbind(e,t,n){if(e&&t&&n){const[i,a]=t.split("."),s=e.components[i];s&&"unbind"in s&&s.unbind(a,this.el,n)}}});function di(e,t){for(let n=0;n<t.length;n++)e.includes(t[n])||e.push(t[n]);return e}AFRAME.registerComponent("svg-ui",{schema:{template:{default:""},clickSelectors:{default:""},hoverSelectors:{default:""},touchSelectors:{default:""},touchDistance:{default:.07},resolution:{type:"vec2",default:{x:512,y:512}},touchDeadZone:{default:.5},bubbles:{default:!1},debug:{default:!1},enabled:{default:!0},useHoverClass:{default:!1},interactIfOccluded:{default:!1}},updateSchema(e){"object"!=typeof e&&re(this,`invalid properties, expected format <property>:<value>; '${e}'`);const t=AFRAME.components[this.name].schema;let n={};for(let i in e)i in t||(n[i]={type:"string"});Object.keys(n).length>0&&this.extendSchema(n)},init(){this.hasUIListeners=!1,this.raycasters=[],this.hoverEls=[],this.touchEls=new Map,this.hasPendingUpdateSVGTexture=!1,this.onObject3DSet=this.onObject3DSet.bind(this),this.onRaycasterIntersected=this.onRaycasterIntersected.bind(this),this.onRaycasterIntersectedCleared=this.onRaycasterIntersectedCleared.bind(this),this.onClick=this.onClick.bind(this),this.el.addEventListener("object3dset",this.onObject3DSet),this.createSVGTexture()},remove(){this.el.removeEventListener("object3dset",this.onObject3DSet),this.proxyEl&&this.proxyEl.parent&&this.proxyEl.parent.removeChild(this.proxyEl)},play(){this.addUIListeners()},pause(){this.removeUIListeners()},update(e){const t=this.data;e.template!==t.template?ie(t.template,"<svg",e=>{this.templateContent=e,(e=>"string"==typeof e&&/\<svg/.test(e))(e)||se(this,`template '${t.template}' doesn't look like SVG: ${e}`),this.createSVGFunction(e),this.requestUpdateSVGTexture()}):this.templateContent&&(Object.keys(e)!==Object.keys(t)&&this.createSVGFunction(this.templateContent),this.requestUpdateSVGTexture()),this.addUIListeners()},tick(){this.hasPendingUpdateSVGTexture&&this.updateSVGTexture(),this.data.enabled&&this.raycasters&&this.proxySVGEl&&this.updateHoverAndTouch()},setTemplate(e){this.templateContent=e,this.requestUpdateSVGTexture()},isSelectable(){const e=this.data;return e.clickSelectors||e.hoverSelectors||e.touchSelectors},addUIListeners(){!this.hasUIListeners&&this.isSelectable()&&(this.el.addEventListener("raycaster-intersected",this.onRaycasterIntersected),this.el.addEventListener("raycaster-intersected-cleared",this.onRaycasterIntersectedCleared),this.el.addEventListener("click",this.onClick),this.hasUIListeners=!1)},removeUIListeners(){this.hasUIListeners&&(this.el.removeEventListener("raycaster-intersected",this.onRaycasterIntersected),this.el.removeEventListener("raycaster-intersected-cleared",this.onRaycasterIntersectedCleared),this.el.removeEventListener("click",this.onClick),this.hasUIListeners=!1)},createSVGTexture(){const e=this.data;this.imageEl=document.createElement("img"),this.imageEl.width=e.resolution.x,this.imageEl.height=e.resolution.y,this.imageEl.isReady=!0;const t=this.texture=new THREE.Texture(this.imageEl);this.imageEl.onload=(()=>{t.needsUpdate=!0}),this.imageEl.onerror=(()=>{re(this,"invalid svg",this.lastContent),t.image.isReady=!0}),t.onUpdate=(()=>{t.image.isReady=!0}),this.requestUpdateSVGTexture(),this.showSVGTextureOnMesh()},requestUpdateSVGTexture(){this.hasPendingUpdateSVGTexture=!0},updateSVGTexture(){if(this.templateContent){let e=this.processTemplate(this.templateContent);if(this.data.debug&&console.log(e),this.isSelectable()&&(this.proxyEl||(this.proxyEl=document.createElement("div"),this.proxyEl.style.position="absolute",this.proxyEl.style.top="0",this.proxyEl.style.left="0",this.proxyEl.style.zIndex="-999",this.el.appendChild(this.proxyEl)),this.proxyEl.innerHTML=e,this.proxySVGEl=this.proxyEl.children[0],this.proxySVGEl.setAttribute("width",256),this.proxySVGEl.setAttribute("height",256),this.data.useHoverClass)){for(let e of this.hoverEls)if(e.id){const t=this.proxyEl.querySelector("#"+e.id);t&&t.classList.add("hover")}else se(this,`an element (${Z(e)}) matching the hoverSelectors (${this.data.hoverSelectors}), does not have an id`);e=this.proxyEl.innerHTML}this.pendingContent=e,this.updatePendingContent()}this.hasPendingUpdateSVGTexture=!1},updatePendingContent(){this.imageEl.isReady&&this.pendingContent&&(this.imageEl.src="data:image/svg+xml;utf8,"+this.pendingContent,this.imageEl.isReady=!1,this.lastContent=this.pendingContent,this.pendingContent=void 0)},showSVGTextureOnMesh(){const e=this.el.getObject3D("mesh");if(e&&!Array.isArray(e.material)){e.material.map=this.texture;const t=e.material.color;t&&(t.r<.95||t.g<.95||t.b<.95)&&se(this,"svg-ui material color is not white, it may be difficult to see the ui")}},createSVGFunction(e){const t=Object.keys(this.data).concat("return `"+e+"`");this.svgTextFunction=new Function(...t)},processTemplate(e){if(this.svgTextFunction){return this.svgTextFunction(...Object.values(this.data)).replace(/%/g,"%25").replace(/#/g,"%23")}},calcViewXYFomUV:function(){let e=new THREE.Vector2;return function(t){e.copy(t),this.texture.transformUv(e);const n=this.proxySVGEl.viewBox.animVal;return{x:n.width*e.x+n.x,y:n.height*e.y+n.y}}}(),calcElementsFromUV:function(){let e=new THREE.Vector2;return function(t,n,i){e.copy(t),this.texture.transformUv(e);const a=256*e.x,s=256*e.y;let r=document.elementsFromPoint(a,s).filter(e=>(function(e,t){let n=e;for(;n&&t!==n;)n=n.parentNode;return!!n})(e,this.proxySVGEl));return i&&console.log("hitElements",a,s,r),n&&(r=r.map(e=>(function(e,t){let n=e;for(;n&&"matches"in n&&!n.matches(t);)n=n.parentNode;return n&&"matches"in n?n:void 0})(e,n)).filter(e=>e),i&&console.log("selectedElements",r)),r}}(),updateHoverAndTouch(){let e=[];const t=this.data.interactIfOccluded,n=this.el;function i(e){const i=e.components.raycaster.intersections;return t?i.find(e=>e.object.el===n):i.length>0?i[0].object.el===e?i[1]:i[0]:void 0}for(let t of this.raycasters){const n=i(t);if(n.object.el===this.el){let i=[],a=!1;const s=this.touchEls.get(t);n&&(n.svg=this.calcViewXYFomUV(n.uv),s.lastMove&&(a=Math.hypot(s.lastMove.x-n.svg.x,s.lastMove.y-n.svg.y)>this.data.touchDeadZone),di(e,this.calcElementsFromUV(n.uv,this.data.hoverSelectors,!1)),n.distance<this.data.touchDistance&&(i=this.calcElementsFromUV(n.uv,this.data.touchSelectors,this.data.debug)));const r=i.map(e=>e.id);for(let e of s.elements)i.find(t=>t.id===e.id)||this.sendEvent("svg-ui-touchend",{uiTarget:e,intersection:n,touches:r},t);for(let e of i)s.elements.find(t=>t.id===e.id)?a&&this.sendEvent("svg-ui-touchmove",{uiTarget:e,intersection:n,touches:r},t):this.sendEvent("svg-ui-touchstart",{uiTarget:e,intersection:n,touches:r},t);!a&&s.lastMove||(s.lastMove=n.svg),s.elements=i}}const a=e.map(e=>e.id);let s=!1;for(let t of this.hoverEls)e.find(e=>e.id===t.id)||(this.sendEvent("svg-ui-hoverend",{uiTarget:t,hovers:a}),s=!0);for(let t of e)this.hoverEls.find(e=>e.id===t.id)||(this.sendEvent("svg-ui-hoverstart",{uiTarget:t,hovers:a}),s=!0);this.data.useHoverClass&&s&&this.requestUpdateSVGTexture(),this.hoverEls=e},sendEvent(e,t,n){this.data.debug&&console.log("emit",e,t,n),this.el.emit(e,t,this.data.bubbles),n&&n.emit(e,t,this.data.bubbles)},onObject3DSet(e){this.showSVGTextureOnMesh()},onRaycasterIntersected(e){this.data.debug&&console.log("onRaycasterIntersected",this.el.id);const t=e.detail.el;this.touchEls.set(t,{elements:[]}),this.raycasters.push(t)},onRaycasterIntersectedCleared(e){this.data.debug&&console.log("onRaycasterIntersectedCleared",this.el.id);const t=e.detail.el;this.raycasters.splice(this.raycasters.indexOf(t),1),this.touchEls.delete(t)},onClick(e){const t=this.data;if(t.debug&&console.log("click",this.el.id),e.detail.intersection&&t.enabled){let n=this.calcElementsFromUV(e.detail.intersection.uv,t.clickSelectors,t.debug);const i={...e.detail.intersection,svg:this.calcViewXYFomUV(e.detail.intersection.uv)};n&&n.length>0&&this.sendEvent("svg-ui-click",{uiTarget:n[0],intersection:i})}}}),AFRAME.registerComponent("texture-updater",{schema:{maps:{default:"map"},meshName:{default:"mesh"}},update(){this.maps=this.data.maps.split(",").map(e=>e.trim())},tick(){const e=this.el.getObject3D(this.data.meshName);if(e&&e.material)for(let t of this.maps)if(Array.isArray(e.material))for(let n of e.material)n[t]&&"object"==typeof n[t]&&(n[t].needsUpdate=!0);else e.material[t]&&"object"==typeof e.material[t]&&(e.material[t].needsUpdate=!0)}}),AFRAME.registerComponent("timer-emit",{schema:{src:{type:"selector"},target:{default:""},targetScope:{default:"document",oneOf:["document","self","parent"]},stopOnPause:{default:!0}},multiple:!0,init(){this.sendEvents=this.sendEvents.bind(this),this.mediaEl=void 0,this.restartMedia=!1,this.clockStartTime=Date.now(),this.targets=[]},remove(){this.removeListeners()},updateSchema(e){"object"!=typeof e&&console.error(`invalid properties, expected format <property>:<value>; '${e}'`);const t=AFRAME.components["timer-emit"].schema;let n={};for(let i in e)i in t||(n[i]={type:"string"});Object.keys(n).length>0&&this.extendSchema(n)},pause(){const e=this.data;this.removeListeners(),e.stopOnPause&&(this.pauseTime=Date.now(),clearTimeout(this.sendEventsTimer),this.sendEventsTimer=void 0,this.mediaEl&&!this.mediaEl.paused&&(this.mediaEl.pause(),this.restartMedia=!0))},play(){this.pauseTime&&(this.clockStartTime+=Date.now()-this.pauseTime,delete this.pauseTime),this.mediaEl&&(this.addListeners(),this.restartMedia&&(this.mediaEl.play(),this.restartMedia=!1)),this.sendEvents()},update(e){const t=this.data,n=AFRAME.components["timer-emit"].schema;e.src!==t.src&&(this.removeListeners(),this.mediaEl=t.src instanceof HTMLMediaElement?t.src:void 0),e.target!==t.target&&(this.targets=this.querySelectorAll(t.targetScope,t.target)),this.events=[];for(let e in t)if(!(e in n)){let n=t[e].split(",").map(e=>Number(e));for(let t of n)isNaN(t)||this.events.push([t,e])}this.events.sort((e,t)=>e[0]-t[0]),this.lastSendEventsTime=-1},querySelectorAll(e,t){if(""==t)return[this.el];switch(e){case"self":return this.el.querySelectorAll(t)||[this.el];case"parent":return this.el.parentNode.querySelectorAll(t)||[this.el];case"document":default:return document.querySelectorAll(t)||[this.el]}},addListeners(){this.mediaEl&&this.mediaEl.addEventListener("play",this.sendEvents)},removeListeners(){this.mediaEl&&this.mediaEl.removeEventListener("play",this.sendEvents)},sendEvents(){if(this.mediaEl&&this.mediaEl.paused)return;let e,t=this.mediaEl?this.mediaEl.currentTime:(Date.now()-this.clockStartTime)/1e3,n=[];for(let i of this.events)if(!(i[0]<=this.lastSendEventsTime)){if(!(i[0]<=t)){e=i[0];break}n.push(i[1])}if(n.length>0){const e=this.el;for(let t of this.targets){const i={source:e,target:t};for(let e of n)t.emit(e,i)}}this.lastSendEventsTime=t,e&&(this.sendEventsTimer=setTimeout(this.sendEvents,1e3*(e-t)))}});THREE.Math.radToDeg;const hi=THREE.Math.degToRad;function ui(e){return e.toLowerCase()}AFRAME.registerComponent("tool",{dependencies:["position","rotation","scale"],schema:{debug:{default:!1},handPosition:{type:"vec3"},handRotation:{type:"vec3"},handScale:{type:"vec3",default:{x:1,y:1,z:1}},maxHands:{default:1},usage:{default:"stayondrop",oneOf:["respawnOnDrop","stayOnDrop"],parse:e=>"string"==typeof e?e.toLowerCase():e}},init(){this.hands=[],this.onGrabStart=this.onGrabStart.bind(this),this.onGrabEnd=this.onGrabEnd.bind(this),this.offsetMatrix=new THREE.Matrix4,this.objectMatrixOnEquip=new THREE.Matrix4,this.originalScale=new THREE.Vector3,this.invRotationMatrix=new THREE.Matrix4,this.el.sceneEl.systems["grab-system"].registerTarget(this.el)},play(){this.el.addEventListener("grabstart",this.onGrabStart),this.el.addEventListener("grabend",this.onGrabEnd)},pause(){this.el.removeEventListener("grabstart",this.onGrabStart),this.el.removeEventListener("grabend",this.onGrabEnd)},update(e){const t=this.data;if(e.handRotation!==t.handRotation||e.handPosition!==t.handPosition||e.handScale!==t.handScale){const e=(new THREE.Euler).set(hi(t.handRotation.x),hi(t.handRotation.y),hi(t.handRotation.z),"YXZ"),n=(new THREE.Quaternion).setFromEuler(e);this.offsetMatrix.compose(t.handPosition,n,t.handScale),this.invRotationMatrix.makeRotationFromQuaternion(n),this.invRotationMatrix.getInverse(this.invRotationMatrix)}},tick:function(){const e=new THREE.Matrix4,t=new THREE.Matrix4,n=new THREE.Vector3(0,0,1),i=new THREE.Vector3,a=new THREE.Vector3,s=new THREE.Vector3,r=new THREE.Quaternion,o=new THREE.Matrix4;return function(){if(0===this.hands.length)return void this.el.sceneEl.removeBehavior(this);const l=this.el.object3D,c=this.hands[0].object3D;if(c.updateMatrixWorld(!0),l.parent.updateMatrixWorld(!0),t.getInverse(l.parent.matrixWorld),this.hands.length>1){const l=this.hands[1].object3D;l.updateMatrixWorld(!0),l.getWorldPosition(a),c.getWorldPosition(s),i.subVectors(s,a).normalize(),n.set(0,0,1),r.setFromUnitVectors(n,i),o.makeRotationFromQuaternion(r),o.multiply(this.invRotationMatrix),o.setPosition(s),e.copy(this.offsetMatrix).premultiply(o).premultiply(t)}else e.copy(this.offsetMatrix).premultiply(c.matrixWorld).premultiply(t);e.decompose(l.position,l.quaternion,l.scale),l.scale.multiply(this.originalScale)}}(),onGrabStart(e){const t=new THREE.Vector3,n=new THREE.Quaternion,i=this.data;this.hands.length=Math.min(i.maxHands-1,this.hands.length),this.hands.push(e.detail.hand),this.objectMatrixOnEquip.copy(this.el.object3D.matrix),this.el.object3D.matrix.decompose(t,n,this.originalScale),this.el.sceneEl.addBehavior(this)},onGrabEnd(e){const t=this.data,n=this.el.object3D,i=this.hands.indexOf(e.detail.hand);-1!==i&&(this.hands.splice(i,1),0===this.hands.length&&"respawnondrop"===t.usage&&this.objectMatrixOnEquip.decompose(n.position,n.quaternion,n.scale))}}),AFRAME.registerComponent("toy",{schema:{routeEvents:{default:"controllerconnected, controllerdisconnected, gripdown, gripup, gripchanged, trackpaddown, trackpadup, triggerdown, triggerup"},debug:{default:!1}},init(){this.invGrabMatrix=new THREE.Matrix4,this.grabHand=void 0,this.routeEvents=[],this.onGrabStart=this.onGrabStart.bind(this),this.onGrabEnd=this.onGrabEnd.bind(this),this.onRouteEvent=this.onRouteEvent.bind(this),this.el.sceneEl.systems["grab-system"].registerTarget(this.el)},play(){this.el.addEventListener("grabstart",this.onGrabStart),this.el.addEventListener("grabend",this.onGrabEnd),this.addRouteListeners()},pause(){this.removeRouteListeners(),this.el.removeEventListener("grabend",this.onGrabEnd),this.el.removeEventListener("grabstart",this.onGrabStart)},update(e){const t=this.data;e.routeEvents!==t.routeEvents&&(this.routeEvents=t.routeEvents.split(",").map(e=>e.trim()))},tick(){this.grabHand?this.stickToHand():this.el.sceneEl.removeBehavior(this)},stickToHand:function(){const e=new THREE.Matrix4,t=new THREE.Matrix4;return function(){const n=this.grabHand.object3D,i=this.el.object3D;e.getInverse(i.parent.matrixWorld),t.multiplyMatrices(n.matrixWorld,this.invGrabMatrix),t.premultiply(e),t.decompose(i.position,i.quaternion,i.scale)}}(),sendEvent(e,t,n){this.data.debug&&ae(this,`send '${t}' to '${Z(e)}'`),e.emit(t,n)},addRouteListeners(){if(this.grabHand)for(let e of this.routeEvents)this.grabHand.addEventListener(e,this.onRouteEvent)},removeRouteListeners(){if(this.grabHand)for(let e of this.routeEvents)this.grabHand.removeEventListener(e,this.onRouteEvent)},onGrabStart(e){this.data.debug&&ae(this,`${e.type}`),this.removeRouteListeners(),this.grabHand=e.detail.hand;const t=this.grabHand.object3D,n=this.el.object3D;this.invGrabMatrix.getInverse(t.matrixWorld).multiply(n.matrixWorld),this.addRouteListeners(),this.el.sceneEl.addBehavior(this)},onGrabEnd(e){this.data.debug&&ae(this,`${e.type}`),this.grabHand===e.detail.hand&&(this.removeRouteListeners(),this.grabHand=void 0)},onRouteEvent(e){this.sendEvent(this.el,e.type,{...e.detail,hand:this.grabHand})}}),AFRAME.registerComponent("trigger-zone",{schema:{triggerSelectors:{default:""},watch:{default:!1},debug:{default:!1},tickMS:{default:100},bubbles:{default:!1},enabled:{default:!0},test:{default:"overlap",oneOf:["overlap","within"]}},multiple:!0,init(){this.firstTime=!0,this.debugShape=void 0,this.overlapping=[],this.triggerElements=[],this.observer=void 0,this.onSceneLoaded=this.onSceneLoaded.bind(this),this.onSceneChanged=this.onSceneChanged.bind(this),this.el.sceneEl.addEventListener("loaded",this.onSceneLoaded)},remove(){this.el.sceneEl.removeEventListener("loaded",this.onSceneLoaded),this.observer&&(this.observer.disconnect(),this.observer=void 0),this.hideDebugShape()},update(e){const t=this.data;this.firstTime||e.triggerSelectors===t.triggerSelectors||this.gatherElements(),this.firstTime||e.watch===t.watch&&e.enabled===t.enabled||this.setupWatch(),e.tickMS!==t.tickMS&&(this.tick=AFRAME.utils.throttleTick(this.tick,t.tickMS,this)),e.debug===t.debug&&e.enabled===t.enabled||this.showDebugShape(),this.firstTime=!1},tick(){this.triggerElements.length>0&&this.data.enabled&&this.checkForEnterLeave()},gatherElements(){const e=this.data;this.triggerElements=e.triggerSelectors?Array.from(document.querySelectorAll(e.triggerSelectors)):[],e.debug&&console.log(`gathering ${this.triggerElements.length} elements`),0===this.triggerElements.length&&se(`no trigger elements using '${e.triggerSelectors}' for trigger-zone`)},checkForEnterLeave(){const e=this.findOverlapping(this.triggerElements,"cyan");for(let t of this.overlapping)e.includes(t)||this.sendTwoEvents("trigger-zone-leave",t);for(let t of e)this.overlapping.includes(t)||this.sendTwoEvents("trigger-zone-enter",t);this.overlapping=e},findOverlapping:function(){const e=new THREE.Vector3,t=new THREE.Vector3,n=new THREE.Vector3,i=new THREE.Vector3(-.5,-.5,-.5),a=new THREE.Vector3(.5,.5,.5);return function(s,r){let o=[];const l=this.el.object3D;l.updateMatrixWorld(!0),l.getWorldPosition(t),l.getWorldScale(n).multiplyScalar(.5);const c=Math.hypot(n.x,n.y,n.z);for(let n of s){if(!n.isEntity||!n.object3D)continue;let s=n.object3D;if(s.boundingSphere&&s.boundingBox&&!s.boundingBox.isEmpty()||Tt(s,r),s.boundingBox.isEmpty())continue;e.copy(s.boundingSphere.center).applyMatrix4(s.matrixWorld);const d=s.boundingSphere.radius*Math.max(s.scale.x,s.scale.y,s.scale.z);if(t.distanceTo(e)>d+c)continue;let h=!1;(h="overlap"===this.data.test?gt(s.boundingBox.min,s.boundingBox.max,s.matrixWorld.elements,i,a,l.matrixWorld.elements):vt(s.boundingBox.min,s.boundingBox.max,s.matrixWorld.elements,i,a,l.matrixWorld.elements))&&o.push(n)}return o}}(),sendTwoEvents(e,t){this.data.debug&&console.log(e,Z(this.el),Z(t));const n=this.data.bubbles;this.el.emit(e,{zoneTarget:t,zoneSource:this.el},n),t.emit(e,{zoneTarget:t,zoneSource:this.el},n)},setupWatch(){this.data.watch&&this.data.enabled?(this.observer=this.observer?this.observer:new MutationObserver(this.onSceneChanged),this.observer.observe(this.el.sceneEl,{childList:!0,subtree:!0})):this.observer&&this.observer.disconnect()},showDebugShape(){this.hideDebugShape();const e=new THREE.BoxBufferGeometry,t=new THREE.WireframeGeometry(e);this.debugShape=new THREE.LineSegments(t,new THREE.LineBasicMaterial({color:this.data.enabled?"blue":"grey"})),this.el.object3D.add(this.debugShape)},hideDebugShape(){this.debugShape&&(this.el.object3D.remove(this.debugShape),this.debugShape=void 0)},onSceneLoaded(e){this.gatherElements(),this.setupWatch()},onSceneChanged(e){!function(e,t,n){for(let i of t){for(let t of i.addedNodes)t.matches(n)&&e.push(t);for(let t of i.removedNodes)t.matches(n)&&e.splice(e.indexOf(t),1)}}(this.triggerElements,e,this.data.triggerSelectors)}});const mi={repeat:THREE.RepeatWrapping,clamptoedge:THREE.ClampToEdgeWrapping,mirroredrepeat:THREE.MirroredRepeatWrapping};AFRAME.registerComponent("uv-transform",{schema:{offset:{type:"vec2"},repeat:{type:"vec2",default:{x:1,y:1}},rotate:{type:"number"},pivot:{type:"vec2",default:{x:.5,y:.5}},meshName:{default:"mesh"},wrapS:{default:"repeat",oneOf:["repeat","clampToEdge","mirroredRepeat"],parse:ui},wrapT:{default:"repeat",oneOf:["repeat","clampToEdge","mirroredRepeat"],parse:ui},maps:{type:"string",default:"map"},textureFrame:{type:"vec2",default:{x:1,y:1}},frame:{default:0}},multiple:!0,init(){this.onObject3DSet=this.onObject3DSet.bind(this),this.onMaterialTextureLoaded=this.onMaterialTextureLoaded.bind(this),this.el.addEventListener("object3dset",this.onObject3DSet),this.el.addEventListener("materialtextureloaded",this.onMaterialTextureLoaded)},remove(){this.el.removeEventListener("materialtextureloaded",this.onMaterialTextureLoaded),this.el.removeEventListener("object3dset",this.onObject3DSet)},update(e){const t=this.data;e.rotate!==t.rotate&&(this.rotate=THREE.Math.degToRad(t.rotate)),e.wrapS===t.wrapS&&e.wrapT===t.wrapT||(this.wrapS=mi[t.wrapS]||THREE.RepeatWrapping,this.wrapT=mi[t.wrapT]||THREE.RepeatWrapping),e.maps!==t.maps&&(this.maps=t.maps.split(",").map(e=>e.trim()),this.cloneMaps()),this.updateUVs()},onObject3DSet(e){e.target===this.el&&e.detail.type===this.data.meshName&&(this.cloneMaps(),this.updateUVs())},onMaterialTextureLoaded(e){e.target===this.el&&(this.cloneMaps(),this.updateUVs())},updateUVs(){const e=this.data,t=e.repeat,n=this.rotate,i=e.pivot,a=this.wrapS,s=this.wrapT,r=e.textureFrame,o=Math.trunc(e.frame),l=o%r.x/r.x,c=1-Math.floor(o/r.x)/r.y,d=e.offset.x+l-i.x+i.x/r.x,h=e.offset.y+c-i.y-(1-i.y)/r.y;const u=this.el.getObject3D(this.data.meshName);if(u&&u.material)for(let e of this.maps)(e=u.material[e])&&(e.wrapS=a,e.wrapT=s,e.offset.set(d,h),e.repeat.copy(t).divide(r),e.center.copy(i),e.rotation=n);var m},cloneMaps(){const e=this.el.getObject3D(this.data.meshName);if(e&&e.material&&this.maps)for(let t of this.maps){const n=e.material[t];n&&(e.material[t]=n.clone(),e.material[t].needsUpdate=!0)}}});function pi(e){let t=function(e){let t={type:"",id:"",classes:[],attrs:{}},n="type",i=0,a="";function s(s,r){let o=e.slice(i,r);if(r>i)switch(n){case"type":t.type=o;break;case"id":t.id=o;break;case"class":t.classes.push(o);break;case"attr":a=o;break;case"value":a&&(t.attrs[a]=o)}n=s,i=r+1}for(let t=0,i=e.length;t<i;t++)switch(e[t]){case"\\":t++;break;case"#":"attr"!==n&&"value"!==n&&s("id",t);break;case".":"attr"!==n&&"value"!==n&&s("class",t);break;case"[":"attr"!==n&&"value"!==n&&s("attr",t);break;case"]":"attr"!==n&&"value"!==n||s("none",t);break;case"=":"attr"===n&&s("value",t)}return s("end",e.length),t}(e),n=t.type||"a-entity",i=document.createElement(n);if(i){t.id&&(i.id=t.id),t.classes.length>0&&i.classList.add(...t.classes);for(let e in t.attrs)AFRAME.utils.entity.setComponentProperty(i,e,fi(t.attrs[e]))}return i}function fi(e){const t="'"===(e=e.trim())[0]||'"'===e[0]?1:0,n=e.length;let i="'"===e[n-1]||'"'===e[n-1]?n-1:n;return 0===t&&i===n?e:e.slice(t,i)}function gi(e,t,n){return e.replace(/\$([\.\w]+)/g,(e,i)=>(function(e,t,n){let i=e;0===e.indexOf("event")?n?i=G(x(n,e.slice(6).split("."))):console.log("value of $event but no event received"):i=G(J(t,e.slice(1)));return i})(i,t,n))}AFRAME.registerComponent("vertex-color",{schema:{color:{type:"color"},verts:{type:"array",parse:function(e){return"string"==typeof e?e.split(",").map(e=>parseInt(e,10)):e}},minPosition:{type:"vec3",default:{x:-1e10,y:-1e10,z:-1e10}},maxPosition:{type:"vec3",default:{x:1e10,y:1e10,z:1e10}},minSlope:{type:"int",default:0},maxSlope:{type:"int",default:90},meshName:{default:"mesh"}},multiple:!0,init(){this.onObject3DSet=this.onObject3DSet.bind(this),this.el.addEventListener("object3dset",this.onObject3DSet),this.isFirstFrame=!0},remove(){this.el.removeEventListener("object3dset",this.onObject3DSet)},update(){if(this.isFirstFrame)this.applyVertexColors(),this.isFirstFrame=!1;else{const e=this.el.components;for(let t in e)0===t.indexOf("vertex-color")&&e[t].applyVertexColors()}},onObject3DSet(e){e.target===this.el&&e.detail.type===this.data.meshName&&this.applyVertexColors()},applyVertexColors(){const e=this.data,t=this.el.getObject3D(e.meshName);if(t){const n=t.geometry,i=t.material,a=t.material.color;if(i.vertexColors=THREE.VertexColors,a.r<.3&&a.g<.3&&a.b<.3&&se("material color is very dark, vertex-color will also be dark"),console.assert(n.isBufferGeometry,"vertex-color only supports buffer geometry"),!n.getAttribute("color")){const e=new Float32Array(3*n.getAttribute("position").count).fill(1);n.setAttribute("color",new THREE.Float32BufferAttribute(e,3))}const s=n.getAttribute("position"),r=n.getAttribute("normal"),o=n.getAttribute("color"),l=e.minPosition.x-.5,c=e.minPosition.y,d=e.minPosition.z-.5,h=e.maxPosition.x-.5,u=e.maxPosition.y,m=e.maxPosition.z-.5,p=new THREE.Color(e.color),f=1e-5,g=THREE.Math.degToRad,v=Math.cos(g(Math.max(0,e.minSlope)))+f,y=Math.cos(g(Math.max(0,e.maxSlope)))-f;for(let t=0,n=o.count;t<n;t++){if(e.verts.length>0&&!e.verts.includes(t))continue;const n=s.getX(t),i=s.getY(t),a=s.getZ(t);if(n<l||n>h||i<c||i>u||a<d||a>m)continue;const f=Math.abs(r.getY(t));f<y||f>v||o.setXYZ(t,p.r,p.g,p.b)}o.needsUpdate=!0}}}),AFRAME.registerComponent("wait-add-remove",{schema:{delay:{default:"0"},events:{default:""},source:{default:""},sourceScope:{default:"document",oneOf:["parent","self","document"]},add:{type:"array"},addRepeat:{type:"int",default:1},remove:{type:"array"}},multiple:!0,init(){this.addRemoveEntities=this.addRemoveEntities.bind(this),this.onEvent=this.onEvent.bind(this),this.delayClock=ee(),this.eventListener=ne(this.el,this.onEvent)},remove(){this.delayClock.clearAllTimers(),this.eventListener.remove()},update(e){const t=this.data;e.events===t.events&&e.source===t.source&&e.sourceScope===t.sourceScope||this.eventListener.set(t.events,t.source,t.sourceScope),e.delay!==t.delay&&(this.delay=R(t.delay),""===t.events&&this.delayClock.startTimer(U(this.delay),this.addRemoveEntities))},pause(){this.delayClock.pause(),this.eventListener.remove()},play(){this.eventListener.add(),this.delayClock.resume()},onEvent(){this.data;this.delayClock.startTimer(U(this.delay),this.addRemoveEntities)},addRemoveEntities(){const e=this.data;for(let t of e.remove){this.el.querySelectorAll(t).forEach(e=>this.el.removeChild(e))}for(let t=0;t<e.addRepeat;++t)for(let t of e.add){let e=pi(t);e&&this.el.appendChild(e)}}}),AFRAME.registerComponent("wait-emit",{schema:{events:{default:""},delay:{default:"0"},source:{default:""},sourceScope:{default:"document",oneOf:["parent","self","document"]},out:{default:""},target:{default:""},targetScope:{default:"document",oneOf:["parent","self","document","event"]},bubbles:{default:!1},debug:{default:!1}},multiple:!0,init(){this.onEvent=this.onEvent.bind(this),this.sendEvent=this.sendEvent.bind(this),this.sources=[],this.delayClock=ee(),this.eventListener=ne(this.el,this.onEvent)},remove(){this.eventListener.remove(),this.delayClock.clearAllTimeouts()},update(e){const t=this.data;t.events===e.events&&t.source===e.source&&t.sourceScope===e.sourceScope||this.eventListener.set(t.events,t.source,t.sourceScope),t.delay!==e.delay&&(this.delay=R(t.delay),""===t.events&&this.delayClock.startTimer(U(t.delay),this.sendEvent))},pause(){this.eventListener.remove(),this.delayClock.pause()},play(){this.eventListener.add(),this.delayClock.resume()},sendEvent(e){const t=this.data,n=te(this.el,t.target,t.targetScope,e?e.target:void 0),i=Object.assign(e,{source:this.el}),a=t.out?t.out:t.event,s=this.data.bubbles;for(let e of n)this.data.debug&&console.log(Z(e),this.attrName,"send",a,i,s),e.emit(a,i,s)},onEvent(e){this.data.debug&&console.log(Z(this.el),this.attrName,"onEvent",e.type);const t=this;this.delayClock.startTimer(U(this.delay),()=>t.sendEvent(e))}}),AFRAME.registerComponent("wait-set",{schema:{delay:{default:"0"},events:{default:""},source:{default:""},sourceScope:{default:"document",oneOf:["parent","self","document"]},target:{default:""},targetScope:{default:"document",oneOf:["parent","self","document","event"]},toggles:{default:""},seed:{type:"int",default:-1},debug:{default:!1}},multiple:!0,init(){this.onEvent=this.onEvent.bind(this),this.setProperties=this.setProperties.bind(this),this.rules={},this.toggles=[],this.eventListener=ne(this.el,this.onEvent),this.delayClock=ee(),this.lcg=p()},remove(){this.eventListener.remove(),this.delayClock.clearAllTimers()},updateSchema(e){"object"!=typeof e&&console.error(`invalid properties, expected format <property>:<value>; '${e}'`);const t=AFRAME.components[this.name].schema;let n={};for(let i in e)i in t||(n[i]={default:""});Object.keys(n).length>0&&this.extendSchema(n)},update(e){const t=AFRAME.components[this.name].schema,n=this.data;n.seed!==e.seed&&this.lcg.setSeed(n.seed);for(let e in this.rules)e in n||delete this.rules[e];for(let i in n)i in t||n[i]===e[i]||(this.rules[i]=R(n[i]));n.events===e.events&&n.source===e.source&&n.sourceScope===e.sourceScope||this.eventListener.set(n.events,n.source,n.sourceScope),n.toggles!==e.toggles&&(this.toggles=n.toggles.split(",").map(e=>e.trim()).filter(e=>e)),n.delay!==e.delay&&(this.delay=R(n.delay),""===n.events&&this.delayClock.startTimer(U(this.delay),this.setProperties))},pause(){this.eventListener.remove(),this.delayClock.pause()},play(){this.delayClock.resume(),this.eventListener.add()},setProperties(e){const t=gi(this.data.target,this.el,e),n=te(this.el,t,this.data.targetScope,e?e.target:void 0);this.data.debug&&console.log(Z(this.el),this.attrName,"setProperties","target=",t);for(let t of n){for(let n in this.rules){const i=G(U(this.rules[n],this.lcg.random)),a=gi(i,this.el,e);this.data.debug&&console.log(Z(this.el),this.attrName,"setProperties","element=",Z(t),"property=",n,"value=",i,"$event=",e),K(t,n,a)}for(let e of this.toggles){const n=!J(t,e);K(t,e,n)}}},onEvent(e){this.data.debug&&console.log(Z(this.el),this.attrName,"onEvent",e.type,e);const t=this;this.delayClock.startTimer(U(this.delay),()=>t.setProperties(e))}})});