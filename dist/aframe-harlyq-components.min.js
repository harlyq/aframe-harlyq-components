!function(e){"function"==typeof define&&define.amd?define(e):e()}(function(){"use strict";const e=new THREE.Vector3(0,1,0);AFRAME.registerComponent("arm-swinger",{schema:{handSelectors:{type:"selectorAll"},startEvent:{default:"gripdown"},endEvent:{default:"gripup"},cameraRig:{type:"selector"},scaling:{default:1},enabled:{default:!0}},init(){this.onStartEvent=this.onStartEvent.bind(this),this.onEndEvent=this.onEndEvent.bind(this),this.tick=AFRAME.utils.throttleTick(this.tick,100,this),this.newOffset=new THREE.Vector3,this.isMoving=!1,this.isEnabled=!1,this.sides=[]},update(e){const t=this.data;if(e.handSelectors!==t.handSelectors&&(this.sides.length=0,t.handSelectors))for(let e of t.handSelectors)this.sides.push({handEl:e,active:!1,positions:[],forwards:[]});e.enabled!==t.enabled&&(t.enabled?this.enable():this.disable())},play(){this.data.enabled&&this.enable()},pause(){this.disable()},tick(e,t){const i=this.data,n=.001*t;let[a,r]=this.sides.length>0?this.tickSide(this.sides[0]):[void 0,void 0],[s,o]=this.sides.length>1?this.tickSide(this.sides[1]):[void 0,void 0];if(this.isMoving=!1,r||o){this.newOffset.set(0,0,0);let e=0;r&&(this.newOffset.add(r),e=Math.max(e,a)),o&&(this.newOffset.add(o),e=Math.max(e,s)),this.newOffset.y=0,this.newOffset.normalize().multiplyScalar(-i.scaling*e*n),this.isMoving=!0}},tock(){const e=this.data,t=e.cameraRig?e.cameraRig.object3D:this.el.object3D;this.isMoving&&t&&t.position.add(this.newOffset)},enable(){if(!this.isEnabled){for(let e of this.sides)this.addListeners(e.handEl);this.isEnabled=!0}},disable(){if(this.isEnabled){for(let e of this.sides)this.deactivate(e),this.removeListeners(e.handEl);this.isEnabled=!1}},onStartEvent(e){for(let t of this.sides)e.target===t.handEl&&this.activate(t)},onEndEvent(e){for(let t of this.sides)e.target===t.handEl&&this.deactivate(t)},addListeners(e){e&&(e.addEventListener(this.data.startEvent,this.onStartEvent),e.addEventListener(this.data.endEvent,this.onEndEvent))},removeListeners(e){e&&(e.removeEventListener(this.data.startEvent,this.onStartEvent),e.removeEventListener(this.data.endEvent,this.onEndEvent))},activate(e){e.active=!0,e.positions.length=0,e.forwards.length=0},deactivate(e){e.active=!1},tickSide(t){if(!t.active)return[void 0,void 0];let i,n;t.positions.length>=3?(i=t.positions.shift(),n=t.forwards.shift()):(i=new THREE.Vector3,n=new THREE.Vector3);const a=t.handEl.object3D.matrixWorld;t.positions.push(i.setFromMatrixPosition(a)),t.forwards.push(n.setFromMatrixColumn(a,0).cross(e));let r=0;const s=t.positions.length;for(let e=1;e<s;e++)r+=t.positions[e].distanceTo(t.positions[e-1]);return[r,n]}});AFRAME.registerSystem("audio-vis",{schema:{src:{type:"selector"},fftSize:{default:32}},init:function(){this.context=void 0,this.analysers={}},getOrCreateAnalyser:function(){this.context||(this.context=new AudioContext);const e=this.data.src,t=(e=>{const t=e.className.split(" ");return e.localName.toLowerCase()+(t[0]?"."+t.join("."):"")+"#"+e.id})(e);if(this.analysers[t])return this.analysers[t];const i=this.data.fftSize;let n=this.context.createAnalyser();return this.context.createMediaElementSource(e).connect(n),n.connect(this.context.destination),n.fftSize=i,n.fetchTime=-1,n.frequencyData=new Uint8Array(i),this.analysers[t]=n,n},getByteFrequencyData:function(e,t){return t!==e.fetchTime&&(e.getByteFrequencyData(e.frequencyData),e.fetchTime=t),e.frequencyData}});const t=e=>Number(e),i=e=>e.trim().split(" ").map(t),n=e=>e.includes(".."),a=e=>e.split("..").map(i),r=(e,t)=>{if(e.length<1)return e[0];let i=[];const n=e[0],a=e[1];for(let e=0,r=Math.max(n.length,a.length);e<r;e++)i[e]=THREE.Math.lerp(n[e]||0,a[e]||0,t);return i},s={bins:{type:"array",default:[0],parse:e=>"string"==typeof e?e.split(",").map(t):e},threshold:{default:0,min:0,max:1}};AFRAME.registerComponent("audio-vis",{schema:s,multiple:!0,init:function(){this.ranges={},this.analyser=this.system.getOrCreateAnalyser()},updateSchema:function(e){"object"!=typeof e&&console.error(`invalid properties, expected format <property>:<value>; '${e}'`);let t={};for(let i in e)i in this.schema||(t[i]={type:"string"});(e=>{for(let t in e)if(e.hasOwnProperty(t))return!1;return!0})(t)||this.extendSchema(t)},update:function(e){const t=this.data;for(let e in t)e in s||!n(t[e])||(this.ranges[e]=a(t[e]))},tick:function(e,t){const i=this.data,n=this.system.getByteFrequencyData(this.analyser,e),a=i.bins,s=a.length;let o=0;for(let e of a)o+=n[e];let l=o/s/255,c=l>i.threshold?l:0,d=this.el;for(let e in this.ranges){const t=r(this.ranges[e],c);switch(e){case"position":case"scale":d.object3D[e].set(...t);break;case"rotation":d.object3D[e].set(...t.map(THREE.Math.degToRad));break;default:d.setAttribute(e,t.map(e=>e.toFixed(4)).join(" "))}}}});Math.PI,Object.freeze({x:0,y:0,z:0}),Object.freeze({x:1,y:0,z:0}),Object.freeze({x:0,y:1,z:0}),Object.freeze({x:0,y:0,z:1});function o(e,t){return e.x=t.x,e.y=t.y,e.z=t.z,e}function l(e,t,i){return e.x=Math.max(t.x,i.x),e.y=Math.max(t.y,i.y),e.z=Math.max(t.z,i.z),e}const c=Math.sqrt(.5);Object.freeze({x:0,y:0,z:0,w:1}),Object.freeze({x:1,y:0,z:0,w:0}),Object.freeze({x:0,y:1,z:0,w:0}),Object.freeze({x:0,y:0,z:1,w:0}),Object.freeze({x:c,y:0,z:0,w:c}),Object.freeze({x:0,y:c,z:0,w:c}),Object.freeze({x:0,y:0,z:c,w:c});function d(e,t,i){const n=i.x,a=i.y,r=i.z;return e.x=t[0]*n+t[4]*a+t[8]*r+t[12],e.y=t[1]*n+t[5]*a+t[9]*r+t[13],e.z=t[2]*n+t[6]*a+t[10]*r+t[14],e}function h(e,t,i){const n=t[0],a=t[1],r=t[2],s=t[4],o=t[5],l=t[6],c=t[8],d=t[9],h=t[10],u=t[12],m=t[13],f=t[14],p=h*o-l*d,g=l*c-h*s,v=d*s-o*c,y=1/(n*p+a*g+r*v),b=p*y,E=(r*d-h*a)*y,x=(l*a-r*o)*y,T=g*y,A=(h*n-r*c)*y,R=(r*s-l*n)*y,S=v*y,w=(a*c-d*n)*y,C=(o*n-a*s)*y,I=i.x-u,O=i.y-m,M=i.z-f;return e.x=b*I+T*O+S*M,e.y=E*I+A*O+w*M,e.z=x*I+R*O+C*M,e}const u=function(){let e=new Float32Array(16);return function(t,i,n,a){if(i&&(i.x=t[12],i.y=t[13],i.z=t[14]),a||n){const i=Math.hypot(t[0],t[1],t[2]),r=Math.hypot(t[4],t[5],t[6]),s=Math.hypot(t[8],t[9],t[10]);if(a&&(a.x=i,a.y=r,a.z=s),n){const a=function(e){const t=e[0],i=e[1],n=e[2],a=e[4],r=e[5],s=e[6],o=e[8],l=e[9],c=e[10];return t*(c*r-s*l)+i*(s*o-c*a)+n*(l*a-r*o)}(t)<0?-1/i:1/i,o=1/r,l=1/s;e.set(t),e[0]*=a,e[1]*=a,e[2]*=a,e[4]*=o,e[5]*=o,e[6]*=o,e[8]*=l,e[9]*=l,e[10]*=l,function(e,t){const i=t[0],n=t[4],a=t[8],r=t[1],s=t[5],o=t[9],l=t[2],c=t[6],d=t[10],h=i+s+d;let u;h>0?(u=.5/Math.sqrt(h+1),e.w=.25/u,e.x=(c-o)*u,e.y=(a-l)*u,e.z=(r-n)*u):i>s&&i>d?(u=2*Math.sqrt(1+i-s-d),e.w=(c-o)/u,e.x=.25*u,e.y=(n+r)/u,e.z=(a+l)/u):s>d?(u=2*Math.sqrt(1+s-i-d),e.w=(a-l)/u,e.x=(n+r)/u,e.y=.25*u,e.z=(o+c)/u):(u=2*Math.sqrt(1+d-i-s),e.w=(r-n)/u,e.x=(a+l)/u,e.y=(o+c)/u,e.z=.25*u)}(n,e)}}return t}}();function m(e,t=Math.random){return e[function(e,t=Math.random){return~~(t()*e)}(e.length,t)]}function f(e,t,i=Math.random){return t===e?e:i()*(t-e)+e}function p(){let e=-1;return{setSeed:function(t){e=t},random:function(){return e<0?Math.random():(e=(1664525*e+1013904223)%4294967296)/4294967296}}}function g(e,t,i){return e<t?t:e>i?i:e}function v(e){return"object"==typeof e&&"r"in e&&"g"in e&&"b"in e}const y=function(){function e(e,t,i){return i<0&&(i+=1),i>1&&(i-=1),i<1/6?e+6*(t-e)*i:i<.5?t:i<2/3?e+6*(t-e)*(2/3-i):e}return function(t,i,n,a){var r;if(i=(i%(r=1)+r)%r,n=g(n,0,1),a=g(a,0,1),0===n)t.r=t.g=t.b=a;else{let r=a<=.5?a*(1+n):a+n-a*n,s=2*a-r;t.r=e(s,r,i+1/3),t.g=e(s,r,i),t.b=e(s,r,i-1/3)}return t}}();const b={aliceblue:15792383,antiquewhite:16444375,aqua:65535,aquamarine:8388564,azure:15794175,beige:16119260,bisque:16770244,black:0,blanchedalmond:16772045,blue:255,blueviolet:9055202,brown:10824234,burlywood:14596231,cadetblue:6266528,chartreuse:8388352,chocolate:13789470,coral:16744272,cornflowerblue:6591981,cornsilk:16775388,crimson:14423100,cyan:65535,darkblue:139,darkcyan:35723,darkgoldenrod:12092939,darkgray:11119017,darkgreen:25600,darkgrey:11119017,darkkhaki:12433259,darkmagenta:9109643,darkolivegreen:5597999,darkorange:16747520,darkorchid:10040012,darkred:9109504,darksalmon:15308410,darkseagreen:9419919,darkslateblue:4734347,darkslategray:3100495,darkslategrey:3100495,darkturquoise:52945,darkviolet:9699539,deeppink:16716947,deepskyblue:49151,dimgray:6908265,dimgrey:6908265,dodgerblue:2003199,firebrick:11674146,floralwhite:16775920,forestgreen:2263842,fuchsia:16711935,gainsboro:14474460,ghostwhite:16316671,gold:16766720,goldenrod:14329120,gray:8421504,green:32768,greenyellow:11403055,grey:8421504,honeydew:15794160,hotpink:16738740,indianred:13458524,indigo:4915330,ivory:16777200,khaki:15787660,lavender:15132410,lavenderblush:16773365,lawngreen:8190976,lemonchiffon:16775885,lightblue:11393254,lightcoral:15761536,lightcyan:14745599,lightgoldenrodyellow:16448210,lightgray:13882323,lightgreen:9498256,lightgrey:13882323,lightpink:16758465,lightsalmon:16752762,lightseagreen:2142890,lightskyblue:8900346,lightslategray:7833753,lightslategrey:7833753,lightsteelblue:11584734,lightyellow:16777184,lime:65280,limegreen:3329330,linen:16445670,magenta:16711935,maroon:8388608,mediumaquamarine:6737322,mediumblue:205,mediumorchid:12211667,mediumpurple:9662683,mediumseagreen:3978097,mediumslateblue:8087790,mediumspringgreen:64154,mediumturquoise:4772300,mediumvioletred:13047173,midnightblue:1644912,mintcream:16121850,mistyrose:16770273,moccasin:16770229,navajowhite:16768685,navy:128,oldlace:16643558,olive:8421376,olivedrab:7048739,orange:16753920,orangered:16729344,orchid:14315734,palegoldenrod:15657130,palegreen:10025880,paleturquoise:11529966,palevioletred:14381203,papayawhip:16773077,peachpuff:16767673,peru:13468991,pink:16761035,plum:14524637,powderblue:11591910,purple:8388736,rebeccapurple:6697881,red:16711680,rosybrown:12357519,royalblue:4286945,saddlebrown:9127187,salmon:16416882,sandybrown:16032864,seagreen:3050327,seashell:16774638,sienna:10506797,silver:12632256,skyblue:8900331,slateblue:6970061,slategray:7372944,slategrey:7372944,snow:16775930,springgreen:65407,steelblue:4620980,tan:13808780,teal:32896,thistle:14204888,tomato:16737095,turquoise:4251856,violet:15631086,wheat:16113331,white:16777215,whitesmoke:16119285,yellow:16776960,yellowgreen:10145074},E=/^((?:rgb|hsl)a?)\(\s*([^\)]*)\)/;function x(e){let t;if(t=E.exec(e)){let e;const i=t[1],n=t[2];switch(i){case"rgb":case"rgba":if(e=/^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(n)){const t={r:Math.min(255,parseInt(e[1],10))/255,g:Math.min(255,parseInt(e[2],10))/255,b:Math.min(255,parseInt(e[3],10))/255};return e[5]&&(t.a=parseFloat(e[5])),t}if(e=/^(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(n)){const t={r:Math.min(100,parseInt(e[1],10))/100,g:Math.min(100,parseInt(e[2],10))/100,b:Math.min(100,parseInt(e[3],10))/100};return e[5]&&(t.a=parseFloat(e[5])),t}break;case"hsl":case"hsla":if(e=/^([0-9]*\.?[0-9]+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(n)){const t=y({r:0,g:0,b:0,a:0},parseFloat(e[1])/360,parseInt(e[2],10)/100,parseInt(e[3],10)/100);return e[5]&&(t.a=parseFloat(e[5])),t}}}else if(t=/^\#([A-Fa-f0-9]+)$/.exec(e)){const e=t[1],i=e.length;if(3===i)return{r:parseInt(e.charAt(0)+e.charAt(0),16)/255,g:parseInt(e.charAt(1)+e.charAt(1),16)/255,b:parseInt(e.charAt(2)+e.charAt(2),16)/255};if(6===i)return{r:parseInt(e.charAt(0)+e.charAt(1),16)/255,g:parseInt(e.charAt(2)+e.charAt(3),16)/255,b:parseInt(e.charAt(4)+e.charAt(5),16)/255}}if(e&&e.length>0){const t=b[e];if(void 0!==t)return(i={r:0,g:0,b:0}).r=((t=t)>>16&255)/255,i.g=(t>>8&255)/255,i.b=(255&t)/255,i}var i,n}const T=e=>e;function A(e,t=T){const i=function(e){const t=e.split("|");if(t.length>1)return{options:t};const i=e.split("..");if(i.length>1)return{range:[i[0],i[1]]};return{options:t}}(e);return i.range?{range:i.range.map(e=>t(R(e)))}:{options:i.options.map(e=>t(R(e)))}}const R=function(){const e=e=>Number(e.trim());return function(t){if(""===t)return"";let i=t.split(" ").filter(e=>""!==e).map(e);if(!i.some(isNaN))switch(i.length){case 1:return i[0];case 2:return{x:i[0],y:i[1]};case 3:return{x:i[0],y:i[1],z:i[2]};case 4:return{x:i[0],y:i[1],z:i[2],w:i[3]}}let n=x(t.trim());return n||t.trim()}}();function S(e){return"number"==typeof e}function w(e){return"object"==typeof e&&"x"in e&&"y"in e&&"z"in e}function C(e){return"object"==typeof e&&"r"in e&&"g"in e&&"b"in e}function I(e,t){return e.range?e.range.every(t):!!e.options&&e.options.every(t)}function O(e,t,i=T){const n=A(e,i);return I(n,t)?n:void 0}function M(e,t,i=!1,n=T){if(""===e)return[];const a=j(e,",").flatMap(e=>A(e,n));return a.every(e=>i&&e||I(e,t))?a:void 0}function L(e,t=T){return O(e,S,t)}function D(e,t=!1,i=T){return M(e,S,t,i)}function F(e,t=T){return O(e,w,t)}function P(e){if(e.options){if(e.options.length>0&&"number"==typeof e.options[0])return Math.max(...e.options)}else if(e.range&&"number"==typeof e.range[0])return Math.max(...e.range)}function k(e,t=Math.random){if(e&&e.range){const i=e.range[0],n=e.range[1];return v(i)?function(e,t,i,n=Math.random){return e.r=f(t.r,i.r,n),e.g=f(t.g,i.g,n),e.b=f(t.b,i.b,n),e}({r:0,g:0,b:0},i,n,t):"object"==typeof i&&"x"in i&&"object"==typeof n&&"x"in n?function(e,t,i,n=Math.random){return e.x=f(t.x,i.x,n),e.y=f(t.y,i.y,n),"z"in t&&"z"in i&&(e.z=f(t.z,i.z,n)),"w"in t&&"w"in i&&(e.w=f(t.w,i.w,n)),e}({x:0,y:0},i,n,t):"number"==typeof i&&"number"==typeof n?f(i,n):i}if(e&&e.options)return m(e.options,t)}function _(e,t=Math.random){return e&&e.map(e=>k(e,t))}function H(e){if("object"==typeof e){if(e.range)return H(e.range[0])+".."+H(e.range[1]);if(e.options)return e.options.map(e=>H(e)).join("|");if(v(e))return"#"+function(e){return 255*e.r<<16^255*e.g<<8^255*e.b<<0}(e).toString(16).padStart(6,"0");if("x"in e&&"y"in e)return e.x+" "+e.y+("z"in e?" "+e.z:"")+("w"in e?" "+e.w:"");if(e.length&&"0"in e)return e.join(",");if(e instanceof HTMLElement)return"#"+e.id}return void 0!==e?e.toString():void 0}function j(e,t=",",i=["''",'""',"{}","[]","()"]){let n=[],a=[],r=0,s=0;for(let o=0,l=e.length;o<l;o++){const l=e[o];if(a.length>0&&l===a[a.length-1][1])a.pop();else for(let e of i)l===e[0]&&a.push(e);0===a.length&&l===t[s]?++s===t.length&&(n.push(e.substring(r,o-s+1)),r=o+1,s=0):s=0}return n.push(e.substring(r,e.length)),n}function z(e){return e.tagName.toLowerCase()+(e.id?"#"+e.id:"")+(e.classList.length>0?"."+Array.from(e.classList).join("."):"")}function V(e,t,i){for(let n of t){for(let t of n.addedNodes)t.matches(i)&&e.push(t);for(let t of n.removedNodes)t.matches(i)&&e.splice(e.indexOf(t),1)}}function B(e,t){let i=e,n=t&&Array.isArray(t)?t.slice().reverse():[];for(;i&&n.length>0;)i=i[n.pop()];return i}const U=(()=>{const e=e=>e.trim(),t={rotation:e=>isNaN(e)?0:THREE.Math.degToRad(e),position:e=>isNaN(e)?0:e,scale:e=>isNaN(e)?1:e};return function(i,n,a){let r=t[n];if(r)return Array.isArray(a)||(a="object"==typeof a?[a.x,a.y,a.z]:"number"==typeof a?[a]:a.split(" ").map(e)),a.length=3,void i.object3D[n].set(...a.map(r));const s=n.split(".");if(s.length<=2)return s[0]=s[0].replace(/[A-Z]/g,e=>"-"+e.toLowerCase()),void(a||"boolean"==typeof a||"number"==typeof a?AFRAME.utils.entity.setComponentProperty(i,s.join("."),H(a)):i.removeAttribute(s[0],s[1]));const o=B(i,s.slice(0,-1));o?o[s[s.length-1]]=a:console.warn(`unknown path for setProperty() '${n}'`)}})();function N(e,t){const i=t.split(".");if(1===i.length)return e.getAttribute(t);if(i.length<=2){i[0]=i[0].replace(/[A-Z]/g,e=>"-"+e.toLowerCase());const t=e.getAttribute(i[0]);return"object"==typeof t?t[i[1]]:void 0}return B(e,i)}function q(){let e=[];function t(e,t,n){e.id=setTimeout(()=>{i(e),n()},1e3*t),e.startTime=Date.now(),e.callback=n}function i(t){const i=e.indexOf(t);i>=0&&(clearTimeout(t.id),e.splice(i,1))}return{startTimer:function(i,n){if(i>0){const a={};return t(a,i,n),e.push(a),a}n()},clearTimer:i,clearAllTimers:function(){for(let t of e)clearTimeout(t.id);e.length=0},pause:function(){for(let t of e)t.resumeTime=Date.now()-t.startTime,clearTimeout(t.id)},resume:function(){for(let i of e)i.resumeTime&&(t(i,i.resumeTime,i.callback),delete i.resumeTime)}}}function W(e,t,i,n){switch(i){case"self":return t?e.querySelectorAll(t):[e];case"parent":return t?e.parentNode.querySelectorAll(t):[e];case"event":return t&&n instanceof HTMLElement?n.querySelectorAll(t):[e];case"document":default:return t?document.querySelectorAll(t):[e]}}function G(e,t){let i,n,a,r=!1,s=[],o=l(i);function l(e){return e&&"string"==typeof e?e.split(",").map(e=>e.trim()):[]}function c(){if(!r){for(let e of s)for(let i of o)e.addEventListener(i,t);r=!0}}function d(){if(r){for(let e of s)for(let i of o)e.removeEventListener(i,t);r=!1}}return{set:function(t,h,u){const m=r;!m||t===i&&h===n&&u===a||d(),n=h,a=u,i!==t&&(o=l(i=t)),s=W(e,n,a,void 0),m&&c()},add:c,remove:d}}function Y(e,t,i){const n=e&&e.match(/url\((.+)\)/);if(n){const e=n[1];(new THREE.FileLoader).load(e,e=>i(e),()=>{},t=>{console.error(`unable to load: ${e} `,t)})}else if(t&&e.includes(t))i(e.trim());else{const t=e?document.querySelector(e):void 0;i(t?t.textContent.trim():e.trim())}}function $(e,...t){console.warn(X(e),...t)}function Q(e,...t){console.error(X(e),...t)}function X(e){return z(e.el)+"["+e.attrName+"]"}function Z(e,t,i,n=0,a=0,r=0){return e[r]=t[n]-i[a],e[r+1]=t[n+1]-i[a+1],e[r+2]=t[n+2]-i[a+2],e}function K(e,t,i=0,n=0){const a=t[i],r=t[i+1],s=t[i+2],o=Math.hypot(a,r,s)||1;return e[n]=a/o,e[n+1]=r/o,e[n+2]=s/o,e}function J(e,t,i=0,n=0){return e[i]*t[n]+e[i+1]*t[n+1]+e[i+2]*t[n+2]}function ee(e,t,i,n,a=0,r=0,s=0){return e[s]=t[a]+i[r]*n,e[s+1]=t[a+1]+i[r+1]*n,e[s+2]=t[a+2]+i[r+2]*n,e}function te(e,t,i=1e-5,n=0,a=0){return Math.abs(e[n]-t[a])<i&&Math.abs(e[n+1]-t[a+1])<i&&Math.abs(e[n+2]-t[a+2])<i}function ie(e,t,i,n=0,a=0,r=0){const s=t[n],o=t[n+1],l=t[n+2],c=i[a],d=i[a+1],h=i[a+2];return e[r]=o*h-l*d,e[r+1]=l*c-s*h,e[r+2]=s*d-o*c,e}const ne=function(){let e=new Float32Array(3),t=new Float32Array(3),i=new Float32Array(3);return function(n,a,r,s,o=0,l=0,c=0,d=0){return Z(e,s,r,c,l),Z(t,a,r,o,l),K(n,ie(i,e,t),0,d)}}();function ae(e,t,i,n=0){const a=i.length;let r=0,s=0,o=0;for(let e=0;e<i.length;e++){const n=i[e];r+=t[n]/a,s+=t[n+1]/a,o+=t[n+2]/a}return function(e,t=0,i=0,n=0,a=0){return e[a]=t,e[a+1]=i,e[a+2]=n,e}(e,r,s,o,n)}const re=function(){const e=new Float32Array(3),t=new Float32Array(3),i=new Float32Array(3);return function(n,a,r,s,o=1e-5,l=0,c=0,d=0,h=0){return Z(e,a,n,c,l),Z(t,r,n,d,l),Z(i,s,n,h,l),Math.abs(J(i,ie(e,e,t)))<o}}();function se(e,t,i,n=0,a=0){return e[a]=t[n]*i,e[a+1]=t[n+1]*i,e[a+2]=t[n+2]*i,e}function oe(e,t,i){return 0===i?e:e+(t-e)*i}function le(e,t,i){let n=Object.assign({},e);if(0===i)return n;for(let a in t)n[a]=void 0!==e[a]?oe(e[a],t[a],i):t[a];return n}function ce(e,t,i=de){const n=e.length;if(t<=0||n<=1)return[0,0];if(t>=1)return[n-2,1];const a=t*(n-1),r=~~a;return[r,i(a-r)]}function de(e){return e}const he={In:function(e){return e*e},Out:function(e){return e*(2-e)},InOut:function(e){return(e*=2)<1?.5*e*e:-.5*(--e*(e-2)-1)}},ue={In:function(e){return e*e*e},Out:function(e){return--e*e*e+1},InOut:function(e){return(e*=2)<1?.5*e*e*e:.5*((e-=2)*e*e+2)}},me={In:function(e){return e*e*e*e},Out:function(e){return 1- --e*e*e*e},InOut:function(e){return(e*=2)<1?.5*e*e*e*e:-.5*((e-=2)*e*e*e-2)}},fe={In:function(e){return e*e*e*e*e},Out:function(e){return--e*e*e*e*e+1},InOut:function(e){return(e*=2)<1?.5*e*e*e*e*e:.5*((e-=2)*e*e*e*e+2)}},pe={In:function(e){return 1-Math.cos(e*Math.PI/2)},Out:function(e){return Math.sin(e*Math.PI/2)},InOut:function(e){return.5*(1-Math.cos(Math.PI*e))}},ge={In:function(e){return 0===e?0:Math.pow(1024,e-1)},Out:function(e){return 1===e?1:1-Math.pow(2,-10*e)},InOut:function(e){return 0===e?0:1===e?1:(e*=2)<1?.5*Math.pow(1024,e-1):.5*(2-Math.pow(2,-10*(e-1)))}},ve={In:function(e){return 1-Math.sqrt(1-e*e)},Out:function(e){return Math.sqrt(1- --e*e)},InOut:function(e){return(e*=2)<1?-.5*(Math.sqrt(1-e*e)-1):.5*(Math.sqrt(1-(e-=2)*e)+1)}},ye={In:function(e){return 0===e?0:1===e?1:-Math.pow(2,10*(e-1))*Math.sin(5*(e-1.1)*Math.PI)},Out:function(e){return 0===e?0:1===e?1:Math.pow(2,-10*e)*Math.sin(5*(e-.1)*Math.PI)+1},InOut:function(e){return 0===e?0:1===e?1:(e*=2)<1?-.5*Math.pow(2,10*(e-1))*Math.sin(5*(e-1.1)*Math.PI):.5*Math.pow(2,-10*(e-1))*Math.sin(5*(e-1.1)*Math.PI)+1}},be={In:function(e){var t=1.70158;return e*e*((t+1)*e-t)},Out:function(e){var t=1.70158;return--e*e*((t+1)*e+t)+1},InOut:function(e){var t=2.5949095;return(e*=2)<1?e*e*((t+1)*e-t)*.5:.5*((e-=2)*e*((t+1)*e+t)+2)}},Ee={In:function(e){return 1-Ee.Out(1-e)},Out:function(e){return e<1/2.75?7.5625*e*e:e<2/2.75?7.5625*(e-=1.5/2.75)*e+.75:e<2.5/2.75?7.5625*(e-=2.25/2.75)*e+.9375:7.5625*(e-=2.625/2.75)*e+.984375},InOut:function(e){return e<.5?.5*Ee.In(2*e):.5*Ee.Out(2*e-1)+.5}},xe={linear:de,ease:ue.InOut,"ease-in":ue.In,"ease-out":ue.Out,"ease-in-out":ue.InOut,"ease-cubic":ue.In,"ease-in-cubic":ue.In,"ease-out-cubic":ue.Out,"ease-in-out-cubic":ue.InOut,"ease-quad":he.InOut,"ease-in-quad":he.In,"ease-out-quad":he.Out,"ease-in-out-quad":he.InOut,"ease-quart":me.InOut,"ease-in-quart":me.In,"ease-out-quart":me.Out,"ease-in-out-quart":me.InOut,"ease-quint":fe.InOut,"ease-in-quint":fe.In,"ease-out-quint":fe.Out,"ease-in-out-quint":fe.InOut,"ease-sine":pe.InOut,"ease-in-sine":pe.In,"ease-out-sine":pe.Out,"ease-in-out-sine":pe.InOut,"ease-expo":ge.InOut,"ease-in-expo":ge.In,"ease-out-expo":ge.Out,"ease-in-out-expo":ge.InOut,"ease-circ":ve.InOut,"ease-in-circ":ve.In,"ease-out-circ":ve.Out,"ease-in-out-circ":ve.InOut,"ease-elastic":ye.InOut,"ease-in-elastic":ye.In,"ease-out-elastic":ye.Out,"ease-in-out-elastic":ye.InOut,"ease-back":be.InOut,"ease-in-back":be.In,"ease-out-back":be.Out,"ease-in-out-back":be.InOut,"ease-bounce":Ee.InOut,"ease-in-bounce":Ee.In,"ease-out-bounce":Ee.Out,"ease-in-out-bounce":Ee.InOut},Te=function(){const e={x:0,y:0,z:0};return function(t,i,n,a,r,s){for(let f=0;f<8;f++)e.x=f%2?a.x:n.x,e.y=(f>>>1)%2?a.y:n.y,e.z=(f>>>2)%2?a.z:n.z,d(e,r,e),h(e,s,e),0===f?(o(t,e),o(i,e)):(u=e,m=t,(c=t).x=Math.min(u.x,m.x),c.y=Math.min(u.y,m.y),c.z=Math.min(u.z,m.z),l(i,e,i));var c,u,m}}(),Ae=function(){let e={x:0,y:0,z:0},t={x:0,y:0,z:0};function i(i,n,a,r,s,o){return Te(e,t,i,n,a,o),Math.max(e.x-s.x,e.y-s.y,e.z-s.z,r.x-t.x,r.y-t.y,r.z-t.z)}return function(e,t,n,a,r,s){const o=i(e,t,n,a,r,s),l=i(a,r,s,e,t,n);return Math.max(o,l)}}(),Re=function(){let e={x:0,y:0,z:0},t={x:1,y:1,z:1};return function(i,n,a,r){u(r,void 0,void 0,t),h(e,r,i);const s=e.x,o=e.y,l=e.z,c=n.x-s,d=n.y-o,m=n.z-l,f=s-a.x,p=o-a.y,g=l-a.z,v=Math.max(f,c)*t.x,y=Math.max(p,d)*t.y,b=Math.max(g,m)*t.z;return v<=0&&y<=0&&b<=0?Math.max(v,y,b):Math.hypot(Math.max(0,v),Math.max(0,y),Math.max(0,b))}}();const Se=function(){let e={x:0,y:0,z:0},t={x:0,y:0,z:0};return function(i,n,a,r,s,o){return Te(e,t,i,n,a,o),e.x>r.x&&e.y>r.y&&e.z>r.z&&t.x<s.x&&t.y<s.y&&t.z<s.z}}();function we(e,t){for(let i of["map","alphaMap","aoMap","bumpMap","displacementMap","emissiveMap","envMap","lighMap","metalnessMap","normalMap","roughnessMap"])e[i]&&e[i].image===t&&(e[i].needsUpdate=!0)}function Ce(e,t){e.uniforms&&e.uniforms.map&&e.uniforms.map.value&&"object"==typeof e.uniforms.map.value&&e.uniforms.map.value.image===t&&(e.uniforms.map.value.needsUpdate=!0)}function Ie(e,t){e.traverse(e=>{if(e.material)if(Array.isArray(e.material))for(let i of e.material)we(i,t),Ce(i,t);else we(e.material,t),Ce(e.material,t)})}const Oe=function(){let e=new THREE.Vector3,t=new THREE.Quaternion,i=new THREE.Vector3,n=new THREE.Box3;return function(a,r){if(0===r.children.length)return a;e.copy(r.position),t.copy(r.quaternion),i.copy(r.scale);const s=r.parent;return r.parent=null,r.position.set(0,0,0),r.quaternion.set(0,0,0,1),r.scale.set(1,1,1),n.setFromObject(r),r.parent=s,r.position.copy(e),r.quaternion.copy(t),r.scale.copy(i),r.updateMatrixWorld(!0),a.min.x=n.min.x,a.min.y=n.min.y,a.min.z=n.min.z,a.max.x=n.max.x,a.max.y=n.max.y,a.max.z=n.max.z,a}}();function Me(e,t){e.boundingBox=e.boundingBox||new THREE.Box3,e.boundingSphere=e.boundingSphere||new THREE.Sphere,e.boundingBoxDebug&&(e.remove(e.boundingBoxDebug),e.boundingBoxDebug=void 0),Oe(e.boundingBox,e),e.boundingBox.isEmpty()||(e.boundingBox.getBoundingSphere(e.boundingSphere),t&&(e.boundingBoxDebug=new THREE.Box3Helper(e.boundingBox,t),e.boundingBoxDebug.name="orientedBoundingDebug",e.add(e.boundingBoxDebug)))}var Le=Math.PI/180,De=48,Fe=57,Pe=44,ke=32,_e=46,He=45;function je(e){'"'!==e[0]&&"'"!==e[0]||(e=e.substring(1,e.length-1));var t,i,n,a,r=new THREE.Shape,s=1,o=e.length,l=0,c=0,d=0,h=0,u=null,m=null,f=0,p=0,g=0,v=0,y=0,b=0,E=0,x=0,T=0;function A(){for(var t,i,n,a=!1;s<o&&((i=e.charCodeAt(s))===Pe||i===ke);)s++;for(t=i===He?s++:s;s<o;)if(i=e.charCodeAt(s),De<=i&&i<=Fe)s++;else{if(i!==_e)return n=e.substring(t,s),a?parseFloat(n):parseInt(n);s++,a=!0}return n=e.substring(t),a?parseFloat(n):parseInt(n)}function R(){for(var t;s<o&&((t=e.charCodeAt(s))===Pe||t===ke);)s++;return(t=e.charCodeAt(s))===He||De<=t&&t<=Fe}for(t=e[0];s<=o;){switch(a=!0,t){case"M":l=A(),c=A(),r.moveTo(l,c),t="L",u=l,m=c;break;case"m":l+=A(),c+=A(),r.moveTo(l,c),t="l",u=l,m=c;break;case"Z":case"z":a=!1,l===u&&c===m||r.lineTo(u,m);break;case"L":case"H":case"V":d="V"===t?l:A(),h="H"===t?c:A(),r.lineTo(d,h),l=d,c=h;break;case"l":case"h":case"v":d="v"===t?l:l+A(),h="h"===t?c:c+A(),r.lineTo(d,h),l=d,c=h;break;case"C":f=A(),g=A();case"S":"S"===t&&(f=2*l-p,g=2*c-v),p=A(),v=A(),d=A(),h=A(),r.bezierCurveTo(f,g,p,v,d,h),l=d,c=h;break;case"c":f=l+A(),g=c+A();case"s":"s"===t&&(f=2*l-p,g=2*c-v),p=l+A(),v=c+A(),d=l+A(),h=c+A(),r.bezierCurveTo(f,g,p,v,d,h),l=d,c=h;break;case"Q":f=A(),g=A();case"T":"T"===t&&(f=2*l-f,g=2*c-g),d=A(),h=A(),r.quadraticCurveTo(f,g,d,h),l=d,c=h;break;case"q":f=l+A(),g=c+A();case"t":"t"===t&&(f=2*l-f,g=2*c-g),d=l+A(),h=c+A(),r.quadraticCurveTo(f,g,d,h),l=d,c=h;break;case"A":y=A(),b=A(),E=A()*Le,x=A(),T=A(),d=A(),h=A(),y!==b&&console.warn("Forcing elliptical arc to be a circular one :(",y,b),f=Math.cos(E)*(l-d)/2+Math.sin(E)*(c-h)/2,g=-Math.sin(E)*(l-d)/2+Math.cos(E)*(c-h)/2;var S=Math.sqrt((y*y*b*b-y*y*g*g-b*b*f*f)/(y*y*g*g+b*b*f*f));x===T&&(S=-S),p=S*y*g/b,v=S*-b*f/y,i=Math.cos(E)*p-Math.sin(E)*v+(l+d)/2,n=Math.sin(E)*p+Math.cos(E)*v+(c+h)/2;var w=new THREE.Vector2(1,0),C=new THREE.Vector2((f-p)/y,(g-v)/b),I=Math.acos(w.dot(C)/w.length()/C.length());w.x*C.y-w.y*C.x<0&&(I=-I),w.x=(-f-p)/y,w.y=(-g-v)/b;var O=Math.acos(C.dot(w)/C.length()/w.length());C.x*w.y-C.y*w.x<0&&(O=-O),!T&&O>0&&(O-=2*Math.PI),T&&O<0&&(O+=2*Math.PI),r.absarc(i,n,y,I,I+O,T),l=d,c=h;break;default:throw new Error("weird path command: "+t)}a&&R()||(t=e[s++])}return r}const ze=function(){let e=new THREE.Vector3,t=new THREE.Vector3;return function(i,n){let a,r,s=9*Math.floor(Math.random()*i.length/9);e.fromArray(i,s),t.fromArray(i,s+3),n.fromArray(i,s+6);do{a=Math.random(),r=Math.random()}while(a+r>1);t.sub(e).multiplyScalar(a),n.sub(e).multiplyScalar(r).add(t).add(e)}}(),Ve=function(){let e=new THREE.Vector3,t=new THREE.Vector3;return function(i,n){const a=9*Math.floor(Math.random()*i.length/9),r=3*Math.random();r>2?(e.fromArray(i,a+6),t.fromArray(i,a)):r>1?(e.fromArray(i,a+3),t.fromArray(i,a+6)):(e.fromArray(i,a),t.fromArray(i,a+3)),n.copy(t).sub(e).multiplyScalar(r-Math.floor(r)).add(e)}}();AFRAME.registerComponent("chalk",{dependencies:["raycaster"],schema:{color:{type:"color"},length:{default:.1},radius:{default:.02},debug:{default:!1}},init(){this.boards=[],this.onRaycasterIntersection=this.onRaycasterIntersection.bind(this),this.onRaycasterIntersectionCleared=this.onRaycasterIntersectionCleared.bind(this);const e=this.data,t=new THREE.CylinderBufferGeometry(e.radius,e.radius,e.length,16);t.applyMatrix((new THREE.Matrix4).set(1,0,0,0,0,0,1,0,0,-1,0,0,0,0,0,1));const i=new THREE.Mesh(t,new THREE.MeshBasicMaterial({color:e.color}));this.el.setObject3D("mesh",i)},update(e){const t=this.data;if(t.color!==e.color){const e=this.el.getObject3D("mesh");e&&e.material&&!Array.isArray(e.material)&&e.material.color.setStyle(t.color)}},play(){this.el.addEventListener("raycaster-intersection",this.onRaycasterIntersection),this.el.addEventListener("raycaster-intersection-cleared",this.onRaycasterIntersectionCleared)},pause(){this.el.removeEventListener("raycaster-intersection",this.onRaycasterIntersection),this.el.removeEventListener("raycaster-intersection-cleared",this.onRaycasterIntersectionCleared)},onRaycasterIntersection(e){this.data.debug&&console.log("contact"),0===this.boards.length&&this.startTick(),this.boards.push(...e.detail.els.map(e=>({el:e,radius:-1,ctx:void 0,texture:void 0,prevIntersection:void 0})))},onRaycasterIntersectionCleared(e){this.data.debug&&console.log("cleared"),this.boards.length=0},tick(){if(0===this.boards.length)return void this.stopTick();const e=this.el.components.raycaster;for(let t of this.boards)this.tryDrawOnBoard(e,t)},startTick(){this.el.sceneEl.addBehavior(this)},stopTick(){this.el.sceneEl.removeBehavior(this)},tryDrawOnBoard:function(){const e=new THREE.Vector2;return function(t,i){const n=this.data,a=t.getIntersection(i.el);if(!a)return!1;if(!i.ctx){let e,t;a.object&&a.object.isMesh&&(t=a.object.material.map)&&t.image&&t.image instanceof HTMLCanvasElement&&(e=t.image),i.ctx=e?e.getContext("2d"):void 0,i.texture=t}const r=i.ctx,s=i.texture;if(i.radius<0&&r)if(i.prevIntersection){const e=a.point.distanceTo(i.prevIntersection.point);if(e>.001){const t=n.radius/e,s=t*(a.uv.x-i.prevIntersection.uv.x)*r.canvas.width,o=t*(a.uv.y-i.prevIntersection.uv.y)*r.canvas.height;i.radius=Math.hypot(s,o),i.prevIntersection=void 0}}else i.prevIntersection=a;const o=i.radius;if(r&&s&&o>0){e.set(a.uv.x,a.uv.y),s.transformUv(e);const t=r.canvas,o=e.x*t.width,l=e.y*t.height,c=i.radius;r.beginPath(),r.fillStyle=n.color,r.arc(o,l,c,0,2*Math.PI),r.fill(),Ie(this.el.sceneEl.object3D,t)}return!0}}()}),AFRAME.registerComponent("climb",{schema:{cameraRig:{type:"selector"},enabled:{default:!0},debug:{default:!1}},init(){this.onGrabStart=this.onGrabStart.bind(this),this.onGrabEnd=this.onGrabEnd.bind(this),this.onSceneLoaded=this.onSceneLoaded.bind(this),this.grab={hand:void 0,target:void 0,position:new THREE.Vector3}},tick:function(){let e=new THREE.Vector3;return function(){const t=this.data;if(t.enabled&&this.grab.hand&&this.grab.target){const i=t.cameraRig?t.cameraRig.object3D:this.el.object3D;i&&(this.grab.hand.object3D.getWorldPosition(e).sub(this.grab.position),i.position.sub(e))}}}(),play(){this.addListeners()},pause(){this.removeListeners()},addListeners(){this.el.addEventListener("grabstart",this.onGrabStart),this.el.addEventListener("grabend",this.onGrabEnd)},removeListeners(){this.el.removeEventListener("grabstart",this.onGrabStart),this.el.removeEventListener("grabend",this.onGrabEnd)},onGrabStart(e){this.data.debug&&console.log(z(this.el),this.attrName,"onGrabStart",z(e.detail.hand),z(e.detail.object)),this.grab.hand=e.detail.hand,this.grab.target=e.detail.object,this.grab.hand.object3D.getWorldPosition(this.grab.position)},onGrabEnd(e){this.data.debug&&console.log(z(this.el),this.attrName,"onGrabEnd",z(e.detail.hand)),e.detail.hand===this.grab.hand&&(this.grab.hand=void 0)}});let Be=0;AFRAME.registerComponent("clone-entity",{schema:{type:"selector"},multiple:!0,update(){const e=this.data;let t=document.importNode(e instanceof HTMLTemplateElement?e.content:e,!0);const i=e=>{e.id&&(e.id+="_clone"+Be),e.children.forEach(i)};i(t),this.el.appendChild(t),Be++}}),AFRAME.registerComponent("clone-geometry",{schema:{src:{type:"selector"}},init(){this.onObject3DSet=this.onObject3DSet.bind(this)},update(e){if(this.data.src!==e.src){e instanceof HTMLElement&&e.removeEventListener("object3dset",this.onObject3DSet);const t=this.data.src;t instanceof HTMLElement&&"object3D"in t&&(this.cloneObject3D(t),t.addEventListener("object3dset",this.onObject3DSet))}},onObject3DSet(e){e.target===this.data.src&&e.detail.type&&this.cloneObject3D(this.data.src)},cloneObject3D(e){const t=this.el.object3D;for(let e in this.el.object3DMap)this.el.removeObject3D(e);for(;t.children.length>0;)t.remove(t.children[0]);function i(t){for(let i in e.object3DMap)if(t===e.object3DMap[i])return i}for(let n=0;n<e.object3D.children.length;n++){const a=e.object3D.children[n],r=i(a);r?this.el.setObject3D(r,a.clone()):t.add(a.clone())}}}),AFRAME.registerComponent("extrude",{schema:{shape:{default:""},depth:{default:100},curveSegments:{type:"int",default:12},bevelEnabled:{default:!0},bevelThickness:{default:6},bevelSize:{default:2},bevelSegments:{type:"int",default:3},extrudePath:{default:""},steps:{type:"int",default:1}},update(){const e=this.data,t=je(e.shape),i={...e,extrudePath:e.extrudePath?je(e.extrudePath):void 0},n=new THREE.ExtrudeBufferGeometry(t,i),a=new THREE.Mesh(n,new THREE.MeshBasicMaterial);this.el.setObject3D("mesh",a)}});AFRAME.registerComponent("face-color",{schema:{color:{type:"color"},faces:{type:"array",parse:function(e){return"string"==typeof e?e.split(",").map(e=>parseInt(e,10)):e}},minPosition:{type:"vec3",default:{x:-1e10,y:-1e10,z:-1e10}},maxPosition:{type:"vec3",default:{x:1e10,y:1e10,z:1e10}},minSlope:{type:"int",default:0},maxSlope:{type:"int",default:90},meshName:{default:"mesh"}},multiple:!0,init(){this.onObject3DSet=this.onObject3DSet.bind(this),this.el.addEventListener("object3dset",this.onObject3DSet),this.isFirstFrame=!0,this.applyingFaceColors=!1},remove(){this.el.removeEventListener("object3dset",this.onObject3DSet)},update(){if(this.isFirstFrame)this.applyFaceColors(),this.isFirstFrame=!1;else{const e=this.el.components;for(let t in e)0===t.indexOf("face-color")&&e[t].applyFaceColors()}},onObject3DSet(e){e.target===this.el&&e.detail.type===this.data.meshName&&this.applyFaceColors()},applyFaceColors(){const e=this.data,t=this.el.getObject3D(e.meshName);if(t&&!this.applyingFaceColors){let i=t.geometry,n=!1;const a=t.material.color;if(a.r<.3&&a.g<.3&&a.b<.3&&$("material color is very dark, face-color will also be dark"),i.isInstancedBufferGeometry)return void $("face-color does not support InstancedBufferGeometry");if(this.applyingFaceColors=!0,i.isGeometry&&(i=(new THREE.BufferGeometry).copy(i),n=!0),i.index&&(i=i.toNonIndexed(),n=!0),!i.getAttribute("color")){const e=new Float32Array(3*i.getAttribute("position").count).fill(1);i.addAttribute("color",new THREE.Float32BufferAttribute(e,3))}const r=i.getAttribute("position"),s=i.getAttribute("normal"),o=i.getAttribute("color"),l=e.minPosition.x-.5,c=e.minPosition.y,d=e.minPosition.z-.5,h=e.maxPosition.x-.5,u=e.maxPosition.y,m=e.maxPosition.z-.5,f=new THREE.Color(e.color),p=1e-5,g=THREE.Math.degToRad,v=Math.cos(g(Math.max(0,e.minSlope)))+p,y=Math.cos(g(Math.max(0,e.maxSlope)))-p;for(let t=0,i=o.count,n=0;t<i;t+=3,n++){let i=!1;if(e.faces.length>0&&!e.faces.includes(n))i=!1;else{i=!0;for(let e=0;e<3;e++){const n=t+e,a=r.getX(n),o=r.getY(n),f=r.getZ(n);if(a<l||a>h||o<c||o>u||f<d||f>m){i=!1;break}const p=Math.abs(s.getY(n));if(p<y||p>v){i=!1;break}}}if(i)for(let e=0;e<3;e++)o.setXYZ(t+e,f.r,f.g,f.b)}o.needsUpdate=!0;const b=t.material;if(b.vertexColors=THREE.VertexColors,n){console.info(`face-color rebuilding mesh '${e.meshName}'`);const t=new THREE.Mesh(i,b);this.el.setObject3D(e.meshName,t)}this.applyingFaceColors=!1}}});var Ue={},Ne={};AFRAME.registerComponent("gltf-part",{schema:{part:{type:"string"},src:{type:"asset"}},update:function(){var e=this.el;!this.data.part&&this.data.src||this.getModel(function(t){t&&e.setObject3D("mesh",t)})},getModel:function(e){var t=this;if(!Ne[this.data.src])return Ue[this.data.src]?Ue[this.data.src].then(function(i){e(t.selectFromModel(i))}):void(Ue[this.data.src]=new Promise(function(i){(new THREE.GLTFLoader).load(t.data.src,function(n){var a=n.scene||n.scenes[0];Ne[t.data.src]=a,delete Ue[t.data.src],e(t.selectFromModel(a)),i(a)},function(){},console.error)}));e(this.selectFromModel(Ne[this.data.src]))},selectFromModel:function(e){var t;if(t=e.getObjectByName(this.data.part))return t.clone();console.error("[gltf-part] `"+this.data.part+"` not found in model.")}}),AFRAME.registerComponent("handle",{schema:{target:{default:"parent"},debug:{default:!1}},events:{grabstart:function(e){this.onGrabStart(e)},grabend:function(e){this.onGrabEnd(e)}},init(){this.onGrabStart=this.onGrabStart.bind(this),this.onGrabEnd=this.onGrabEnd.bind(this),this.grabHand=void 0,this.invHandMatrix=new THREE.Matrix4},tick(){this.grabHand?this.repositionTarget():this.el.sceneEl.removeBehavior(this)},repositionTarget:function(){const e=new THREE.Matrix4,t=new THREE.Matrix4,i=new THREE.Vector3;return function(){const n=this.getTargetObject3D(this.data.target);if(!n)return;const a=this.grabHand.object3D;a.updateMatrixWorld(),n.updateMatrixWorld(),t.getInverse(n.parent.matrixWorld),e.copy(this.invHandMatrix).premultiply(a.matrixWorld).premultiply(t),e.decompose(n.position,n.quaternion,i)}}(),getTargetObject3D(e){switch(e){case"self":return this.el.object3D;case"parent":return this.el.object3D.parent;default:const t=document.querySelector(this.data.target);return t?t.object3D:void 0}},onGrabStart(e){this.data.debug&&console.log(z(this.el),"onGrabStart",z(e.detail.hand)),this.grabHand=e.detail.hand,this.el.sceneEl.addBehavior(this);const t=this.getTargetObject3D(this.data.target);if(t){const e=this.grabHand.object3D;e.updateMatrixWorld(),t.updateMatrixWorld(),this.invHandMatrix.getInverse(e.matrixWorld).multiply(t.matrixWorld)}},onGrabEnd(e){this.data.debug&&console.log(z(this.el),"onGrabEnd",z(e.detail.hand)),this.grabHand===e.detail.hand&&(this.grabHand=void 0)}});const qe={rgb:[1/765,1/765,1/765,0],rgba:[1/765,1/765,1/765,1/765],r:[1/255,0,0,0],g:[0,1/255,0,0],b:[0,0,1/255,0],a:[0,0,0,1/255]};function We(e){let t=[];e.parent.updateMatrixWorld();const i=(new THREE.Matrix4).getInverse(e.matrixWorld),n=new THREE.Matrix4,a=new THREE.Vector3;return e.traverse(e=>{const r=e.isMesh?e:void 0;if(r&&r.geometry)if(n.copy(r.matrixWorld).multiply(i),r.geometry.isBufferGeometry){const e=r.geometry.getAttribute("position").array,i=r.geometry.getAttribute("position").itemSize,s=e.length;for(let r=0;r<s;r+=i)a.set(e[r],e[r+1],e[r+2]).applyMatrix4(n),t.push(a.x,a.y,a.z)}else{const e=r.geometry.vertices,i=r.geometry.vertices.length;for(let r=0;r<i;r++)a.copy(e[r]).applyMatrix4(n),t.push(a.x,a.y,a.z)}}),t.length>0?t:void 0}AFRAME.registerComponent("heightfield",{schema:{src:{type:"selector"},numRows:{type:"int",default:32},numCols:{type:"int",default:32},heightScale:{default:.2},channels:{default:"rgb",oneOf:Object.keys(qe)},smooth:{default:!1}},init(){this.onLoaded=this.onLoaded.bind(this),this.loadTextureCallback=this.loadTextureCallback.bind(this),this.geometry=void 0,this.image=void 0},update(e){const t=this.data;e.src!==t.src?this.loadTexture(t.src):e.numRows!==t.numRows||e.numCols!==t.numCols||e.smooth!==t.smooth?this.createHeightfield(this.image):e.heightScale===t.heightScale&&e.channels===t.channels||this.el.getObject3D("mesh")===this.mesh&&this.updateHeightfield(this.image)},loadTexture(e){this.el.sceneEl.systems.material.loadTexture(e,{src:e},this.loadTextureCallback)},loadTextureCallback(e){e&&e.image&&e.image instanceof HTMLElement?this.createHeightfield(e.image):$(`heightfield: unable to access image '${this.data.src}'`)},onLoaded(e){this.createHeightfield(e.target)},createHeightfield(e){this.image!==e&&(this.image&&this.image.removeEventListener("loaded",this.onLoaded),this.image=e,e&&e.addEventListener("loaded",this.onLoaded));const t=this.data.numRows,i=this.data.numCols;let n;if(this.data.smooth)(n=new THREE.PlaneBufferGeometry(1,1,i,t)).applyMatrix((new THREE.Matrix4).set(1,0,0,0,0,0,-1,0,0,-1,0,0,0,0,0,1));else{const e=6*(i*t),a=new Float32Array(3*e),r=new Float32Array(3*e),s=new Float32Array(2*e);n=new THREE.BufferGeometry;for(let e=0;e<t;e++)for(let n=0;n<i;n++){const r=6*(e*i+n)*3,o=6*(e*i+n)*2,l=n/i,c=(n+1)/i,d=e/t,h=(e+1)/t;a[r+3]=a[r+9]=a[r+15]=l-.5,a[r+2]=a[r+5]=a[r+17]=d-.5,a[r+0]=a[r+6]=a[r+12]=c-.5,a[r+8]=a[r+11]=a[r+14]=h-.5,s[o+2]=s[o+6]=s[o+10]=l,s[o+1]=s[o+3]=s[o+11]=1-d,s[o+0]=s[o+4]=s[o+8]=c,s[o+5]=s[o+7]=s[o+9]=1-h}n.addAttribute("position",new THREE.Float32BufferAttribute(a,3)),n.addAttribute("normal",new THREE.Float32BufferAttribute(r,3)),n.addAttribute("uv",new THREE.Float32BufferAttribute(s,2))}const a=this.el.getObject3D("mesh");this.mesh=new THREE.Mesh(n,a?a.material:new THREE.MeshBasicMaterial),this.updateHeightfield(this.image),this.el.setObject3D("mesh",this.mesh)},updateHeightfield(e){let t;e instanceof HTMLCanvasElement?t=e:((t=document.createElement("canvas")).width=e.width,t.height=e.height,t.getContext("2d").drawImage(e,0,0));const i=t.width,n=t.height,a=t.getContext("2d").getImageData(0,0,i,n).data,r=this.data.numRows,s=this.data.numCols,o=this.mesh.geometry.getAttribute("uv"),l=this.mesh.geometry.getAttribute("position"),c=qe[this.data.channels]||qe.rgb,d=this.data.heightScale,h=r*s,u=new Float32Array((r+1)*(s+1)),m=new Float32Array(h),f=(i-1)/s,p=(n-1)/r;for(let e=0;e<=r;e++)for(let t=0;t<=s;t++){const n=4*(Math.floor(t*f)+Math.floor(e*p)*i);u[t+e*(s+1)]=(a[n]*c[0]+a[n+1]*c[1]+a[n+2]*c[2]+a[n+3]*c[3])*d}for(let e=0;e<r;e++)for(let t=0;t<s;t++){const n=4*(Math.floor((t+.5)*f)+Math.floor((e+.5)*p)*i);m[t+e*s]=(a[n]*c[0]+a[n+1]*c[1]+a[n+2]*c[2]+a[n+3]*c[3])*d}if(this.data.smooth)for(let e=0;e<l.count;e++)l.setY(e,u[e]);else for(let e=0;e<r;e++)for(let t=0;t<s;t++){const i=t+e*(s+1),n=t+e*s,a=6*n,r=u[i],c=u[i+1],d=u[i+s+1],h=u[i+s+2],f=m[n],p=t/s,g=(t+1)/s;l.setY(a,c),l.setY(a+1,r),l.setY(a+3,d),l.setY(a+4,h),Math.abs(.5*(r+h)-f)>Math.abs(.5*(d+c)-f)?(l.setX(a+2,p-.5),l.setY(a+2,d),l.setX(a+5,g-.5),l.setY(a+5,c),o.setX(a+2,p),o.setX(a+5,g)):(l.setX(a+2,g-.5),l.setY(a+2,h),l.setX(a+5,p-.5),l.setY(a+5,r),o.setX(a+2,g),o.setX(a+5,p))}this.mesh.geometry.computeVertexNormals(),l.needsUpdate=!0}}),AFRAME.registerComponent("hull",{schema:{points:{default:""},src:{type:"selector"},computeNormals:{default:!1}},init(){this.onObject3DSet=this.onObject3DSet.bind(this)},update(e){const t=this.data;let i;if(t.src===this.el&&Q("cannot set 'src' to yourself"),t.src!==e.src&&(e.src&&e.src.removeEventListener("object3dset",this.onObject3DSet),t.src&&(t.src.object3D?(i=We(t.src.object3D),t.src.addEventListener("object3dset",this.onObject3DSet)):$("'src' must point to an entity"))),t.points!==e.points&&t.points&&!i){const e=t.points.split(",").map(e=>AFRAME.utils.coordinates.parse(e)),n=["x","y","z"];i=Float32Array.from({length:3*e.length},(t,i)=>e[~~(i/3)][n[i%3]])}i&&this.generateHull(i)},generateHull(e){const t=function(e,t=3){const i=e.length;if(i<12)return;const n=[],a=new Float32Array(3),r=new Float32Array(3),s=1e-5;function o(t,i,n){const s=new Float32Array(3);return ne(s,e,e,e,t,i,n),J(s,Z(r,e,a,t))>0?{ai:t,bi:i,ci:n,normal:s}:{ai:t,bi:n,ci:i,normal:se(s,s,-1)}}function l(t){let i=[];for(let a=0;a<n.length;a++)K(r,Z(r,e,e,t,n[a].ai)),J(r,n[a].normal)>s&&i.push(a);return i}function c(e){for(let t=0;t<e.length;){let i=!1;for(let n=t+1;n<e.length;n++)if(e[t][0]===e[n][0]&&e[t][1]===e[n][1]||e[t][1]===e[n][0]&&e[t][0]===e[n][1]){e.splice(n,1),e.splice(t,1),i=!0;break}i||t++}return e}let d=0,h=0;for(let r=0,s=0,l=0,c=t;c<i;c+=t)if(0===s)te(e,e,1e-5,c,r)||(s=c);else if(0===l)te(e,e,1e-5,c,s)||(l=c);else if(0===h&&!te(e,e,1e-5,c,l)&&!re(e,e,e,e,1e-5,r,s,l,c)){ae(a,e,[r,s,l,h=c]),n.push(o(r,s,l)),n.push(o(r,s,h)),n.push(o(r,l,h)),n.push(o(s,l,h)),d=4;break}if(0!==d){for(let r=3*t;r<i;r+=t){if(r===h)continue;const t=l(r),i=t.flatMap(e=>{const t=n[e];return[[t.ai,t.bi],[t.ai,t.ci],[t.bi,t.ci]]});t.length>1&&c(i),ee(a,e,a,d,r,0),se(a,a,1/(d+1));for(let e=t.length-1;e>=0;--e)n.splice(t[e],1);for(let e of i)n.push(o(e[0],e[1],r));d++}return n.flatMap(e=>[e.ai,e.bi,e.ci])}}(e).flatMap(t=>[e[t],e[t+1],e[t+2]]),i=new THREE.BufferGeometry;i.addAttribute("position",new THREE.BufferAttribute(Float32Array.from(t),3)),this.data.computeNormals&&i.computeVertexNormals();const n=new THREE.Mesh(i,new THREE.MeshBasicMaterial({color:"white"}));this.el.setObject3D("mesh",n)},onObject3DSet(e){const t=this.data;if(e.target===t.src){const e=We(t.src.object3D);e&&this.generateHull(e)}}}),AFRAME.registerComponent("instance",{schema:{src:{type:"selector"},color:{type:"color",default:"#fff"},dynamic:{default:!1}},init(){this.instancePool=void 0,this.blockIndex=void 0,this.color=new THREE.Color},remove(){this.freeInstance()},update(e){const t=this.data;if(e.src!==t.src){const e=t.src.components["instance-pool"];e?(this.freeInstance(),this.blockIndex=e.reserveBlock(1),this.instancePool=e,void 0===this.blockIndex&&$("no more instances available")):$("no 'instance-pool' found on src")}else Q("missing 'src' on 'instance' component");e.dynamic!==t.dynamic&&t.dynamic&&this.el.sceneEl.addBehavior(this),e.color!==t.color&&this.color.set(t.color)},tick(){this.syncTransform(),this.data.dynamic||this.el.sceneEl.removeBehavior(this)},syncTransform(){const e=this.blockIndex;if(this.instancePool&&void 0!==e){let t=this.el.object3D.position;this.instancePool.setPositionAt(e,t.x,t.y,t.z),t=this.el.object3D.quaternion,this.instancePool.setQuaternionAt(e,t.x,t.y,t.z,t.w),t=this.el.object3D.scale,this.instancePool.setScaleAt(e,t.x,t.y,t.z);const i=this.color;this.instancePool.setColorAt(e,i.r,i.g,i.b)}},freeInstance(){this.instancePool&&void 0!==this.blockIndex&&this.instancePool.releaseBlock(this.blockIndex),this.instancePool=void 0,this.blockIndex=void 0}}),AFRAME.registerPrimitive("a-instance",{defaultComponents:{instance:{}},mappings:{src:"instance.src",color:"instance.color",dynamic:"instance.dynamic"}});AFRAME.registerComponent("instance-pool",{schema:{size:{default:1e3},patchShader:{default:!0}},init(){this.oldMesh=void 0,this.positions=void 0,this.colors=void 0,this.quaternions=void 0,this.scales=void 0,this.instancedGeoemtry=void 0,this.reservedCount=0,this.occupiedBlocks=[],this.freeBlocks=[],this.onSetObject3D=this.onSetObject3D.bind(this),this.onBeforeCompile=this.onBeforeCompile.bind(this),this.el.addEventListener("setobject3d",this.onSetObject3D)},remove(){this.el.removeEventListener("setobject3d",this.setobject3d),this.destroyInstances()},update(){this.createInstances()},onSetObject3D(e){e.target===this.el&&"mesh"===e.detail.type&&(this.destroyInstances(),this.createInstances())},createInstances(){const e=this.el.getObject3D("mesh");if(!e||!e.geometry||!e.material)return;this.oldMesh=e;const t=this.data,i=(new THREE.InstancedBufferGeometry).copy(e.geometry),n=t.size;i.maxInstancedCount=0;const a=this.positions&&this.positions.length===n?this.positions:new Float32Array(3*n),r=this.scales&&this.scales.length===n?this.scales:new Float32Array(3*n).fill(0),s=this.colors&&this.colors.length===n?this.colors:new Float32Array(4*n).fill(1),o=this.quaternions&&this.quaternions===n?this.quaternions:new Float32Array(4*n).map((e,t)=>(t-3)%4?0:1);this.instancePosition=new THREE.InstancedBufferAttribute(a,3),this.instanceQuaternion=new THREE.InstancedBufferAttribute(o,4),this.instanceScale=new THREE.InstancedBufferAttribute(r,3),this.instanceColor=new THREE.InstancedBufferAttribute(s,4),i.addAttribute("instancePosition",this.instancePosition),i.addAttribute("instanceQuaternion",this.instanceQuaternion),i.addAttribute("instanceScale",this.instanceScale),i.addAttribute("instanceColor",this.instanceColor);let l=e.material;t.patchShader&&(Array.isArray(e.material)?(l=e.material.map(e=>e.clone())).forEach(e=>e.onBeforeCompile=this.onBeforeCompile(e.onBeforeCompile)):(l=e.material.clone()).onBeforeCompile=this.onBeforeCompile(l.onBeforeCompile));const c=new THREE.Mesh(i,l);c.frustumCulled=!1,this.el.setObject3D("mesh",c),this.instancedGeoemtry=i,this.positions=a,this.quaternions=o,this.scales=r,this.colors=s,this.reservedCount=0,this.freeBlocks=[[0,n]],this.occupiedBlocks=[]},destroyInstances(){this.oldMesh&&(this.el.setObject3D("mesh",this.oldMesh),this.oldMesh=void 0),this.instancedGeoemtry=void 0,this.positions=void 0,this.quaternions=void 0,this.scales=void 0,this.colors=void 0,this.freeBlocks=[],this.occupiedBlocks=[]},onBeforeCompile(e){const t=e;return function(e){t&&t(e);let i=e.vertexShader,n=e.fragmentShader;i=(i=(i=(i=i.replace("void main()","\n      attribute vec3 instancePosition;\n      attribute vec4 instanceQuaternion;\n      attribute vec4 instanceColor;\n      attribute vec3 instanceScale;\n  \n      varying vec4 vInstanceColor;\n  \n      vec3 applyQuaternion( const vec3 v, const vec4 q ) \n      {\n        return v + 2. * cross( q.xyz, cross( q.xyz, v ) + q.w * v );\n      }\n  \n      void main()")).replace("#include <color_vertex>","\n      #include <color_vertex>\n      vInstanceColor = instanceColor;")).replace("#include <begin_vertex>","\n      vec3 transformed = applyQuaternion( position*instanceScale, instanceQuaternion ) + instancePosition;")).replace("#include <defaultnormal_vertex>","\n      vec3 transformedNormal = normalMatrix * applyQuaternion( objectNormal/instanceScale, -instanceQuaternion );\n      \n      #ifdef FLIP_SIDED\n        transformedNormal = - transformedNormal;\n      #endif\n  \n      #ifdef USE_TANGENT\n        vec3 transformedTangent = normalMatrix * applyQuaternion( objectTangent/instanceScale, -instanceQuaternion );\n        #ifdef FLIP_SIDED\n          transformedTangent = - transformedTangent;\n        #endif\n      #endif"),n=(n=n.replace("#include <color_pars_fragment>","\n      #include <color_pars_fragment>\n      varying vec4 vInstanceColor;")).replace("#include <color_fragment>","\n      #include <color_fragment>\n      diffuseColor *= vInstanceColor;"),e.vertexShader=i,e.fragmentShader=n}},reserveBlock(e){for(let t=this.freeBlocks.length-1;t>=0;t--){const i=this.freeBlocks[t],n=i[1]-e;if(n>=0){const t=[i[0],e];if(this.occupiedBlocks.push(t),this.instancedGeoemtry.maxInstancedCount=Math.max(this.instancedGeoemtry.maxInstancedCount,t[0]+t[1]),n>0)i[0]+=e,i[1]=n;else{const e=this.freeBlocks;this.freeBlocks.splice(e,1)}return t[0]}}},releaseBlock(e){for(let t=0;t<this.occupiedBlocks.length;t++){const i=this.occupiedBlocks[t];if(i[0]===e){for(let t=e;t<e+i[1];t++)this.setScaleAt(t,0,0,0);this.occupiedBlocks.splice(t,1),this.freeBlocks.push(i),this.repartionBlocks(i);const n=this.occupiedBlocks.reduce((e,t)=>Math.max(e,t[0]+t[1]),0);return this.instancedGeoemtry.maxInstancedCount=Math.max(this.instancedGeoemtry.maxInstancedCount,n),!0}}return!1},repartionBlocks(){for(let e=this.freeBlocks.length-1;e>=0;e--){const t=this.freeBlocks[e];for(let i=0;i<e;i++){const n=this.freeBlocks[i];if(n[0]==t[0]+t[1]){n[0]=t[0],n[1]+=t[1],this.freeBlocks.splice(e,1);break}if(n[0]+n[1]===t[0]){n[1]+=t[1],this.freeBlocks.splice(e,1);break}}}},setColorAt(e,t,i,n,a){const r=4*e;this.colors[r]=t,this.colors[r+1]=i,this.colors[r+2]=n,this.colors[r+3]=void 0!==a?a:1,this.instanceColor.needsUpdate=!0},setPositionAt(e,t,i,n){const a=3*e;this.positions[a]=t,this.positions[a+1]=i,this.positions[a+2]=n,this.instancePosition.needsUpdate=!0},setScaleAt(e,t,i,n){const a=3*e;this.scales[a]=t,this.scales[a+1]=void 0!==i?i:t,this.scales[a+2]=void 0!==n?n:t,this.instanceScale.needsUpdate=!0},setQuaternionAt(e,t,i,n,a){const r=4*e;this.quaternions[r]=t,this.quaternions[r+1]=i,this.quaternions[r+2]=n,this.quaternions[r+3]=a,this.instanceQuaternion.needsUpdate=!0},getPositionAt(e,t){const i=3*e;return t.x=this.positions[i],t.y=this.positions[i+1],t.z=this.positions[i+2],t},getColorAt(e,t){const i=4*e;return t.r=this.colors[i],t.g=this.colors[i+1],t.b=this.colors[i+2],t.a=this.colors[i+3],t},getScaleAt(e,t){const i=3*e;return t.x=this.scales[i],t.y=this.scales[i+1],t.z=this.scales[i+2],t},getQuaternionAt(e,t){const i=4*e;return t.x=this.quaternions[i],t.y=this.quaternions[i+1],t.z=this.quaternions[i+2],t.w=this.quaternions[i+3],t}});function Ge(e,t,i,n=de){const[a,r]=ce(t,i,n);switch(e){case"object":return le(t[a],t[a+1],r);case"number":return oe(t[a],t[a+1],r);default:return t[a]}}function Ye(e,t){const i=t.split(".");if(i.length<=2)return H(AFRAME.utils.entity.getComponentProperty(e,t));const n=B(e,i);if(n)return H(n[t]);$(`unknown path for getProperty() '${t}'`)}AFRAME.registerComponent("keyframe",{schema:{events:{default:""},delay:{default:0},duration:{default:1},direction:{default:"forward",oneOf:["forward","backward","alternate"]},loops:{default:-1},seed:{default:-1,type:"int"},easing:{default:"linear",oneOf:Object.keys(xe)},randomizeEachLoop:{default:!0},enabled:{default:!0},debug:{default:!1},bubbles:{default:!1}},multiple:!0,init(){this.startKeyframes=this.startKeyframes.bind(this),this.lcg=p(),this.loopTime=0,this.loops=0,this.keys={},this.rules={},this.isStarted=!1,this.eventListener=G(this.el,this.onEvent.bind(this)),this.delayClock=q()},remove(){this.eventListener.remove(),this.delayClock.clearAllTimers()},play(){this.eventListener.add(),this.delayClock.resume()},pause(){this.eventListener.remove(),this.delayClock.pause()},updateSchema(e){"object"!=typeof e&&console.error(`invalid properties, expected format <property>:<value>; '${e}'`);const t=AFRAME.components[this.name].schema;let i={};for(let n in e)n in t||(i[n]={type:"string"});Object.keys(i).length>0&&this.extendSchema(i)},update(e){const t=this.data,i=AFRAME.components[this.name].schema;e.seed!==t.seed&&this.lcg.setSeed(t.seed);for(let e in this.rules)e in t||(delete this.rules[e],delete this.keys[e]);for(let n in t)if(e[n]!==t[n]&&!(n in i)){const e=t[n];this.rules[n]=e.split(",").map(e=>A(e))}if(e.duration===t.duration&&e.loops===t.loops||(this.loopTime=0,this.loops=0),e.direction!==t.direction&&(this.forward="backward"!==t.direction,this.loopTime=this.forward?0:t.duration),this.generateKeys(!0),this.isComplete()?this.el.sceneEl.removeBehavior(this):this.el.sceneEl.addBehavior(this),t.duration<=0)for(let e in this.keys)U(this.el,e,this.keys[e][0]);t.events!==e.events&&this.eventListener.set(t.events),t.events||t.delay===e.delay||this.delayClock.startTimer(t.delay,this.startKeyframes)},tick(e,t){if(this.data.enabled){const e=Math.min(t,100)/1e3;this.step(e)}},step(e){const t=this.data,i=this.isComplete();if(!i&&this.isStarted){let i=!1;this.loopTime=this.loopTime+(this.forward?e:-e),(this.loopTime>t.duration||this.loopTime<0)&&(this.loops++,i=!0),i&&(t.loops<0||this.loops<t.loops)&&("alternate"===t.direction?(this.forward=!this.forward,this.loopTime=this.loopTime<0?-this.loopTime:2*t.duration-this.loopTime):this.loopTime=this.loopTime+(this.forward?-t.duration:t.duration),t.randomizeEachLoop&&this.generateKeys(!1));const n=xe[t.easing]||xe.linear;for(let e in this.keys){let i=THREE.Math.clamp(this.loopTime/t.duration,0,1);const a=Ge(this.keyTypes[e],this.keys[e],i,n);U(this.el,e,a)}}else this.el.sceneEl.removeBehavior(this);this.isStarted&&i&&(this.sendEvent("keyframeend",{name:this.attrName}),this.isStarted=!1)},startKeyframes(){this.isStarted||(this.isStarted=!0,this.el.sceneEl.addBehavior(this),this.sendEvent("keyframestart",{name:this.attrName}))},isComplete(){const e=this.data;return e.duration<=0||e.loops>0&&this.loops>e.loops},generateKeys(e){let t;this.keys={},this.keyTypes={};for(let i in this.rules){this.keys[i]=[];for(let n=0,a=this.rules[i].length;n<a;n++){const r=this.forward?n:a-1-n,s=this.rules[i][r];if(e){const e=s.range&&s.range.includes(""),a=s.options&&s.options.includes("");if(e||a){let r=0==n?R(Ye(this.el,i)):t;e&&(s.range=s.range.map(e=>""===e?r:e)),a&&(s.options=s.options.map(e=>""===e?r:e))}}t=k(s,this.lcg.random),this.keys[i][r]=t,this.keyTypes[i]=this.keyTypes[i]||typeof t}}},sendEvent(e,t){this.data.debug&&console.log(z(this.el),this.attrName,"send",e,t,this.data.bubbles),this.el.emit(e,t,this.data.bubbles)},onEvent(e){this.data.debug&&console.log(z(this.el),this.attrName,"onEvent",e.type),this.delayClock.startTimer(this.data.delay,this.startKeyframes)}});const $e=THREE.Math.degToRad;AFRAME.registerComponent("lathe",{schema:{shape:{default:""},steps:{type:"int",default:1},segments:{type:"int",default:12},phiStart:{default:0},phiEnd:{default:360}},update(){const e=this.data,t=je(e.shape).extractPoints(e.steps).shape,i=new THREE.LatheBufferGeometry(t,e.segments,$e(e.phiStart),$e(e.phiEnd)),n=new THREE.Mesh(i,new THREE.MeshBasicMaterial);this.el.setObject3D("mesh",n)}});const Qe={error:"red",warn:"yellow",log:"white",info:"grey"};function Xe(e){if(0===e.length)return"";let t=1;return e[0].toString().replace(/%(\.(\d+))?([cdfios])/g,(i,n,a,r)=>{let s;switch(r){case"c":return t++,"";case"d":case"i":return s=parseInt(e[t++],10),a?s.toString().padStart(a,"0"):s;case"f":return s=parseFloat(e[t++]),a?s.toFixed(a):s;case"o":return"[object]";case"s":return e[t++]}})+(t<e.length?" "+e.slice(t).join(" "):"")}AFRAME.registerSystem("logger",{init(){this.loggers=[],this.isLogging=!1},remove(){this.releaseLogs(),console.assert(0===this.loggers.length)},captureLogs(){this.oldLog=console.log,this.oldError=console.error,this.oldWarn=console.warn,this.oldInfo=console.info,console.log=((...e)=>{this.sendToLogger("log",Xe(e)),this.oldLog(...e)}),console.error=((...e)=>{this.sendToLogger("error",Xe(e)),this.oldError(...e)}),console.warn=((...e)=>{this.sendToLogger("warn",Xe(e)),this.oldWarn(...e)}),console.info=((...e)=>{this.sendToLogger("info",Xe(e)),this.oldInfo(...e)})},releaseLogs(){console.log=this.oldLog,console.error=this.oldError,console.warn=this.oldWarn,console.info=this.oldInfo},sendToLogger(e,t){if(!this.isLogging){this.isLogging=!0;for(let i of this.loggers)i.showMessage(e,t);this.isLogging=!1}},registerLogger(e){this.loggers.push(e),1===this.loggers.length&&this.captureLogs()},unregisterLogger(e){this.loggers.splice(this.loggers.indexOf(e),1),0===this.loggers.length&&this.releaseLogs()}}),AFRAME.registerComponent("logger",{schema:{maxLines:{default:20},offset:{type:"vec2",default:{x:2,y:2}},lineHeight:{default:12},columnWidth:{default:80},characterWidth:{default:7.3},types:{type:"array",default:["log","error","warn"]},filter:{default:""},font:{default:"1em monospace"}},init(){this.dirty=!0,this.messages=[],this.onSetObject3D=this.onSetObject3D.bind(this),this.system.registerLogger(this),this.createTexture(),this.el.addEventListener("setobject3d",this.onSetObject3D)},remove(){this.el.removeEventListener("setobject3d",this.onSetObject3D),this.system.unregisterLogger(this)},update(e){const t=this.data;e.filter!==t.filter&&(this.filter=t.filter?new RegExp(t.filter):void 0)},tick(){this.dirty&&this.imageEl.isReady&&this.updateTexture()},createTexture(){this.imageEl=document.createElement("img"),this.imageEl.width=512,this.imageEl.height=512,this.imageEl.isReady=!0;const e=this.texture=new THREE.Texture(this.imageEl);this.imageEl.onload=(()=>{e.needsUpdate=!0}),this.imageEl.onerror=(()=>{e.image.isReady=!0}),e.onUpdate=(()=>{e.image.isReady=!0}),this.showTexture()},updateTexture(){const e=this.imageEl,t=this.data,i=t.columnWidth*t.characterWidth,n=(t.maxLines+1)*t.lineHeight;const a="data:image/svg+xml;utf8,"+function(e){return e.replace(/%/g,"%25").replace(/#/g,"%23")}(`<svg viewBox="0 0 ${i} ${n}" preserveAspectRatio="none" xmlns="http://www.w3.org/2000/svg" version="1.1">\n      <rect x="0" y="0" width="${i}" height="${n}" fill="#111"/>\n      <style> text { font: ${t.font}; }></style>\n      ${this.messages.map((e,i)=>{const n=t.offset.y+t.lineHeight*(i+1),a=t.offset.x,r=e[1].replace(/[^\x20-\x7E\n\t]/g,"").replace(/[&<>'"]/g,e=>"&"===e?"&amp;":"<"===e?"&lt;":">"===e?"&gt;":"'"===e?"&apos;":"&quot;");return`<text x="${a}" y="${n}" fill="${Qe[e[0]]}">${r}</text>`}).join("\n")}\n    </svg>`);e.src=a,e.isReady=!1,this.dirty=!1},showTexture(){const e=this.el.getObject3D("mesh");e&&e.material&&(e.material.map=this.texture)},showMessage(e,t){const i=this.data;if(!i.types.includes(e))return;if(this.filter&&!this.filter.test(t))return;const n=t.split("\n");for(let t of n)for(let n=0,a=t.length;n<a;n+=i.columnWidth)this.messages.push([e,t.slice(n,Math.min(a,n+i.columnWidth))]);for(;this.messages.length>=this.data.maxLines;)this.messages.shift();this.dirty=!0},onSetObject3D(e){this.showTexture()}}),AFRAME.registerPrimitive("a-logger",{defaultComponents:{geometry:{primitive:"plane",height:3,width:3},material:{color:"white",shader:"flat",side:"double"},logger:{}},mappings:{types:"logger.types",filter:"logger.filter"}}),function(){var e=AFRAME.utils.debug("components:materialx:error"),t=AFRAME.shaders;function i(e,t){e.dispose(),t.unregisterMaterial(e)}function n(e,t,i,n){var a=!1;if(n.length=0,0===i.length)return!0;if(""===t){(r=e.getObject3D("mesh"))&&r.material&&(n.push(r.material),r.material=i[0],a=!0)}else{var r=e.object3D,s=t.replace(/[\.\{\}\(\)\^\[\]\$]/g,"\\$&").replace(/[\*\?]/g,".$&"),o=new RegExp("^"+s+"$"),l=0;r&&r.traverse(function(e){if(e&&e.material)if(a=!0,Array.isArray(e.material))for(var t=0,r=e.material.length;t<r;t++)o.test(e.material[t].name)&&(n.push(e.material[t]),e.material[t]=i[l],l=(l+1)%i.length);else o.test(e.material.name)&&(n.push(e.material),e.material=i[l],l=(l+1)%i.length)})}return a}AFRAME.registerComponent("materialx",{schema:{alphaTest:{default:0,min:0,max:1},depthTest:{default:!0},depthWrite:{default:!0},flatShading:{default:!1},name:{default:""},npot:{default:!1},offset:{type:"vec2",default:{x:0,y:0}},opacity:{default:1,min:0,max:1},remap:{default:""},repeat:{type:"vec2",default:{x:1,y:1}},shader:{default:"standard",oneOf:Object.keys(AFRAME.shaders),schemaChange:!0},side:{default:"front",oneOf:["front","back","double"]},transparent:{default:!1},vertexColors:{type:"string",default:"none",oneOf:["none","face","vertex"]},visible:{default:!0},blending:{default:"normal",oneOf:["none","normal","additive","subtractive","multiply"]}},multiple:!0,init:function(){this.system=this.el.sceneEl.systems.material,this.material=null,this.oldMaterials=[],this.onObject3DSet=this.onObject3DSet.bind(this),this.el.addEventListener("object3dset",this.onObject3DSet)},update:function(e){var t=this.data;this.shader&&t.shader===e.shader||(n(this.el,e.remap,this.oldMaterials,[]),this.updateShader(t.shader)),this.shader.update(this.data),this.updateMaterial(e)},updateSchema:function(i){var n,a,r,s;"string"==typeof i&&e(`invalid properties, expected format <property>:<value>; '${i}'`),a=i&&i.shader,n=this.oldData&&this.oldData.shader,(r=t[s=a||n]&&t[s].schema)||e("Unknown shader schema "+s),n&&a===n||(this.extendSchema(r),this.updateBehavior())},updateBehavior:function(){var e,t,i=this.el.sceneEl,n=this.schema,a=this;function r(e,i){var n;for(n in t)t[n]=e;a.shader.update(t)}for(e in this.tick=void 0,t={},n)"time"===n[e].type&&(this.tick=r,t[e]=!0);i&&(this.tick?i.addBehavior(this):i.removeBehavior(this))},updateShader:function(e){var i,n=this.data,a=t[e]&&t[e].Shader;if(!a)throw new Error("Unknown shader "+e);(i=this.shader=new a).el=this.el,i.init(n),this.setMaterial(i.material),this.updateSchema(n)},updateMaterial:function(e){var t,i=this.data,n=this.material;for(t in n.alphaTest=i.alphaTest,n.depthTest=!1!==i.depthTest,n.depthWrite=!1!==i.depthWrite,n.name=i.name,n.opacity=i.opacity,n.flatShading=i.flatShading,n.side=function(e){switch(e){case"back":return THREE.BackSide;case"double":return THREE.DoubleSide;default:return THREE.FrontSide}}(i.side),n.transparent=!1!==i.transparent||i.opacity<1,n.vertexColors=function(e){switch(e){case"face":return THREE.FaceColors;case"vertex":return THREE.VertexColors;default:return THREE.NoColors}}(i.vertexColors),n.visible=i.visible,n.blending=function(e){switch(e){case"none":return THREE.NoBlending;case"additive":return THREE.AdditiveBlending;case"subtractive":return THREE.SubtractiveBlending;case"multiply":return THREE.MultiplyBlending;default:return THREE.NormalBlending}}(i.blending),e)break;!t||e.alphaTest===i.alphaTest&&e.side===i.side&&e.vertexColors===i.vertexColors||(n.needsUpdate=!0)},remove:function(){this.el.removeEventListener("object3dset",this.onObject3DSet);var e=this.material;n(this.el,this.data.remap,this.oldMaterials,[]),this.oldMaterials.length=0,i(e,this.system)},setMaterial:function(e){var t=this.el,a=this.system;this.material&&i(this.material,a),this.material=e,a.registerMaterial(e),n(t,this.data.remap,[e],this.oldMaterials)},onObject3DSet(e){"mesh"===e.detail.type&&e.target===this.el&&n(this.el,this.data.remap,[this.material],this.oldMaterials)}})}(),AFRAME.registerComponent("merge-geometry",{dependencies:["material"],schema:{keepColor:{default:!0},keepOriginal:{default:!1}},init(){this.mergeGeometry()},mergeGeometry(){const e=this,t=new THREE.Geometry,i=new THREE.Matrix4,n=this.el.object3D;n.updateMatrixWorld(!0),i.getInverse(n.matrixWorld),n.traverse(function(n){if("Mesh"!==n.type)return;const a=n.geometry.isBufferGeometry?(new THREE.Geometry).fromBufferGeometry(n.geometry):n.geometry;if(e.data.keepColor){const e=Array.isArray(n.material)?n.material[0].color:n.material.color;a.faces.forEach(t=>{3===t.vertexColors.length?(t.vertexColors[0].multiply(e),t.vertexColors[1].multiply(e),t.vertexColors[2].multiply(e)):t.color.multiply(e)})}const r=n.matrixWorld.clone().premultiply(i);t.merge(a,r),e.data.keepOriginal||n.parent.remove(n)});const a=new THREE.Mesh((new THREE.BufferGeometry).fromGeometry(t));if(this.el.setObject3D("mesh",a),e.data.keepColor){this.el.getObject3D("mesh").material.vertexColors=THREE.VertexColors}}});const Ze=2*Math.PI,Ke=.5*Math.PI,Je=new THREE.Vector3(0,1,0),et=THREE.Math.degToRad;function tt(e){return{x:et(e.x),y:et(e.y),z:et(e.z)}}function it(e){return e.options?Math.max(...e.options):Math.max(...e.range)}function nt(e){return"number"==typeof e}function at(e){return"object"==typeof e&&"x"in e&&"y"in e&&"z"in e}function rt(e){return"object"==typeof e&&"r"in e&&"g"in e&&"b"in e}function st(e,t){return e.range?e.range.every(t):!!e.options&&e.options.every(t)}function ot(e){if(!e)return;const t=j(e).flatMap(e=>A(e));if(t.every(e=>st(e,at)))return t;$(`unrecognized array of vec3 range options '${e}'`)}function lt(e){if(!e)return;const t=j(e).flatMap(e=>A(e));if(t.every(e=>st(e,nt)))return t;$(`unrecognized array of float range options '${e}'`)}function ct(e){return"number"==typeof e?{x:e,y:e,z:e}:e}const dt={position:ot,velocity:ot,acceleration:ot,radialPosition:lt,radialVelocity:lt,radialAcceleration:lt,angularVelocity:ot,angularAcceleration:ot,orbitalVelocity:lt,orbitalAcceleration:lt,scale:function(e){if(!e)return;const t=j(e).flatMap(e=>A(e));if(t.every(e=>st(e,at)||st(e,nt)))return t.map(e=>e.range?{range:e.range.map(ct)}:e.options?{options:e.options.map(ct)}:void 0);$(`unrecognized array of float or vec3 range options '${e}'`)},color:function(e){if(!e)return;const t=j(e.toLowerCase()).flatMap(e=>A(e));if(t.every(e=>st(e,rt)))return t;$(`unrecognized array of color range options '${e}'`)},rotation:ot,opacity:lt};AFRAME.registerComponent("mesh-particles",{schema:{events:{default:""},delay:{default:0},enabled:{default:!0},duration:{default:-1},instancePools:{default:""},spawnRate:{default:"1"},lifeTime:{default:"1"},position:{default:""},velocity:{default:""},acceleration:{default:""},radialType:{default:"circle",oneOf:["circle","sphere","circlexy","circleyz","circlexz"],parse:e=>e.toLowerCase()},radialPosition:{default:""},radialVelocity:{default:""},radialAcceleration:{default:""},angularVelocity:{default:""},angularAcceleration:{default:""},orbitalVelocity:{default:""},orbitalAcceleration:{default:""},scale:{default:""},color:{default:""},rotation:{default:""},opacity:{default:""},source:{type:"string"},destination:{type:"string"},destinationOffset:{type:"vec3"},destinationWeight:{type:"number"},seed:{type:"int",default:-1}},multiple:!0,init(){this.startParticles=this.startParticles.bind(this),this.onEvent=this.onEvent.bind(this),this.isStarted=!1,this.hasListeners=!1,this.spawnID=0,this.spawnCount=0,this.instancePools=[],this.instanceIndices=[],this.particles=[],this.customData={},this.lcg=p(),this.delayClock=q(),this.eventListener=G(this.el,this.onEvent)},remove(){this.releaseInstances(),this.eventListener.remove(),this.delayClock.clearAllTimers(),this.source=void 0,this.destination=void 0},play(){this.eventListener.add(),this.delayClock.resume()},pause(){this.eventListener.remove(),this.delayClock.pause()},update(e){const t=this.data;this.lcg.setSeed(t.seed),this.duration=t.duration;for(let i in t)e[i]!==t[i]&&i in dt&&(this.customData[i]=dt[i](t[i]));if(t.lifeTime!==e.lifeTime&&(this.lifeTimeRule=A(t.lifeTime),this.maxLifeTime=it(this.lifeTimeRule),this.particles=[]),t.source!==e.source&&(this.source=this.el.object3D,t.source)){const e=document.querySelector(t.source);e&&e.object3D?this.source=e.object3D:$(`unable to find object3D on source '${t.source}'`)}if(t.destination!==e.destination&&(this.destination=void 0,t.destination)){const e=document.querySelector(t.destination);e&&e.object3D?this.destination=e.object3D:$(`unable to find object3D on destination '${t.destination}'`)}t.spawnRate===e.spawnRate&&t.lifeTime===e.lifeTime||(this.spawnRateRule=A(t.spawnRate),this.maxParticles=it(this.spawnRateRule)*this.maxLifeTime,this.spawnRate=k(this.spawnRateRule,this.lcg.random)),t.instancePools===e.instancePools&&t.spawnRate===e.spawnRate&&t.lifeTime===e.lifeTime||(this.spawnID=0,this.releaseInstances(),this.instancePools=t.instancePools?[].slice.call(document.querySelectorAll(t.instancePools)).map(e=>e.components?e.components["instance-pool"]:void 0).filter(e=>e):this.el.components["instance-pool"]?[this.el.components["instance-pool"]]:[],0===this.instancePools.length?t.instancePools?$(`no 'instance-pool' on the entities: '${t.instancePools}'`):$("no 'instance-pool' component on this element"):(this.instanceIndices=this.instancePools.map(e=>e.reserveBlock(Math.ceil(this.maxParticles/this.instancePools.length))),this.instanceIndices.forEach((e,t)=>{void 0===e&&$(`unable to reserve blocks for instance '${this.instancePools[t].el.id}'`)}))),t.events!==e.events&&(this.eventListener.set(t.events),t.events||(this.startTime=t.delay,this.startParticles()))},tick(e,t){const i=.001*e,n=Math.min(.1,.001*t),a=this.duration<0||i-this.startTime<this.duration;if(this.isStarted&&a&&this.instancePools.length>0&&this.data.enabled)for(this.spawnCount+=this.spawnRate*n,this.spawnCount>1&&(this.spawnRate=k(this.spawnRateRule,this.lcg.random));this.spawnCount>1;)this.spawn(),this.spawnCount--;else this.isStarted&&!a&&this.stopParticles();this.move(n)},onEvent(e){this.delayClock.startTimer(this.delay,this.startParticles)},startParticles(){this.isStarted=!0,this.startTime=this.el.sceneEl.clock.elapsedTime},stopParticles(){this.isStarted=!1},releaseInstances(){this.instancePools.forEach((e,t)=>e.releaseBlock(this.instanceIndices[t])),this.instanceIndices.length=0,this.particles=[],this.spawnID=0,this.spawnCount=0},configureRandomizer(e){this.data.seed>0&&(this.lcg.setSeed(e+1),this.lcg.setSeed(this.data.seed+12783891*this.lcg.random()))},instanceFromID(e){const t=e%this.maxParticles,i=e%this.instancePools.length,n=this.instancePools[i];return void 0===this.instanceIndices[i]?[void 0,void 0,void 0]:[n,this.instanceIndices[i]+Math.floor(t/this.instancePools.length),t]},spawn(){const e=this.data,t=this.customData,i=this.lcg.random;this.configureRandomizer(this.spawnID);const n={age:0};n.col=new THREE.Color,n.col.a=1,n.pos=new THREE.Vector3(0,0,0),n.vel=new THREE.Vector3(0,0,0),n.acc=new THREE.Vector3(0,0,0),n.angularVel=new THREE.Vector3(0,0,0),n.angularAcc=new THREE.Vector3(0,0,0),n.orbitalVel=0,n.orbitalAcc=0,this.source&&(n.sourcePosition=new THREE.Vector3,n.sourceQuaternion=new THREE.Quaternion,n.sourceScale=new THREE.Vector3,this.source.matrixWorld.decompose(n.sourcePosition,n.sourceQuaternion,n.sourceScale)),n.lifeTime=k(this.lifeTimeRule,i),n.radialPhi="circlexz"!==e.radialType?2*Math.acos(2*i()-1):Ke,n.radialTheta="circleyz"===e.radialType?0:"circle"===e.radialType||"circlexy"===e.radialType?Ke:i()*Ze,t.position&&(n.positions=t.position.map(e=>k(e,i))),t.rotation&&(n.rotations=t.rotation.map(e=>tt(k(e,i)))),t.scale&&(n.scales=t.scale.map(e=>k(e,i))),t.color&&(n.colors=t.color.map(e=>k(e,i))),t.opacity&&(n.opacities=t.opacity.map(e=>k(e,i))),t.velocity&&(n.velocities=t.velocity.map(e=>k(e,i))),t.acceleration&&(n.accelerations=t.acceleration.map(e=>k(e,i))),t.radialPosition&&(n.radialPositions=t.radialPosition.map(e=>k(e,i))),t.radialVelocity&&(n.radialVelocities=t.radialVelocity.map(e=>k(e,i))),t.radialAcceleration&&(n.radialAccelerations=t.radialAcceleration.map(e=>k(e,i))),t.angularVelocity&&(n.angularVelocities=t.angularVelocity.map(e=>tt(k(e,i)))),t.angularAcceleration&&(n.angularAccelerations=t.angularAcceleration.map(e=>tt(k(e,i)))),t.orbitalVelocity&&(n.orbitalVelocities=t.orbitalVelocity.map(e=>et(k(e,i)))),t.orbitalAcceleration&&(n.orbitalAccelerations=t.orbitalAcceleration.map(e=>et(k(e,i)))),n.orbitalAxis=new THREE.Vector3;const a=this.spawnID%this.maxParticles;this.particles[a]=n,this.spawnID++},move:function(){const e=new THREE.Vector3(0,0,0),t=new THREE.Euler(0,0,0,"YXZ"),i=new THREE.Quaternion(0,0,0,1),n=new THREE.Vector3(1,1,1),a=new THREE.Color(0,0,0),r=new THREE.Vector3(0,0,0);return function(s){const o=this.data;for(let l=Math.max(0,this.spawnID-this.maxParticles);l<this.spawnID;l++){const[c,d,h]=this.instanceFromID(l);if(void 0===c)continue;const u=this.particles[h],m=u.age/u.lifeTime,f=0===m;let p=!1,g=!1;if(m>1){c.setScaleAt(d,{x:0,y:0,z:0});continue}const v=u.age;if(u.age+=s,u.positions&&(f||u.positions.length>1)&&u.pos.copy(this.lerpVector(u.positions,m)),u.radialPositions&&(f||u.radialPositions.length>1)&&u.pos.setFromSphericalCoords(this.lerpFloat(u.radialPositions,m),u.radialPhi,u.radialTheta),u.accelerations&&(f||u.accelerations.length>1)&&u.acc.copy(this.lerpVector(u.accelerations,m)),u.radialAccelerations&&(f||u.radialAccelerations.length>1)&&u.acc.setFromSphericalCoords(this.lerpFloat(u.radialAccelerations,m),u.radialPhi,u.radialTheta),u.velocities&&(f||u.velocities.length>1)&&u.vel.copy(this.lerpVector(u.velocities,m)),u.radialVelocities&&(f||u.radialVelocities.length>1)&&u.vel.setFromSphericalCoords(this.lerpFloat(u.radialVelocities,m),u.radialPhi,u.radialTheta),u.accelerations||u.radialAccelerations||u.velocities||u.radialVelocities?(e.copy(u.acc).multiplyScalar(.5*v).add(u.vel).multiplyScalar(v).add(u.pos),p=!0):u.positions||u.radialPositions?e.copy(u.pos):e.set(0,0,0),u.orbitalAccelerations&&(f||u.orbitalAccelerations.length>1)&&(u.orbitalAcc=this.lerpFloat(u.orbitalAccelerations,m)),u.orbitalVelocities&&(f||u.orbitalVelocities.length>1)&&(u.orbitalVel=this.lerpFloat(u.orbitalVelocities,m)),u.orbitalAccelerations||u.orbitalVelocities){f&&u.orbitalAxis.copy(r.copy(u.pos).normalize().cross(Je).normalize());const t=(u.orbitalVel+.5*v*u.orbitalAcc)*v;i.setFromAxisAngle(u.orbitalAxis,t),e.applyQuaternion(i),p=!0}u.angularAccelerations&&(f||u.angularAccelerations.length>1)&&u.angularAcc.copy(this.lerpVector(u.angularAccelerations,m)),u.angularVelocities&&(f||u.angularVelocities.length>1)&&u.angularVel.copy(this.lerpVector(u.angularVelocities,m)),(u.angularAccelerations||u.angularVelocities)&&(r.copy(u.angularAcc).multiplyScalar(.5*v).add(u.angularVel).multiplyScalar(v),t.set(r.x,r.y,r.z,"YXZ"),i.setFromEuler(t),e.applyQuaternion(i),p=!0),(f||p||this.destination)&&(e.add(u.sourcePosition),this.destination&&(r.copy(o.destinationOffset).applyMatrix4(this.destination.matrixWorld),e.copy(le(e,r,o.destinationWeight*m))),c.setPositionAt(d,e.x,e.y,e.z)),u.opacities&&(f||u.opacities.length>1)&&(u.col.a=this.lerpFloat(u.opacities,m),g=!0),u.colors&&(f||u.colors.length>1)&&(a.copy(this.lerpVector(u.colors,m)),u.col.setRGB(a.r,a.g,a.b),g=!0),(f||g)&&c.setColorAt(d,u.col.r,u.col.g,u.col.b,u.col.a),u.rotations&&(f||u.rotations.length>1)&&(u.rotations.length>0?(t.setFromVector3(this.lerpVector(u.rotations,m)),i.setFromEuler(t),i.premultiply(u.sourceQuaternion)):i.copy(u.sourceQuaternion),c.setQuaternionAt(d,i.x,i.y,i.z,i.w)),u.scales&&(f||u.scales.length>1)&&(n.copy(u.sourceScale),u.scales.length>0&&n.multiply(r.copy(this.lerpVector(u.scales,m))),c.setScaleAt(d,n.x,n.y,n.z)),!u.scales&&f&&c.setScaleAt(d,1,1,1)}}}(),lerpFloat(e,t){const[i,n]=ce(e,t);return oe(e[i],e[i+1],n)},lerpVector(e,t){const[i,n]=ce(e,t);return le(e[i],e[i+1],n)}}),AFRAME.registerSystem("procedural-texture",{init(){this.renderer=void 0,this.proceduralTextureComponents=[]},registerComponent(e){this.proceduralTextureComponents.push(e),this.renderer||this.createRenderer()},unregisterComponent(e){const t=this.proceduralTextureComponents.indexOf(e);-1!==t&&this.proceduralTextureComponents.slice(t,1)},updateProceduralTexturesUsingThisCanvas(e,t){for(let i of this.proceduralTextureComponents)t!==i&&Object.keys(i.uniforms).some(t=>{const n=i.uniforms[t];return"texture"===n.type&&(Array.isArray(n.value)?n.value.any(t=>t.image===e):n.value.image===e)})&&i.update(i.data)},createRenderer(){this.renderer=new THREE.WebGLRenderer({alpha:!0,premultipliedAlpha:!1}),this.renderer.setPixelRatio(window.devicePixelRatio),this.renderer.autoClear=!0,this.renderer.setClearColor(new THREE.Color("purple"),1)}}),AFRAME.registerComponent("procedural-texture",{dependencies:["geometry"],schema:{shader:{type:"string"},canvas:{type:"selector"}},multiple:!0,init(){this.canvas=void 0,this.system.registerComponent(this)},remove(){this.system.unregisterComponent(this)},updateSchema(e){var t=!1;"object"!=typeof e&&console.error(`invalid properties, expected format <property>:<value>; '${e}'`),this.data&&this.data.shader===e.shader||(this.shaderProgram="",this.uniforms={},e.shader&&Y(e.shader,"main(",e=>{this.shaderProgram=e,this.uniforms=this.parseShaderUniforms(this.shaderProgram),t&&this.updateProceduralTexture()}));let i=this.uniformsToSchema(this.uniforms);e.canvas||(i.width={type:"int",value:256},i.height={type:"int",value:256}),Object.keys(i).length>0&&this.extendSchema(i),t=!0},update(e){const t=this.data;if(t.canvas!==e.canvas&&(this.canvas=t.canvas&&t.canvas instanceof HTMLCanvasElement?t.canvas:void 0),!t.canvas&&!this.canvas){this.canvas=document.createElement("canvas"),this.canvas.width=t.width||256,this.canvas.height=t.height||256;const e=this.el.getObject3D("mesh");e&&e.material&&(e.material.map=new THREE.CanvasTexture(this.canvas))}this.canvas&&this.shaderProgram&&this.updateProceduralTexture(),this.usesComponentTime()&&this.el.sceneEl.addBehavior(this)},updateProceduralTexture(){this.scene||this.setupScene(this.canvas,this.shaderProgram),this.updateUniforms(this.uniforms,this.data),this.renderScene(),Ie(this.el.sceneEl.object3D,this.canvas),this.system.updateProceduralTexturesUsingThisCanvas(this.canvas),this.canvas.dispatchEvent(new CustomEvent("loaded",{bubbles:!1}))},usesComponentTime(){return"time"in this.uniforms&&!("time"in this.attrValue)},tick(e){this.usesComponentTime()?(this.uniforms.time.value=.001*e,this.renderScene()):this.el.sceneEl.removeBehavior(this)},setupScene(e,t){this.scene=new THREE.Scene,this.camera=new THREE.Camera,this.camera.position.z=1,this.uniforms=this.parseShaderUniforms(t);const i=t.replace(/#include\s*<procedural-ext>/,ut);var n=new THREE.RawShaderMaterial({uniforms:this.uniforms,vertexShader:ht,fragmentShader:i});const a=new THREE.Mesh(new THREE.PlaneBufferGeometry(2,2),n);this.scene.add(a),this.ctx=e.getContext("2d")},renderScene(){const e=this.ctx.canvas,t=e.width,i=e.height,n=this.system.renderer;n.setSize(t,i),n.render(this.scene,this.camera),this.ctx.clearRect(0,0,t,i),this.ctx.drawImage(this.system.renderer.domElement,0,0)},parseShaderUniforms(e){const t=/uniform (vec2|vec3|vec4|float|int|uint|bool|sampler2D) ([a-zA-Z0-9_]+)(\[(\d+)\])?;/;let i={};return e.split("\n").forEach(e=>{const n=t.exec(e);if(n){const e=n[1],t=n[2],a=void 0!==n[4]?parseInt(n[4],10):0;if(t){const n=i[t]||this.allocateUniform(e,a);i[t]=n}}}),i},uniformsToSchema(e){let t=[];for(let i in e){const n=e[i];switch(n.type){case"texture":t[i]={type:"string"};break;case"float32array":case"int32array":t[i]={type:"string"};break;default:t[i]={type:n.count>1?"string":n.type}}}return t},updateUniforms:function(){let e=new Array(4);const t=e=>Number(e),i=e=>!isNaN(e);function n(n,a,r,s){switch(n){case"texture":const c=s.sceneEl.systems.material,d=document.querySelector(a),h=d||a;c.loadTexture(h,{src:h},e=>{r(e)});break;case"number":r(parseFloat(a));break;case"boolean":r(!!a);break;case"float32array":case"int32array":let u=a.split(" ").map(t).filter(i);if(0==u.length){let t=x(a);t&&(e.fill(1),l=t,(o=e)[0]=l.r,o[1]=l.g,o[2]=l.b,void 0!==l.a&&(o[3]=l.a),u=o)}u.length>0&&r(u)}var o,l}return function(e,t){for(let i in e){const a=t[i],r=e[i];if(void 0===a)$(`no attribute for uniform: ${i}`);else{const e=("string"==typeof a?j(a):[a.toString()]).map(e=>e.trim());if(r.arrayCount>0)for(let t=0;t<e.length;t++){const i=e[t];switch(r.type){case"texture":n(r.type,i,e=>r.value[t]=e,this.el);break;case"number":case"boolean":n(r.type,i,e=>r.value[t]=e,this.el);break;case"float32array":case"in32array":n(r.type,i,e=>r.value.set(e.slice(0,r.size),t*r.size))}}else switch(r.type){case"texture":case"number":case"boolean":n(r.type,e[0],e=>r.value=e,this.el);break;case"float32array":case"in32array":n(r.type,e[0],e=>r.value.set(e.slice(0,r.size)))}}}}}(),allocateUniform(e,t){const i=Math.max(1,t);switch(e){case"sampler2D":return{type:"texture",value:t>0?new Array(t).fill(void 0):void 0,arrayCount:t};case"float":case"int":return{type:"number",value:t>0?new Array(t).fill(0):0,arrayCount:t};case"bool":return{type:"boolean",value:t>0&&new Array(t).fill(!1),arrayCount:t};case"ivec2":case"bvec2":case"vec2":return{type:"float32array",value:new Float32Array(2*i),size:2,arrayCount:t};case"vec3":return{type:"float32array",value:new Float32Array(3*i),size:3,arrayCount:t};case"vec4":return{type:"float32array",value:new Float32Array(4*i),size:4,arrayCount:t};case"ivec3":case"bvec3":return{type:"int32array",value:new Int32Array(3*i),size:3,arrayCount:t};case"ivec4":case"bvec4":return{type:"int32array",value:new Int32Array(4*i),size:4,arrayCount:t};default:$(`unknown uniform type ${e}`)}}});const ht="\nprecision highp float;\n\nattribute vec3 position;\nattribute vec2 uv;\n\nvarying vec2 vUv;\nvoid main()\n{\n  vUv = uv;\n  gl_Position = vec4( position, 1.0 );\n}",ut="\nprecision highp float;\nprecision highp int;\n\n// FLOAT -> FLOAT\n// could use levels low, high, mid, black, white (mid maps to (black + white)/2)\nfloat remap(float v, float amin, float amax, float bmin, float bmax)\n{\n  return (v - amin)*(bmax - bmin)/(amax - amin) + bmin;\n}\n\nfloat roundF(const float number)\n{\n  return sign(number)*floor(abs(number)+0.5);\n}\n\nfloat quantize(const float v, const float quanta) {\n  return floor(v/quanta)*quanta;\n}\n\n// VEC2 -> VEC2\nvec2 uvBrick(const vec2 uv, const float numberOfBricksWidth, const float numberOfBricksHeight)\n{\n  float yi=uv.y*numberOfBricksHeight;\n  float nyi=roundF(yi);\n  float xi=uv.x*numberOfBricksWidth;\n  if (mod(floor(yi),2.0) == 0.0)\n  {\n    xi=xi-0.5;\n  }\n  float nxi=roundF(xi);\n\n  return vec2((xi-floor(xi))*numberOfBricksHeight,(yi-floor(yi))*numberOfBricksWidth);\n}\n\nvec2 uvTransform(const vec2 uv, const vec2 center, const vec2 scale, const float rad, const vec2 translate) \n{\n  float c = cos(-rad);\n  float s = sin(-rad);\n  float x = (uv.x - translate.x - center.x);\n  float y = (uv.y - translate.y - center.y);\n  float x2 = (x*c + y*s)/scale.x + center.x;\n  float y2 = (-x*s + y*c)/scale.y + center.y;\n  return vec2(x2, y2);\n}\n\nvec2 uvCrop(const vec2 uv, const vec2 uvMin, const vec2 uvMax) \n{\n  vec2 scale = 1./(uvMax - uvMin);\n  return uvTransform(uv, vec2(0.), scale, 0., -uvMin*scale);\n}\n\n\n// SAMPLER2D -> VEC4\nfloat normpdf(const float x, const float sigma)\n{\n  return .39894*exp(-.5*x*x/(sigma*sigma))/sigma;\n}\n\nvec4 blur13(const sampler2D image, const vec2 uv, const vec2 resolution, const float sigma)\n{\n  const int kernelWidth = 13;\n  const int kSize = kernelWidth/2 - 1;\n  float kernel[kernelWidth];\n\n  float Z = 0.;\n\n  for (int j = 0; j <= kSize; j++)\n  {\n    kernel[kSize + j] = kernel[kSize - j] = normpdf(float(j), sigma);\n  }\n  for (int j = 0; j < kernelWidth; j++)\n  {\n    Z += kernel[j];\n  }\n\n  vec4 color = vec4(0.);\n  for (int i = -kSize; i <= kSize; i++)\n  {\n    for (int j = -kSize; j <= kSize; j++)\n    {\n      color += kernel[kSize + j]*kernel[kSize + i]*texture2D( image, uv + vec2(float(i), float(j))/resolution );\n    }\n  }\n\n  return color/(Z*Z);\n}\n\nvec4 terrase13(const sampler2D image, const vec2 uv, const vec2 resolution)\n{\n  const int kernelWidth = 13; // this must be const for webgl1\n  const int kSize = kernelWidth/2 - 1;\n\n  vec4 color = vec4(0.);\n  for (int i = -kSize; i <= kSize; i++)\n  {\n    for (int j = -kSize; j <= kSize; j++)\n    {\n      color = max( color, texture2D( image, uv + vec2(float(i), float(j))/resolution ) );\n    }\n  }\n\n  return color;\n}\n\nvec4 terrase5(const sampler2D image, const vec2 uv, const vec2 resolution)\n{\n  const int kernelWidth = 5; // this must be const for webgl1\n  const int kSize = kernelWidth/2 - 1;\n\n  vec4 color = vec4(0.);\n  for (int i = -kSize; i <= kSize; i++)\n  {\n    for (int j = -kSize; j <= kSize; j++)\n    {\n      color = max( color, texture2D( image, uv + vec2(float(i), float(j))/resolution ) );\n    }\n  }\n\n  return color;\n}\n\nvec4 terrase27(const sampler2D image, const vec2 uv, const vec2 resolution)\n{\n  const int kernelWidth = 27; // this must be const for webgl1\n  const int kSize = kernelWidth/2 - 1;\n\n  vec4 color = vec4(0.);\n  for (int i = -kSize; i <= kSize; i++)\n  {\n    for (int j = -kSize; j <= kSize; j++)\n    {\n      color = max( color, texture2D( image, uv + vec2(float(i), float(j))/resolution ) );\n    }\n  }\n\n  return color;\n}\n\n// VEC2 -> FLOAT\nfloat rand(const vec2 n)\n{\n  return fract(cos(dot(n,vec2(12.9898,4.1414)))*43758.5453);\n}\n\nfloat noise(const vec2 n)\n{\n  const vec2 d=vec2(0.0,1.0);\n  vec2 b=floor(n), f=smoothstep(vec2(0.0), vec2(1.0), fract(n));\n  return mix( mix( rand(b), rand(b+d.yx), f.x ), mix( rand(b+d.xy), rand(b+d.yy), f.x ), f.y );\n}\n\nfloat fbm(vec2 n) {\n  float total=0.0,amplitude=1.0;\n\n  for (int i=0; i<4; i++)\n  {\n    total+=noise(n)*amplitude;\n    n+=n;\n    amplitude*=0.5;\n  }\n\n  return total;\n}\n\nfloat turbulence(const vec2 P)\n{\n  float val=0.0;\n  float freq=1.0;\n\n  for (int i=0; i<4; i++)\n  {\n    val+=abs(noise(P*freq)/freq);\n    freq*=2.07;\n  }\n\n  return val;\n}\n\nfloat brick(const vec2 uv, const float numberOfBricksWidth, const float numberOfBricksHeight, const float jointWidthPercentage, const float jointHeightPercentage)\n{\n  float yi=uv.y*numberOfBricksHeight;\n  float nyi=roundF(yi);\n  float xi=uv.x*numberOfBricksWidth;\n  if (mod(floor(yi),2.0) == 0.0) { xi = xi - 0.5; } // offset every second brick\n  float nxi=roundF(xi);\n  xi = abs(xi - nxi);\n  yi = abs(yi - nyi);\n\n  return 1. - clamp( min(yi/jointHeightPercentage, xi/jointWidthPercentage) + 0.2, 0., 1. );\n}\n\nfloat marble(const vec2 uv, float amplitude, float k)\n{\n  k = 6.28*uv.x/k;\n  k += amplitude*turbulence(uv.xy);\n  k = sin(k);\n  k = .5*(k + 1.);\n  k = sqrt( sqrt( sqrt(k) ) ); \n  return .2 + .75*k;\n}\n\nfloat checkerboard(const vec2 uv, const float numCheckers)\n{\n  float cx = floor(numCheckers * uv.x);\n  float cy = floor(numCheckers * uv.y);\n  return sign( mod(cx + cy, 2.) );\n}\n\nfloat gaussian(const vec2 uv)\n{\n  vec2 xy = (mod(uv, vec2(1.,1.)) - .5)*2.;\n  float exponent = dot(xy,xy)/0.31831;\n  return exp(-exponent);\n}\n\n// from glsl-voronoi-noise\nconst mat2 myt = mat2(.12121212, .13131313, -.13131313, .12121212);\nconst vec2 mys = vec2(1e4, 1e6);\n\nvec2 rhash(vec2 uv) {\n  uv *= myt;\n  uv *= mys;\n  return fract(fract(uv / mys) * uv);\n}\n\nvec3 hash(const vec3 p) {\n  return fract(sin(vec3(dot(p, vec3(1.0, 57.0, 113.0)),\n    dot(p, vec3(57.0, 113.0, 1.0)),\n    dot(p, vec3(113.0, 1.0, 57.0)))) *\n  43758.5453);\n}\n\nfloat voronoi2d(const in vec2 point) {\n  vec2 p = floor(point);\n  vec2 f = fract(point);\n  float res = 0.0;\n  for (int j = -1; j <= 1; j++) {\n    for (int i = -1; i <= 1; i++) {\n      vec2 b = vec2(i, j);\n      vec2 r = vec2(b) - f + rhash(p + b);\n      res += 1. / pow(dot(r, r), 8.);\n    }\n  }\n  return pow(1. / res, 0.0625);\n}\n\n// from glsl-worley\n// Permutation polynomial: (34x^2 + x) mod 289\nvec3 permute(const vec3 x) {\n  return mod((34.0 * x + 1.0) * x, 289.0);\n}\n\nvec3 dist(const vec3 x, const vec3 y) {\n  return (x * x + y * y);\n}\n\nvec2 worley(const vec2 P, const float jitter) {\n  float K= 0.142857142857; // 1/7\n  float Ko= 0.428571428571 ;// 3/7\n  vec2 Pi = mod(floor(P), 289.0);\n  vec2 Pf = fract(P);\n  vec3 oi = vec3(-1.0, 0.0, 1.0);\n  vec3 of = vec3(-0.5, 0.5, 1.5);\n  vec3 px = permute(Pi.x + oi);\n  vec3 p = permute(px.x + Pi.y + oi); // p11, p12, p13\n  vec3 ox = fract(p*K) - Ko;\n  vec3 oy = mod(floor(p*K),7.0)*K - Ko;\n  vec3 dx = Pf.x + 0.5 + jitter*ox;\n  vec3 dy = Pf.y - of + jitter*oy;\n  vec3 d1 = dist(dx,dy); // squared\n  p = permute(px.y + Pi.y + oi); // p21, p22, p23\n  ox = fract(p*K) - Ko;\n  oy = mod(floor(p*K),7.0)*K - Ko;\n  dx = Pf.x - 0.5 + jitter*ox;\n  dy = Pf.y - of + jitter*oy;\n  vec3 d2 = dist(dx,dy); // squared\n  p = permute(px.z + Pi.y + oi); // p31, p32, p33\n  ox = fract(p*K) - Ko;\n  oy = mod(floor(p*K),7.0)*K - Ko;\n  dx = Pf.x - 1.5 + jitter*ox;\n  dy = Pf.y - of + jitter*oy;\n  vec3 d3 = dist(dx,dy); // squared\n\n  // Sort out the two smallest distances (F1, F2)\n  vec3 d1a = min(d1, d2);\n  d2 = max(d1, d2); // Swap to keep candidates for F2\n  d2 = min(d2, d3); // neither F1 nor F2 are now in d3\n  d1 = min(d1a, d2); // F1 is now in d1\n  d2 = max(d1a, d2); // Swap to keep candidates for F2\n  d1.xy = (d1.x < d1.y) ? d1.xy : d1.yx; // Swap if smaller\n  d1.xz = (d1.x < d1.z) ? d1.xz : d1.zx; // F1 is in d1.x\n  d1.yz = min(d1.yz, d2.yz); // F2 is now not in d2.yz\n  d1.y = min(d1.y, d1.z); // nor in  d1.z\n  d1.y = min(d1.y, d2.x); // F2 is in d1.y, we're done.\n  return sqrt(d1.xy);\n}\n";AFRAME.registerComponent("prefab",{schema:{template:{default:""},debug:{default:!1}},init(){this.templateContent=void 0,this.hasPrefab=!1},remove(){this.destroyPrefab()},updateSchema(e){"object"!=typeof e&&console.error(`invalid properties, expected format <property>:<value>; '${e}'`);const t=AFRAME.components[this.name].schema;let i={};for(let n in e)n in t||(i[n]={type:"string"});Object.keys(i).length>0&&this.extendSchema(i)},update(e){const t=this.data;e.template!==t.template&&Y(t.template,"",e=>{this.templateContent=e,this.destroyPrefab(),this.createPrefab()})},createPrefab(){if(!this.hasPrefab){const e=this.processTemplate(this.templateContent);this.el.innerHTML=e,this.hasPrefab=!0,this.data.debug&&console.log(e)}},destroyPrefab(){if(this.hasPrefab){for(;this.el.lastChild;)this.el.removeChild(this.el.lastChild);this.hasPrefab=!1}},processTemplate(e){const t=Object.keys(this.data).concat("return `"+e+"`");return new Function(...t)(...Object.values(this.data))}}),AFRAME.registerComponent("rumble",{schema:{events:{default:""},delay:{default:0},duration:{default:.1},force:{default:1},controllers:{default:""},enabled:{default:!0}},multiple:!0,init(){this.delayClock=q(),this.eventListener=G(this.el,this.onEvent.bind(this)),this.pulses=[]},remove(){this.eventListener.remove(),this.stopAllActuators()},play(){this.eventListener.add()},pause(){this.eventListener.remove(),this.stopAllActuators()},update(e){const t=this.data;t.events!==e.events&&this.eventListener.set(t.events),t.controllers!==e.controllers&&(this.stopAllActuators(),this.actuators=[]),t.enabled!==e.enabled&&(t.enabled||this.stopAllActuators())},onEvent(e){const t=this.data;if(!t.enabled)return;const i=this.getActuators(e);if(0===i.length)return;const n=this;var a;this.delayClock.startTimer(t.delay,()=>(a=n.pulses,a=[],void i.map(e=>{a.push(e),e.pulse(t.force,1e3*t.duration).then(()=>{a.splice(a.indexOf(e),1)},t=>{a.splice(a.indexOf(e),1),console.error(t)})})))},stopAllActuators(){this.delayClock.clearAllTimers();for(let e of this.pulses)e.pulse(0,0);this.pulses.length=0},getActuators(e){if(this.actuators.length>0)return this.actuators;const t=this.data,i=t.controllers?document.querySelectorAll(t.controllers):[this.el];let n=[];if(0===i.length)$("no controller elements found");else{for(let e of i)if(e.components["tracked-controls"]&&e.components["tracked-controls"].controller){const t=e.components["tracked-controls"].controller;t.hapticActuators.length>0&&n.push(...t.hapticActuators)}0===n.length&&$("no tracked-controls found")}return this.actuators=n,n}});var mt=["attribute vec3 position;","attribute vec2 uv;","uniform mat4 projectionMatrix;","uniform mat4 modelViewMatrix;","varying vec2 vUv;","void main()  {","  vUv = vec2( 1.- uv.x, uv.y );","  gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );","}"].join("\n"),ft=["precision mediump float;","uniform samplerCube map;","varying vec2 vUv;","#define M_PI 3.141592653589793238462643383279","void main() {","  vec2 uv = vUv;","  float longitude = uv.x * 2. * M_PI + .5 * M_PI;","  float latitude = uv.y * M_PI;","  vec3 dir = vec3(","    - sin( longitude ) * sin( latitude ),","    cos( latitude ),","    - cos( longitude ) * sin( latitude )","  );","  normalize( dir );","  gl_FragColor = vec4( textureCube( map, dir ).rgb, 1.0 );","}"].join("\n"),pt=["varying vec2 vUv;","void main() {","  vUv = uv;","  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);","}"].join("\n"),gt=["#include <packing>","varying vec2 vUv;","uniform sampler2D tDepth;","uniform float cameraNear;","uniform float cameraFar;","uniform float maxDepth;","float readDepth( sampler2D depthSampler, vec2 coord ) {","  float fragCoordZ = texture2D( depthSampler, coord ).x;","  float z_n = 2.0 * fragCoordZ - 1.0;","  float z_e = 2.0 * cameraNear * cameraFar / (cameraFar + cameraNear - z_n * (cameraFar - cameraNear));","  return clamp(z_e/maxDepth, 0., 1.);","}","void main() {","  //gl_FragColor.rgb = vec3(vUv.x, vUv.y, 0.0);","  //gl_FragColor.rgb = texture2D( tDepth, vUv ).rgb;","  float depth = readDepth( tDepth, vUv );","  gl_FragColor.rgb = 1.0 - vec3( depth );","  gl_FragColor.a = 1.0;","}"].join("\n");AFRAME.registerComponent("screenshotx",{schema:{width:{default:4096},height:{default:2048},camera:{type:"selector"},maxDepth:{default:10}},init:function(){this.setup=this.setup.bind(this),this.onKeyDown=this.onKeyDown.bind(this);const e=this.el;e.renderer?this.setup():e.addEventListener("render-target-loaded",this.setup)},setup(){var e=this.el.renderer.getContext();if(!e)return;this.cubeMapSize=e.getParameter(e.MAX_CUBE_MAP_TEXTURE_SIZE),this.orthographicCamera=new THREE.OrthographicCamera(-1,1,1,-1,0,1),this.screenshot={},this.screenshot.canvas=document.createElement("canvas"),this.screenshot.ctx=this.screenshot.canvas.getContext("2d"),this.equirectangular={},this.equirectangular.material=new THREE.RawShaderMaterial({uniforms:{map:{type:"t",value:null}},vertexShader:mt,fragmentShader:ft,side:THREE.DoubleSide});const t=new THREE.Mesh(new THREE.PlaneBufferGeometry(2,2),this.equirectangular.material);this.equirectangular.scene=new THREE.Scene,this.equirectangular.scene.add(t),this.depth={},this.depth.canvas=document.createElement("canvas"),this.depth.ctx=this.depth.canvas.getContext("2d"),this.depth.material=new THREE.ShaderMaterial({vertexShader:pt,fragmentShader:gt,uniforms:{cameraNear:{value:0},cameraFar:{value:0},maxDepth:{value:0},tDepth:{type:"t",value:null}}});const i=new THREE.Mesh(new THREE.PlaneBufferGeometry(2,2),this.depth.material);this.depth.scene=new THREE.Scene,this.depth.scene.add(i)},createRenderTarget:function(e,t){const i=new THREE.WebGLRenderTarget(e,t,{minFilter:THREE.LinearFilter,magFilter:THREE.LinearFilter,wrapS:THREE.ClampToEdgeWrapping,wrapT:THREE.ClampToEdgeWrapping,format:THREE.RGBAFormat,type:THREE.UnsignedByteType});return i.stencilBuffer=!1,i.depthBuffer=!0,i},play:function(){window.addEventListener("keydown",this.onKeyDown)},pause:function(){window.removeEventListener("keydown",this.onKeyDown)},onKeyDown:function(e){const t=83===e.keyCode&&e.ctrlKey&&e.altKey;if(this.data&&t){const t=`screenshot${document.title?"+"+document.title.toLowerCase():""}-${Date.now()}`;this.capture(e.shiftKey?"equirectangular":"perspective",t)}},capture(e,t){const i=this.el.renderer,n=i.vr.enabled;i.vr.enabled=!1;const a=this.data.camera&&this.data.camera.components.camera.camera||this.el.camera,r={width:this.data.width,height:this.data.height};return"perspective"===e?this.capturePerspective(a,r):this.captureEquirectangular(a,r),t&&(this.saveCapture(this.screenshot.canvas,t+".png"),"perspective"===e&&this.saveCapture(this.depth.canvas,t+"_depth.png")),i.vr.enabled=n,this.screenshot.canvas},capturePerspective(e,t){const i=this.el.renderer,n=this.createRenderTarget(t.width,t.height);n.depthTexture=new THREE.DepthTexture,n.depthTexture.type=THREE.UnsignedShortType,i.clear(),i.setRenderTarget(n),i.render(this.el.object3D,e),this.screenshot.canvas.width=t.width,this.screenshot.canvas.height=t.height,this.copyRenderTargetToCanvas(i,n,this.screenshot.ctx,t,!0);const a=this.depth.material.uniforms;a.tDepth.value=n.depthTexture,a.cameraNear.value=e.near,a.cameraFar.value=e.far,a.maxDepth.value=this.data.maxDepth;const r=this.createRenderTarget(t.width,t.height);i.setRenderTarget(r),i.render(this.depth.scene,this.orthographicCamera),this.depth.canvas.width=t.width,this.depth.canvas.height=t.height,this.copyRenderTargetToCanvas(i,r,this.depth.ctx,t,!0),i.setRenderTarget(null)},captureEquirectangular(e,t){const i=this.el,n=i.renderer;var a=new THREE.CubeCamera(e.near,e.far,Math.min(this.cubeMapSize,2048));e.getWorldPosition(a.position),e.getWorldQuaternion(a.quaternion),a.update(i.renderer,i.object3D);const r=this.createRenderTarget(t.width,t.height);this.equirectangular.material.uniforms.map.value=a.renderTarget.texture,n.clear(),n.setRenderTarget(r),n.render(this.equirectangular.scene,this.orthographicCamera),this.screenshot.canvas.width=t.width,this.screenshot.canvas.height=t.height,this.copyRenderTargetToCanvas(n,r,this.screenshot.ctx,t,!1),n.setRenderTarget(null)},flipPixelsVertically:function(e,t,i){for(var n=e.slice(0),a=0;a<t;++a)for(var r=0;r<i;++r)n[4*a+r*t*4]=e[4*a+(i-r)*t*4],n[4*a+1+r*t*4]=e[4*a+1+(i-r)*t*4],n[4*a+2+r*t*4]=e[4*a+2+(i-r)*t*4],n[4*a+3+r*t*4]=e[4*a+3+(i-r)*t*4];return n},saveCapture:function(e,t){e.toBlob(function(e){var i=document.createElement("a"),n=URL.createObjectURL(e);i.href=n,i.setAttribute("download",t),i.innerHTML="downloading...",i.style.display="none",document.body.appendChild(i),setTimeout(function(){i.click(),document.body.removeChild(i)},1)},"image/png")},copyRenderTargetToCanvas(e,t,i,n,a){let r=new Uint8Array(4*n.width*n.height);e.readRenderTargetPixels(t,0,0,n.width,n.height,r),a&&(r=this.flipPixelsVertically(r,n.width,n.height));const s=new ImageData(new Uint8ClampedArray(r),n.width,n.height);i.putImageData(s,0,0)}});const vt=THREE.Math.degToRad,yt=new THREE.Vector3(0,0,0),bt={geometrytriangle:ze,geometryedge:Ve,geometryvertex:function(e,t){let i=3*Math.floor(Math.random()*e.length/3);t.fromArray(e,i)}},Et=["sequence","randomsequence","random"];function xt(e){return e.toLowerCase()}AFRAME.registerComponent("simple-emitter",{schema:{enabled:{default:!0},count:{default:100},particles:{default:"particles"},textureFrame:{type:"vec2",default:{x:0,y:0}},lifeTime:{default:"1"},loopTime:{default:"0"},colors:{default:""},rotations:{default:""},scales:{default:""},opacities:{default:""},frames:{default:""},frameStyle:{default:"sequence",oneOf:Et,parse:xt},velocity:{default:"0 0 0"},acceleration:{default:"0 0 0"},radialVelocity:{default:"0"},radialAcceleration:{default:"0"},angularVelocity:{default:"0 0 0"},angularAcceleration:{default:"0 0 0"},orbitalVelocity:{default:"0"},orbitalAcceleration:{default:"0"},spawnShape:{default:"point",oneOf:["point","geometrytriangle","geometryedge","geometryvertex","circle","sphere","box","insidecircle","insidesphere","insidebox"],parse:xt},spawnGeometry:{type:"selector"}},multiple:!0,init(){this.particleSystem=this.el.sceneEl.systems["simple-particles"].getParticles(this.data.particles),this.startIndex=void 0,this.endIndex=void 0,this.maxLifeTime=void 0,this.spawnCount=0,this.particles=[],this.enabled=!0,this.spawnOffsets=void 0},remove(){this.startIndex&&this.particleSystem.releaseParticles(this.startIndex)},update(e){const t=this.data;if("string"==typeof t)return void $(this,`attributes are incorrectly formatted '${t}'`);this.lifeTime=L(t.lifeTime),this.loopTime=L(t.loopTime),this.rotations=D(t.rotations,!1,vt),this.scales=D(t.scales),this.opacities=D(t.opacities),this.colors=function(e,t=!1,i=T){return M(e,C,t,i)}(t.colors),this.frames=D(t.frames),this.frameStyle=Et.indexOf(t.frameStyle)?Et.indexOf(t.frameStyle):0,this.velocity=F(t.velocity),this.acceleration=F(t.acceleration),this.radialVelocity=L(t.radialVelocity),this.radialAcceleration=L(t.radialAcceleration),this.angularVelocity=F(t.angularVelocity),this.angularAcceleration=F(t.angularAcceleration),this.orbitalVelocity=L(t.orbitalVelocity),this.orbitalAcceleration=L(t.orbitalAcceleration),bt[t.spawnShape]&&t.spawnGeometry!==e.spawnGeometry?(this.spawnGeometryFunction=bt[t.spawnShape],this.spawnOffsets=this.calcSpawnOffsetsFromGeometry(t.spawnGeometry||this.el)):(this.spawnGeometryFunction=void 0,this.spawnOffsets=void 0),(t.textureFrame.x>64||t.textureFrame.y>64||t.textureFrame.x<0||t.textureFrame.y<0)&&Q(this,`textureFrame (${t.textureFrame.x},${t.textureFrame.y}) is expected in the range (0,64) x (0,64)`),t.textureFrame.x===~~t.textureFrame.x&&t.textureFrame.y===~~t.textureFrame.y||Q(this,"textureFrame must be an integer value");const i=this.particleSystem;i?(this.maxLifeTime=P(this.lifeTime),this.startIndex&&(i.releaseParticles(this.startIndex),this.startIndex=void 0,this.endIndex=void 0),this.startIndex=i.allocateParticles(t.count),void 0!==this.startIndex&&(this.endIndex=this.startIndex+t.count),this.enabled=this.data.enabled,this.createParticles(0)):this.enabled=!1},createParticles(e){const t=this.data,i=Math.max(k(this.loopTime),P(this.lifeTime)),n=i/t.count;this.el.object3D.updateMatrixWorld();for(let t=this.startIndex;t<this.endIndex;t++)this.spawn(t,e+t*n,i);this.particleSystem.needsUpdate()},spawn:function(){const e=new THREE.Vector3;return function(t,i,n){const a=this.data,r=_(this.scales),s=_(this.rotations),o=_(this.colors),l=_(this.opacities),c=_(this.frames),d=k(this.lifeTime),h=k(this.velocity),u=k(this.acceleration),m=k(this.radialVelocity),f=k(this.radialAcceleration),p=k(this.angularVelocity),g=k(this.angularAcceleration),v=k(this.orbitalVelocity),y=k(this.orbitalAcceleration);this.spawnGeometryFunction&&this.spawnOffsets?this.spawnGeometryFunction(this.spawnOffsets,e):e.copy(yt);const b=this.particleSystem;b.setMatrixAt(t,this.el.object3D.matrixWorld),b.setPositionAt(t,e.x,e.y,e.z),b.setScalesAt(t,r),b.setColorsAt(t,o),b.setRotationsAt(t,s),b.setOpacitiesAt(t,l);const E=c.length>0?c[0]:0,x=c.length>1?c[1]:E;b.setFrameAt(t,this.frameStyle,E,x,a.textureFrame.x,a.textureFrame.y),b.setTimingsAt(t,i,d,n),b.setVelocityAt(t,h.x,h.y,h.z,m),b.setAccelerationAt(t,u.x,u.y,u.z,f),b.setAngularVelocityAt(t,p.x,p.y,p.z,v),b.setAngularAccelerationAt(t,g.x,g.y,g.z,y)}}(),calcSpawnOffsetsFromGeometry(e){if(!e||!e.object3D)return;let t=[];const i=new THREE.Vector3,n=new THREE.Matrix4,a=new THREE.Matrix4;return e.object3D.updateMatrixWorld(),n.getInverse(e.object3D.matrixWorld),e.object3D.traverse(e=>{if(!e.geometry||!e.geometry.getAttribute)return;const r=e.geometry.getAttribute("position");if(r&&3===r.itemSize)for(let s=0;s<r.count;s++)a.copy(e.matrixWorld).multiply(n),i.fromBufferAttribute(r,s).applyMatrix4(a),t.push(i.x,i.y,i.z)}),Float32Array.from(t)}});AFRAME.registerComponent("simple-hands",{schema:{grabSelectors:{default:""},toolSelectors:{default:""},colliderOffset:{type:"vec3"},colliderRadius:{default:.05},handSelectors:{default:""},grabStart:{default:"triggerdown"},grabEnd:{default:"triggerup"},toolEquip:{default:"triggerdown"},toolDrop:{default:"gripdown"},watch:{default:!0},bubbles:{default:!1},debug:{default:!1}},init(){this.observer=null,this.sides=[],this.grabEls=[],this.toolEls=[],this.onSceneChanged=this.onSceneChanged.bind(this),this.onGrabStartEvent=this.onGrabStartEvent.bind(this),this.onGrabEndEvent=this.onGrabEndEvent.bind(this),this.onToolEquipEvent=this.onToolEquipEvent.bind(this),this.onToolDropEvent=this.onToolDropEvent.bind(this),this.onSceneLoaded=this.onSceneLoaded.bind(this),this.el.sceneEl.addEventListener("loaded",this.onSceneLoaded)},remove(){this.el.sceneEl.removeEventListener("loaded",this.onSceneLoaded),this.hideColliderDebug(),this.observer&&(this.observer.disconnect(),this.observer=null)},play(){for(let e of this.sides)this.addListeners(e)},pause(){for(let e of this.sides)this.removeListeners(e)},addListeners(e){if(e.hand&&!e.hasListeners){const t=this.data;e.hand.addEventListener(t.grabStart,this.onGrabStartEvent),e.hand.addEventListener(t.grabEnd,this.onGrabEndEvent),e.hand.addEventListener(t.toolEquip,this.onToolEquipEvent),e.hand.addEventListener(t.toolDrop,this.onToolDropEvent),e.hasListeners=!0}},removeListeners(e){if(e.hand&&e.hasListeners){const t=this.data;e.hand.removeEventListener(t.grabStart,this.onGrabStartEvent),e.hand.removeEventListener(t.grabEnd,this.onGrabEndEvent),e.hand.removeEventListener(t.toolEquip,this.onToolEquipEvent),e.hand.removeEventListener(t.toolDrop,this.onToolDropEvent),e.hasListeners=!1}},update(e){const t=this.data;if(e.grabSelectors===t.grabSelectors&&e.toolSelectors===t.toolSelectors&&e.handSelectors===t.handSelectors||this.gatherElements(),!AFRAME.utils.deepEqual(t.colliderOffset,e.colliderOffset)||t.colliderRadius!==e.colliderRadius)for(let e of this.sides)this.hideColliderDebug(e),this.showColliderDebug(e)},tick(){for(let e of this.sides)"hover"===e.mode&&e.hand&&this.updateHover(e)},setMode(e,t){e.mode!==t&&(e.mode=t)},findOverlapping:function(){const e=new THREE.Vector3;return function(t,i,n,a){let r=Number.MAX_VALUE,s=void 0;for(let l of n){if(!l.isEntity||!l.object3D)continue;let n=l.object3D;if(n.boundingSphere&&n.boundingBox&&!n.boundingBox.isEmpty()||Me(n,a),n.boundingBox.isEmpty())continue;e.copy(n.boundingSphere.center).applyMatrix4(n.matrixWorld);const c=n.boundingSphere.radius*Math.max(n.scale.x,n.scale.y,n.scale.z);if(t.distanceTo(e)>c+i)continue;if(Re(t,n.boundingBox.min,n.boundingBox.max,n.matrixWorld.elements)>i)continue;const d=((o=n.boundingBox).max.x-o.min.x)*(o.max.y-o.min.y)*(o.max.z-o.min.z);d<r&&(r=d,s=l)}var o;return s}}(),gatherElements(){const e=this.data,t=this.el.sceneEl;this.grabEls=e.grabSelectors?t.querySelectorAll(e.grabSelectors):[],this.grabEls.length>100&&$(`many entities in grabSelectors (${this.grabEls.length}), performance may be affected`),this.toolEls=e.toolSelectors?t.querySelectorAll(e.toolSelectors):[],this.toolEls.length>100&&$(`many entities in toolSelectors (${this.toolEls.length}), performance may be affected`);const i=e.handSelectors?t.querySelectorAll(e.handSelectors):[];this.setSides(Array.from(i))},setSides(e){for(let t=0;t<this.sides.length;){const i=this.sides[t];e.includes(i.hand)?t++:(this.removeListeners(i),this.hideColliderDebug(i),this.sides.splice(t,1))}for(let t of e)if(!this.sides.find(e=>e.hand===t)){const e={hand:t,mode:"hover"};this.sides.push(e),this.addListeners(e),this.removeListeners(e)}},updateHover:function(){const e=new THREE.Vector3,t=new THREE.Color("yellow"),i=new THREE.Color("blue");return function(n){const a=this.data,r=n.hand.object3D,s=a.colliderRadius;let o=void 0,l=void 0;e.copy(a.colliderOffset).applyMatrix4(r.matrixWorld),l="tool",(o=this.findOverlapping(e,s,this.toolEls,a.debug?i:void 0))||(o=this.findOverlapping(e,s,this.grabEls,a.debug?t:void 0),l="grab"),n.target&&n.target!==o&&this.sendTwoEvents("hoverend",n.hand,n.target),o&&o!==n.target&&this.sendTwoEvents("hoverstart",n.hand,o),n.target=o,n.targetType=o?l:void 0}}(),hideColliderDebug(e){e.colliderDebug&&e.hand.object3D.remove(e.colliderDebug)},showColliderDebug(e){const t=this.data;if(e.hand&&t.debug){const i=new THREE.SphereBufferGeometry(t.colliderRadius,6,6);i.translate(t.colliderOffset.x,t.colliderOffset.y,t.colliderOffset.z);const n=new THREE.WireframeGeometry(i);e.colliderDebug=new THREE.LineSegments(n,new THREE.LineBasicMaterial({color:16776960})),e.hand.object3D.add(e.colliderDebug)}},determineSide(e){return this.sides.find(t=>t.hand===e)},sendTwoEvents(e,t,i){const n=this.data.bubbles;this.data.debug&&(console.log(z(i),"send",e),console.log(z(this.el),"send",e)),i.emit(e,{hand:t,object:i},n),this.el.emit(e,{hand:t,object:i},n)},onSceneLoaded(){this.gatherElements(),this.data.watch&&(this.observer=new MutationObserver(this.onSceneChanged),this.observer.observe(this.el.sceneEl,{childList:!0,subtree:!0}));const e=this.data;0===this.sides.length&&$(`unable to find any hand elements (${e.handSelectors})`),0===this.grabEls.length&&0===this.toolEls.length&&$(`no grab (${e.grabSelectors}) or tool (${e.toolSelectors}) elements`)},onSceneChanged(e){V(this.grabEls,e,this.data.grabSelectors),V(this.toolEls,e,this.data.toolSelectors)},onGrabStartEvent(e){const t=this.determineSide(e.target);t&&"hover"===t.mode&&t.target&&"grab"===t.targetType&&(this.sendTwoEvents("hoverend",t.hand,t.target),this.setMode(t,"grab"),this.sendTwoEvents("grabstart",t.hand,t.target))},onGrabEndEvent(e){const t=this.determineSide(e.target);"grab"===t.mode&&t.target&&(this.sendTwoEvents("grabend",t.hand,t.target),this.setMode(t,"hover"),t.target=void 0)},onToolEquipEvent(e){const t=this.determineSide(e.target);"hover"===t.mode&&t.target&&"tool"===t.targetType&&(this.sendTwoEvents("hoverend",t.hand,t.target),this.setMode(t,"tool"),this.sendTwoEvents("toolequip",t.hand,t.target))},onToolDropEvent(e){const t=this.determineSide(e.target);"tool"===t.mode&&t.target&&(this.sendTwoEvents("tooldrop",t.hand,t.target),this.setMode(t,"hover"),t.target=void 0)}});const Tt=new THREE.DataTexture(new Uint8Array(3).fill(255),1,1,THREE.RGBFormat);Tt.needsUpdate=!0;const At={none:THREE.NoBlending,normal:THREE.NormalBlending,additive:THREE.AdditiveBlending,subtractive:THREE.SubtractiveBlending,multiply:THREE.MultiplyBlending};AFRAME.registerSystem("simple-particles",{schema:{enabled:{default:!0}},init(){this.simpleParticles={}},registerParticles(e,t){this.simpleParticles[e]?Q(`name '${e}' already in use`):this.simpleParticles[e]=t},unregisterParticles(e,t){this.simpleParticles[e]!==t?Q(`could not find particles '${e}'`):this.simpleParticles[e]=void 0},getParticles(e){return this.simpleParticles[e]}}),AFRAME.registerComponent("simple-particles",{schema:{name:{default:"particles"},count:{default:1e3},texture:{type:"map"},textureFrame:{type:"vec2",default:{x:1,y:1}},particleType:{default:"particle",oneOf:["particle","ribbon"]},particleSize:{default:10},transparent:{default:!1},alphaTest:{default:0},depthWrite:{default:!0},depthTest:{default:!0},blending:{default:"normal",oneOf:["none","normal","additive","subtractive","multiply"],parse:function(e){return e.toLowerCase()}},fog:{default:!0},usePerspective:{default:!0},useLinearMotion:{default:!0},useOrbitalMotion:{default:!0},useAngularMotion:{default:!0},useRadialMotion:{default:!0},useFramesOrRotation:{default:!0}},multiple:!0,init(){this.mesh=void 0,this.material=void 0,this.geometry=void 0,this.system.registerParticles(this.data.name,this),this.blocks=function(e){const t=[{index:0,size:e}],i=[];function n(e){let i=!1;for(let n=0;!i&&n<t.length;n++){const a=t[n];if(a.index==e.index+e.size)a.index=e.index,a.size+=e.size,i=!0;else if(a.index+a.size===e.index){a.size+=e.size;const r=t[n+1];r&&r.index===a.index+a.size&&(a.size+=r.size,t.splice(n+1,1)),i=!0}else a.index>e.index&&(t.splice(n,0,e),i=!0)}i||t.push(e)}return{allocate:function(e){for(let n=t.length-1;n>=0;n--){const a=t[n],r=a.size-e;if(r>=0){let s;return r>0?(s={index:a.index,size:e},a.index+=e,a.size=r):(s=a,t.splice(n,1)),i.push(s),s.index}}},release:function(e){for(let t=0;t<i.length;t++){const a=i[t];if(a.index===e){const e=a.size;return i.splice(t,1),n(a),e}}return 0},maxUsed:function(){return i.reduce((e,t)=>Math.max(e,t.index+t.size),0)}}}(this.data.count),this.createMesh(this.data.count)},remove(){this.system.unregisterParticles(this.data.name,this)},update(e){const t=this.data;t.texture!==e.texture&&this.loadTexture(t.texture),(t.textureFrame.x>64||t.textureFrame.y>64||t.textureFrame.x<1||t.textureFrame.y<1)&&Q(this,`textureFrame (${t.textureFrame.x},${t.textureFrame.y}) is expected in the range (1,64) x (1,64)`),t.textureFrame.x===~~t.textureFrame.x&&t.textureFrame.y===~~t.textureFrame.y||Q(this,"textureFrame must be an integer value"),this.updateMaterial(this.material)},tick(e,t){this.material&&(this.material.uniforms.t.value=e/1e3)},createMesh(e){this.geometry=new THREE.BufferGeometry,this.updateGeometry(this.geometry,e),this.material=new THREE.RawShaderMaterial({uniforms:{map:{type:"t",value:Tt},textureFrame:{value:new THREE.Vector2(1,1)},particleSize:{value:10},usePerspective:{value:1},t:{value:0},fogDensity:{value:25e-5},fogNear:{value:1},fogFar:{value:2e3},fogColor:{value:new THREE.Color(16777215)}},fragmentShader:St,vertexShader:Rt,defines:{}}),this.mesh=new THREE.Points(this.geometry,this.material),this.mesh.frustumCulled=!1,this.el.sceneEl.object3D.add(this.mesh)},updateGeometry(e,t){e.addAttribute("row1",new THREE.Float32BufferAttribute(new Float32Array(4*t),4)),e.addAttribute("row2",new THREE.Float32BufferAttribute(new Float32Array(4*t),4)),e.addAttribute("row3",new THREE.Float32BufferAttribute(new Float32Array(4*t),4)),e.addAttribute("position",new THREE.Float32BufferAttribute(new Float32Array(3*t),3)),e.addAttribute("scales",new THREE.Float32BufferAttribute(new Float32Array(3*t),3)),e.addAttribute("rotations",new THREE.Float32BufferAttribute(new Float32Array(3*t),3)),e.addAttribute("colors",new THREE.Float32BufferAttribute(new Float32Array(3*t),3)),e.addAttribute("opacities",new THREE.Float32BufferAttribute(new Float32Array(3*t).fill(1),3)),e.addAttribute("frame",new THREE.Float32BufferAttribute(new Float32Array(2*t),2)),e.addAttribute("timings",new THREE.Float32BufferAttribute(new Float32Array(4*t),4)),e.addAttribute("velocity",new THREE.Float32BufferAttribute(new Float32Array(4*t),4)),e.addAttribute("acceleration",new THREE.Float32BufferAttribute(new Float32Array(4*t),4)),e.addAttribute("angularvelocity",new THREE.Float32BufferAttribute(new Float32Array(4*t),4)),e.addAttribute("angularacceleration",new THREE.Float32BufferAttribute(new Float32Array(4*t),4));const i=new THREE.Matrix4;for(let e=0;e<t;e++)this.setMatrixAt(e,i)},updateMaterial(e){const t=this.data;e.uniforms.particleSize.value=t.particleSize,e.uniforms.textureFrame.value.x=t.textureFrame.x,e.uniforms.textureFrame.value.y=t.textureFrame.y,e.uniforms.usePerspective.value=t.usePerspective?1:0,e.transparent=t.transparent,e.alphaTest=t.alphaTest,e.blending=At[t.blending],e.fog=t.fog,e.depthWrite=t.depthWrite,e.depthTest=t.depthTest;const i={};t.useAngularMotion&&(i.USE_ANGULAR_MOTION=!0),t.useRadialMotion&&(i.USE_RADIAL_MOTION=!0),t.useOrbitalMotion&&(i.USE_ORBITAL_MOTION=!0),t.useLinearMotion&&(i.USE_LINEAR_MOTION=!0),t.useFramesOrRotation&&(i.USE_FRAMES_OR_ROTATION=!0),t.fog&&(i.USE_FOG=!0),e.defines=i,e.needsUpdate=!0},loadTexture(e){if(e){this.el.sceneEl.systems.material.loadTexture(e,{src:e},e=>{this.material.uniforms.map.value=e})}else this.material.uniforms.map.value=Tt},setMatrixAt(e,t){const i=t.elements,n=this.geometry.getAttribute("row1"),a=this.geometry.getAttribute("row2"),r=this.geometry.getAttribute("row3");n.setXYZW(e,i[0],i[4],i[8],i[12]),a.setXYZW(e,i[1],i[5],i[9],i[13]),r.setXYZW(e,i[2],i[6],i[10],i[14])},setPositionAt(e,t,i,n){const a=this.geometry.getAttribute("position");Array.isArray(t)?(n=t[2],i=t[1],t=t[0]):"object"==typeof t&&(n=t.z,i=t.y,t=t.x),a.setXYZ(e,t,i,n)},setColorsAt(e,t){function i(e,t,i){return~~(255*e)/256+~~(255*t)/65536+~~(255*i)/16777216}const n=this.geometry.getAttribute("colors"),a=t[0],r=t[1],s=t[2];let o,l,c;switch(t.length){case 0:o=l=c=i(1,1,1);break;case 1:o=i(a.r,a.r,a.r),l=i(a.g,a.g,a.g),c=i(a.b,a.b,a.b);break;case 2:o=i(a.r,.5*(a.r+r.r),r.r),l=i(a.g,.5*(a.g+r.g),r.g),c=i(a.b,.5*(a.b+r.b),r.b);break;default:o=i(a.r,r.r,s.r),l=i(a.g,r.g,s.g),c=i(a.b,r.b,s.b)}n.setXYZ(e,o,l,c)},setOpacitiesAt(e,t){const i=this.geometry.getAttribute("opacities");this.setKeyframesAt(i,e,t,1)},setTimingsAt(e,t,i,n,a=Math.random()){this.geometry.getAttribute("timings").setXYZW(e,t,i,n,a)},setFrameAt(e,t,i,n,a=0,r=0){const s=~~(a=a||this.data.textureFrame.x)+.015625*~~(r=r||this.data.textureFrame.y)+3814697265625e-18*~~i,o=t+3814697265625e-18*~~n;this.geometry.getAttribute("frame").setXY(e,s,o)},setScalesAt(e,t){const i=this.geometry.getAttribute("scales");this.setKeyframesAt(i,e,t,1)},setRotationsAt(e,t){const i=this.geometry.getAttribute("rotations");this.setKeyframesAt(i,e,t,0)},setVelocityAt(e,t,i,n,a=0){this.geometry.getAttribute("velocity").setXYZW(e,t,i,n,a)},setAccelerationAt(e,t,i,n,a=0){this.geometry.getAttribute("acceleration").setXYZW(e,t,i,n,a)},setAngularVelocityAt(e,t,i,n,a=0){this.geometry.getAttribute("angularvelocity").setXYZW(e,t,i,n,a)},setAngularAccelerationAt(e,t,i,n,a=0){this.geometry.getAttribute("angularacceleration").setXYZW(e,t,i,n,a)},setKeyframesAt(e,t,i,n){const a=i[0],r=i[1],s=i[2];switch(i.length){case 0:e.setXYZ(t,n,n,n);break;case 1:e.setXYZ(t,a,a,a);break;case 2:e.setXYZ(t,a,.5*(a+r),r);break;default:e.setXYZ(t,a,r,s)}},needsUpdate(){this.geometry.getAttribute("row1").needsUpdate=!0,this.geometry.getAttribute("row2").needsUpdate=!0,this.geometry.getAttribute("row3").needsUpdate=!0,this.geometry.getAttribute("position").needsUpdate=!0,this.geometry.getAttribute("scales").needsUpdate=!0,this.geometry.getAttribute("colors").needsUpdate=!0,this.geometry.getAttribute("opacities").needsUpdate=!0,this.geometry.getAttribute("rotations").needsUpdate=!0,this.geometry.getAttribute("timings").needsUpdate=!0,this.geometry.getAttribute("frame").needsUpdate=!0,this.geometry.getAttribute("velocity").needsUpdate=!0,this.geometry.getAttribute("acceleration").needsUpdate=!0},multipleNeedsUpdate(e){for(let t of e)this.needsUpdate(t)},allocateParticles(e){return this.blocks.allocate(e)},releaseParticles(e){const t=this.blocks.release(e);if(t>0){const i=this.geometry.getAttribute("scales");for(let n=e;n<e+t;n++)i.setXYZ(n,0,0,0)}return t}});const Rt="\nprecision highp float;\nprecision highp int;\n\nattribute vec4 row1;\nattribute vec4 row2;\nattribute vec4 row3;\nattribute vec3 position;\nattribute vec3 scales;\nattribute vec3 rotations;\nattribute vec3 colors;\nattribute vec3 opacities;\nattribute vec4 timings;\nattribute vec2 frame;\nattribute vec4 velocity;\nattribute vec4 acceleration;\nattribute vec4 angularvelocity;\nattribute vec4 angularacceleration;\n\nuniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\nuniform vec2 textureFrame;\nuniform float particleSize;\nuniform float usePerspective;\nuniform float t;\n\nvarying mat3 vUvTransform;\nvarying vec4 vParticleColor;\nvarying vec2 vUv;\nvarying float vFogDepth;\n\nfloat pseudoRandom( const float seed )\n{\n  return mod( 1664525.*seed + 1013904223., 4294967296. )/4294967296.;\n}\n\nvec3 unpackFrame( float pack )\n{\n  float y = fract( pack ) * 64.;\n  return floor( vec3( pack, y, fract( y ) * 4096. ) );\n}\n\nvec3 unpackRGB( float pack )\n{\n  vec3 enc = fract( pack * vec3( 1., 256., 65536. ) );\n  enc -= enc.yzz * vec3( 1./256., 1./256., 0. );\n  return enc;\n}\n\nfloat interpolate( const vec3 keys, const float r )\n{\n  float k = r*2.;\n  return k < 1. ? mix( keys.x, keys.y, k ) : mix( keys.y, keys.z, k - 1. );\n}\n\n// assumes euler order is YXZ\nvec4 eulerToQuaternion( const vec3 euler )\n{\n  // from https://github.com/mrdoob/three.js/blob/master/src/math/Quaternion.js\n\n  vec3 c = cos( euler * .5 );\n  vec3 s = sin( euler * .5 );\n\n  return vec4(\n    s.x * c.y * c.z + c.x * s.y * s.z,\n    c.x * s.y * c.z - s.x * c.y * s.z,\n    c.x * c.y * s.z - s.x * s.y * c.z,\n    c.x * c.y * c.z + s.x * s.y * s.z\n  );\n}\n\n// from http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm\nvec4 axisAngleToQuaternion( const vec3 axis, const float angle ) \n{\n  return vec4( axis * sin( angle*.5 ), cos( angle*.5 ) );\n}\n\nvec3 applyQuaternion( const vec3 v, const vec4 q )\n{\n  return v + 2. * cross( q.xyz, cross( q.xyz, v ) + q.w * v );\n}\n\nvoid main()\n{\n  float spawnTime = timings.x;\n  float lifeTime = timings.y;\n  float loopTime = timings.z;\n  float seed = timings.w;\n  float age = mod( t - spawnTime, loopTime );\n  float timeRatio = age / lifeTime;\n\n  float scale = interpolate( scales, timeRatio );\n  float rotation = interpolate( rotations, timeRatio );\n  float opacity = interpolate( opacities, timeRatio );\n  vec3 color = vec3(\n    interpolate( unpackRGB( colors.x ), timeRatio ),\n    interpolate( unpackRGB( colors.y ), timeRatio ),\n    interpolate( unpackRGB( colors.z ), timeRatio )\n  );\n\n  mat4 particleMatrix = mat4(\n    vec4( row1.x, row2.x, row3.x, 0. ),\n    vec4( row1.y, row2.y, row3.y, 0. ),\n    vec4( row1.z, row2.z, row3.z, 0. ),\n    vec4( row1.w, row2.w, row3.w, 1. )\n  );\n\n  float distance = length( position );\n  vec3 direction = distance == 0. ? position : position / distance;\n\n#if defined(USE_RADIAL_MOTION)\n  distance += ( .5 * acceleration.w * age + velocity.w ) * age;\n#endif\n\n#if defined(USE_ANGULAR_MOTION)\n  if ( length( angularacceleration.xyz ) > 0. || length( angularvelocity.xyz ) > 0. )\n  {\n    vec3 angularMotion = ( .5 * angularacceleration.xyz * age + angularvelocity.xyz ) * age;\n    direction = applyQuaternion( direction, eulerToQuaternion( angularMotion ) );\n  }\n#endif\n\n#if defined(USE_ORBITAL_MOTION)\n  if ( angularacceleration.w != 0. || angularvelocity.w != 0. ) \n  {\n    float orbitalMotion = ( .5 * angularacceleration.w * age + angularvelocity.w ) * age;\n    vec3 axis;\n    axis.x = pseudoRandom(spawnTime + loopTime);\n    axis.y = pseudoRandom(axis.x);\n    axis.z = pseudoRandom(axis.y);\n    normalize(axis);\n    direction = applyQuaternion( direction, axisAngleToQuaternion( axis, orbitalMotion ) );\n  }\n#endif\n\n  vec3 motion = direction * distance;\n  \n#if defined(USE_LINEAR_MOTION)\n  motion += ( .5 * acceleration.xyz * age + velocity.xyz ) * age;\n#endif\n\n  vec4 mvPosition = modelViewMatrix * particleMatrix * vec4( motion, 1. );\n\n  vParticleColor = vec4( color, opacity );\n  vUv = vec2( 0. );\n  vFogDepth = -mvPosition.z;\n\n  vUvTransform = mat3( 1. );\n\n#if defined(USE_FRAMES_OR_ROTATION)\n\n  vec3 frameInfoA = unpackFrame( frame.x );\n  vec3 frameInfoB = unpackFrame( frame.y );\n\n  float frameWidth = frameInfoA.x;\n  float frameHeight = frameInfoA.y;\n  float startFrame = frameInfoA.z;\n  float endFrame = frameInfoB.z;\n  float frameStyle = frameInfoB.x;\n  float invFrameWidth = 1./frameWidth;\n  float invFrameHeight = 1./frameHeight;\n  float numFrames = endFrame - startFrame + 1.;\n  float currentFrame = floor( mix( startFrame, endFrame + .99999, timeRatio ) );\n\n  currentFrame = frameStyle == 0. ? currentFrame \n    : frameStyle == 1. ? ( floor( pseudoRandom( currentFrame * 6311. + seed ) * numFrames ) + startFrame  )\n    : ( floor( seed * numFrames ) + startFrame );\n\n  float tx = mod( currentFrame, frameWidth ) * invFrameWidth;\n  float ty = 1. - floor( currentFrame * invFrameWidth ) * invFrameHeight;\n  float sx = invFrameWidth;\n  float sy = invFrameHeight;\n  float cx = .5 * sx;\n  float cy = -.5 * sy;\n  float c = cos( rotation );\n  float s = sin( rotation );\n\n  mat3 uvrot = mat3( vec3( c, -s, 0. ), vec3( s, c, 0. ), vec3( 0., 0., 1.) );\n  mat3 uvtrans = mat3( vec3( 1., 0., 0. ), vec3( 0., 1., 0. ), vec3( tx + cx, ty + cy, 1. ) );\n  mat3 uvscale = mat3( vec3( sx, 0., 0. ), vec3( 0., sy, 0. ), vec3( 0., 0., 1.) );\n  mat3 uvcenter = mat3( vec3( 1., 0., 0. ), vec3( 0., 1., 0. ), vec3( -cx / sx, cy / sy, 1. ) );  \n\n  vUvTransform = uvtrans * uvscale * uvrot * uvcenter;\n\n#endif // USE_FRAMES_OR_ROTATION\n\n#if defined(USE_RIBBON)\n#else\n  gl_PointSize = scale * particleSize * mix( 1., 1. / - mvPosition.z, usePerspective );\n#endif // USE_RIBBON\n\n  gl_Position = projectionMatrix * mvPosition;\n\n  if (scale <= 0. || timeRatio < 0. || timeRatio > 1. )\n  {\n    gl_Position.w = -2.; // don't draw\n  }\n}",St="\nprecision highp float;\nprecision highp int;\n\nuniform sampler2D map;\nuniform vec3 fogColor;\nuniform float fogNear;\nuniform float fogFar;\n\nvarying mat3 vUvTransform;\nvarying vec4 vParticleColor;\nvarying vec2 vUv;\nvarying float vFogDepth;\n\nvoid main()\n{\n\n#if defined(USE_RIBBON)\n  vec2 uv = ( vUvTransform * vec3( vUv, 1. ) ).xy;\n#else\n  vec2 uv = ( vUvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1. ) ).xy;\n#endif // USE_RIBBON\n\n  vec4 diffuseColor = vParticleColor;\n\n  vec4 mapTexel = texture2D( map, uv );\n  // diffuseColor *= mapTexelToLinear( mapTexel );\n  diffuseColor *= mapTexel;\n\n#if defined(ALPHATEST)\n  if ( diffuseColor.a < ALPHATEST ) {\n    discard;\n  }\n#endif // ALPHATEST\n\n  gl_FragColor = diffuseColor;\n\n#if defined(USE_FOG)\n  float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );\n\n  gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif // USE_FOG\n}",wt=THREE.Math.degToRad,Ct={acceleration:"USE_PARTICLE_ACCELERATION",angularAcceleration:"USE_PARTICLE_ANGULAR_ACCELERATION",angularVelocity:"USE_PARTICLE_ANGULAR_VELOCITY",color:"USE_PARTICLE_COLOR",textureFrame:"USE_PARTICLE_FRAMES",textureCount:"USE_PARTICLE_FRAMES",textureLoop:"USE_PARTICLE_FRAMES",position:"USE_PARTICLE_OFFSET",opacity:"USE_PARTICLE_OPACITY",radialAcceleration:"USE_PARTICLE_RADIAL_ACCELERATION",radialPosition:"USE_PARTICLE_RADIAL_OFFSET",radialVelocity:"USE_PARTICLE_RADIAL_VELOCITY",scale:"USE_PARTICLE_SCALE",velocity:"USE_PARTICLE_VELOCITY",orbitalVelocity:"USE_PARTICLE_ORBITAL",orbitalAcceleration:"USE_PARTICLE_ORBITAL",drag:"USE_PARTICLE_DRAG",destinationWeight:"USE_PARTICLE_DESTINATION",screenDepthOffset:"USE_PARTICLE_SCREEN_DEPTH_OFFSET",source:"USE_PARTICLE_SOURCE",model:"USE_PARTICLE_SOURCE"},It=["overtime","interval"],Ot=["newest","oldest","any"],Mt=["x","y","z"],Lt=e=>e.reduce((e,t)=>Array.isArray(t)?e.concat(Lt(t)):e.concat(t),[]),Dt=(e,t)=>{let i=e.split("..").map(e=>e.trim().split(" ").map(e=>{const t=Number(e);return isNaN(t)?void 0:t}));return 1===i.length&&(i[1]=i[0]),i.length=2,Lt(i.map(e=>t.map((t,i)=>void 0===e[i]?t:e[i])))},Ft=(e,t)=>Lt(e.split(",").map(e=>Dt(e,t)));function Pt(e){return e.toLowerCase()}let kt=new THREE.DataTexture(new Uint8Array(3).fill(255),1,1,THREE.RGBFormat);kt.needsUpdate=!0;const _t={none:THREE.NoBlending,normal:THREE.NormalBlending,additive:THREE.AdditiveBlending,subtractive:THREE.SubtractiveBlending,multiply:THREE.MultiplyBlending},Ht={double:THREE.DoubleSide,front:THREE.FrontSide,back:THREE.BackSide};AFRAME.registerComponent("sprite-particles",{schema:{texture:{type:"map"},delay:{default:0},duration:{default:-1},spawnType:{default:"continuous",oneOf:["continuous","burst"],parse:Pt},spawnRate:{default:10},source:{type:"selector"},textureFrame:{type:"vec2",default:{x:1,y:1}},textureCount:{type:"int",default:0},textureLoop:{default:1},randomizeFrames:{default:!1},trailInterval:{default:0},trailLifeTime:{default:"0"},trailType:{default:"particle",oneOf:["particle","ribbon","ribbon3d"]},ribbonWidth:{default:1},ribbonShape:{default:"flat",oneOf:["flat","taperin","taperout","taper"],parse:Pt},ribbonUVType:{default:"overtime",oneOf:It,parse:Pt},emitterColor:{type:"color"},lifeTime:{default:"1"},position:{default:"0 0 0"},velocity:{default:"0 0 0"},acceleration:{default:"0 0 0"},radialType:{default:"circle",oneOf:["circle","sphere","circlexy","circlexz"],parse:Pt},radialPosition:{default:"0"},radialVelocity:{default:"0"},radialAcceleration:{default:"0"},angularVelocity:{default:"0 0 0"},angularAcceleration:{default:"0 0 0"},orbitalVelocity:{default:"0"},orbitalAcceleration:{default:"0"},scale:{default:"1"},color:{default:"white",parse:Pt},rotation:{default:"0"},opacity:{default:"1"},velocityScale:{default:0},velocityScaleMinMax:{type:"vec2",default:{x:0,y:3}},drag:{default:0},destination:{type:"selector"},destinationOffset:{default:"0 0 0"},destinationWeight:{default:"0"},events:{default:""},enabled:{default:!0},emitterTime:{default:0},model:{type:"selector"},modelFill:{default:"triangle",oneOf:["triangle","edge","vertex"],parse:Pt},direction:{default:"forward",oneOf:["forward","backward"],parse:Pt},particleOrder:{default:"any",oneOf:Ot},ribbonUVMultiplier:{default:1},materialSide:{default:"front",oneOf:["double","front","back"],parse:Pt},screenDepthOffset:{default:0},alphaTest:{default:0},fog:{default:!0},depthWrite:{default:!1},depthTest:{default:!0},blending:{default:"normal",oneOf:["none","normal","additive","subtractive","multiply"],parse:Pt},transparent:{default:!0},particleSize:{default:100},usePerspective:{default:!0},seed:{type:"number",default:-1},overTimeSlots:{type:"int",default:5},frustumCulled:{default:!0},editorObject:{default:!0}},multiple:!0,help:"https://github.com/harlyq/aframe-sprite-particles-component",init(){this.handleObject3DSet=this.handleObject3DSet.bind(this),this.count=0,this.trailCount=0,this.overTimeArrayLength=0,this.emitterTime=0,this.delayTime=0,this.lifeTime=[1,1],this.trailLifeTime=[0,0],this.paused=!1,this.textureFrames=new Float32Array(4),this.offset=new Float32Array(8).fill(0),this.velocity=new Float32Array(8).fill(0),this.acceleration=new Float32Array(8).fill(0),this.angularVelocity=new Float32Array(8).fill(0),this.angularAcceleration=new Float32Array(8).fill(0),this.orbital=new Float32Array(4).fill(0),this.colorOverTime,this.rotationScaleOverTime,this.params=new Float32Array(20).fill(0),this.velocityScale=new Float32Array(3).fill(0),this.emitterColor=new THREE.Vector3,this.destination=new Float32Array(8).fill(0),this.destinationOffset,this.destinationWeight,this.nextID=0,this.nextTime=0,this.startDisabled=!this.data.enabled||!!this.data.events,this.manageIDs=!1,this.params[1]=-1,this.eventListener=G(this.el,this.onEvent.bind(this)),this.delayClock=q()},remove(){this.mesh&&this.el.removeObject3D(this.mesh.name),this.data.model&&this.data.model.removeEventListener("object3dset",this.handleObject3DSet),this.eventListener.remove(),this.delayClock.clearAllTimers()},update(e){const t=this.data;let i=t.particleSize!==e.particleSize,n=!1;if(t.overTimeSlots===e.overTimeSlots||this.isPlaying||(this.overTimeArrayLength=2*this.data.overTimeSlots+1,this.colorOverTime=new Float32Array(4*this.overTimeArrayLength).fill(0),this.rotationScaleOverTime=new Float32Array(2*this.overTimeArrayLength).fill(0),n=!0),this.params[8]=t.particleSize,this.params[9]=t.usePerspective?1:0,this.params[10]="forward"===t.direction?0:1,this.params[11]=THREE.Math.clamp(t.drag,0,1),this.params[15]=1e-5*t.screenDepthOffset,this.params[16]=t.ribbonWidth,this.params[17]=t.ribbonUVMultiplier,this.textureFrames[0]=t.textureFrame.x,this.textureFrames[1]=t.textureFrame.y,this.textureFrames[2]=t.textureCount>0?t.textureCount:t.textureFrame.x*t.textureFrame.y,this.textureFrames[3]=t.textureLoop,this.velocityScale[0]=t.velocityScale,this.velocityScale[1]=t.velocityScaleMinMax.x,this.velocityScale[2]=t.velocityScaleMinMax.y,this.material&&(this.material.alphaTest=t.alphaTest,this.material.depthTest=t.depthTest,this.material.depthWrite=t.depthWrite,this.material.blending=_t[t.blending],this.material.fog=t.fog),t.seed!==e.seed&&(this.seed=t.seed,this.params[6]=t.seed>=0?t.seed:Math.random()),t.ribbonUVType!==e.ribbonUVType&&(this.params[18]=-1===It.indexOf(t.ribbonUVType)?0:It.indexOf(t.ribbonUVType)),t.radialType!==e.radialType&&(this.params[2]=["sphere","circlexy","circle"].includes(t.radialType)?1:0,this.params[19]=["sphere","circlexz"].includes(t.radialType)?1:0),this.mesh&&t.frustumCulled!==e.frustumCulled&&(this.mesh.frustumCulled=t.frustumCulled),t.emitterColor!==e.emitterColor){const e=new THREE.Color(t.emitterColor);this.emitterColor.set(e.r,e.g,e.b)}if(t.position===e.position&&t.radialPosition===e.radialPosition||(this.updateVec4XYZRange(t.position,"offset"),this.updateVec4WRange(t.radialPosition,[0],"offset"),i=!0),t.velocity===e.velocity&&t.radialVelocity===e.radialVelocity||(this.updateVec4XYZRange(t.velocity,"velocity"),this.updateVec4WRange(t.radialVelocity,[0],"velocity"),i=!0),t.acceleration===e.acceleration&&t.radialAcceleration===e.radialAcceleration||(this.updateVec4XYZRange(t.acceleration,"acceleration"),this.updateVec4WRange(t.radialAcceleration,[0],"acceleration"),i=!0),(t.rotation!==e.rotation||t.scale!==e.scale||n)&&(this.updateRotationScaleOverTime(),i=!0),(t.color!==e.color||t.opacity!==e.opacity||n)&&this.updateColorOverTime(),t.lifeTime!==e.lifeTime&&(this.lifeTime=this.updateVec4WRange(t.lifeTime,[1],"angularVelocity")),t.angularVelocity!==e.angularVelocity&&this.updateAngularVec4XYZRange(t.angularVelocity,"angularVelocity"),t.trailLifeTime!==e.trailLifeTime&&(this.trailLifeTime=Dt(t.trailLifeTime,[0]).map((e,t)=>e>0?e:this.lifeTime[t]),this.angularAcceleration[3]=this.trailLifeTime[0],this.angularAcceleration[7]=this.trailLifeTime[1]),t.angularAcceleration!==e.angularAcceleration&&this.updateAngularVec4XYZRange(t.angularAcceleration,"angularAcceleration"),t.orbitalVelocity!==e.orbitalVelocity&&this.updateAngularVec2PartRange(t.orbitalVelocity,[0],"orbital",0),t.orbitalAcceleration!==e.orbitalAcceleration&&this.updateAngularVec2PartRange(t.orbitalAcceleration,[0],"orbital",1),t.destinationOffset!==e.destinationOffset&&(this.destinationOffset=this.updateVec4XYZRange(t.destinationOffset,"destination")),t.destinationWeight!==e.destinationWeight&&(this.destinationWeight=this.updateVec4WRange(t.destinationWeight,[0],"destination")),t.duration===e.duration&&t.delay===e.delay&&t.emitterTime===e.emitterTime||(this.params[3]=t.duration,this.emitterTime=t.emitterTime,this.delayTime=t.delay),t.spawnType!==e.spawnType||t.spawnRate!==e.spawnRate||t.lifeTime!==e.lifeTime||t.trailInterval!==e.trailInterval){const e=this.lifeTime[1],i=t.trailInterval>0?this.trailLifeTime[1]:0,n=e+i,a=Math.max(1,Math.ceil(n*t.spawnRate));this.trailCount=1+(t.trailInterval>0?Math.ceil(Math.min(i,e)/t.trailInterval):0),this.isRibbon()?(this.trailCount++,this.count=a*this.trailCount*2):this.count=a*this.trailCount,this.params[4]="burst"===t.spawnType?0:1,this.params[5]=t.spawnRate,this.params[7]=this.count,this.params[13]=a,this.params[12]=t.trailInterval,this.params[14]=this.trailCount,this.updateAttributes()}t.enabled&&this.startDisabled&&!t.events&&(this.startDisabled=!1),t.model!==e.model&&t.model&&"getObject3D"in t.model&&(e.model&&e.model.removeEventListener("object3dset",this.handleObject3DSet),this.updateModelMesh(t.model.getObject3D("mesh")),t.model&&t.model.addEventListener("object3dset",this.handleObject3DSet)),this.mesh?this.updateDefines():this.createMesh(),t.materialSide!==e.materialSide&&(this.material.side=Ht[t.materialSide]),i&&this.updateBounds(),this.paused&&t.editorObject!==e.editorObject&&this.enableEditorObject(t.editorObject),this.manageIDs=this.manageIDs||!t.enabled||!!t.events||t.source||void 0!==this.el.getDOMAttribute(this.attrName).enabled||t.model||t.delay>0,t.texture!==e.texture&&this.loadTexture(t.texture),t.events!==e.events&&this.eventListener.set(t.events)},tick(e,t){const i=this.data;if(this.startDisabled)return;t>100&&(t=100);const n=t/1e3;i.enabled&&(this.delayTime-=n),this.delayTime>=0||i.model&&!this.modelVertices||(this.emitterTime+=n,this.params[0]=this.emitterTime,this.geometry&&this.manageIDs?this.spawnParticles(this.emitterTime):this.params[1]=-1,i.destination&&i.destination.object3D&&(this.destinationWeight[0]>0||this.destinationWeight[1]>0)&&this.updateDestinationEntity())},pause(){this.paused=!0,this.enableEditorObject(this.data.editorObject),this.eventListener.remove(),this.delayClock.pause()},play(){this.paused=!1,this.enableEditorObject(!1),this.eventListener.add(),this.delayClock.resume()},onEvent(){const e=this,t=this.data;this.delayClock.startTimer(t.delay,()=>{e.emitterTime=t.emitterTime,e.nextTime=0,e.nextID=0,e.delayTime=0,e.startDisabled=!1})},handleObject3DSet(e){e.target===this.data.model&&"mesh"===e.detail.type&&this.updateModelMesh(this.data.model.getObject3D("mesh"))},loadTexture(e){if(e){this.el.sceneEl.systems.material.loadTexture(e,{src:e},e=>{this.isRibbon()&&(e.wrapS=THREE.RepeatWrapping),this.material.uniforms.map.value=e})}else this.material.uniforms.map.value=kt},isRibbon(){return this.data.trailInterval>0&&"particle"!==this.data.trailType},createMesh(){const e=this.data;this.geometry=new THREE.BufferGeometry,this.updateAttributes(),this.material=new THREE.ShaderMaterial({uniforms:{map:{type:"t",value:kt},textureFrames:{value:this.textureFrames},params:{value:this.params},offset:{value:this.offset},velocity:{value:this.velocity},acceleration:{value:this.acceleration},angularVelocity:{value:this.angularVelocity},angularAcceleration:{value:this.angularAcceleration},orbital:{value:this.orbital},colorOverTime:{value:this.colorOverTime},rotationScaleOverTime:{value:this.rotationScaleOverTime},velocityScale:{value:this.velocityScale},emitterColor:{value:this.emitterColor},destination:{value:this.destination},fogDensity:{value:25e-5},fogNear:{value:1},fogFar:{value:2e3},fogColor:{value:new THREE.Color(16777215)}},fragmentShader:Nt,vertexShader:Ut,transparent:e.transparent,alphaTest:e.alphaTest,blending:_t[e.blending],fog:e.fog,depthWrite:e.depthWrite,depthTest:e.depthTest,defines:{}}),this.updateDefines(),this.isRibbon()?(this.mesh=new THREE.Mesh(this.geometry,[this.material]),this.mesh.drawMode=THREE.TriangleStripDrawMode):this.mesh=new THREE.Points(this.geometry,this.material),this.mesh.frustumCulled=e.frustumCulled,this.mesh.name=this.attrName,this.material.name=this.mesh.name,this.el.setObject3D(this.mesh.name,this.mesh)},updateColorOverTime(){let e=(e=>Lt(e.split(",").map(e=>{let t=e.split("..");return 1===t.length&&(t[1]=t[0]),t.length=2,t.map(e=>new THREE.Color(e.trim()))})))(this.data.color),t=Ft(this.data.opacity,[1]);const i=this.data.overTimeSlots;e.length>2*i&&(e.length=2*i),t.length>2*i&&(t.length=2*i),this.colorOverTime.fill(0),this.colorOverTime[0]=e.length/2,this.colorOverTime[1]=t.length/2;let n=e.length;for(let t=0,i=4;t<n;t++,i+=4){let n=e[t];this.colorOverTime[i]=n.r,this.colorOverTime[i+1]=n.g,this.colorOverTime[i+2]=n.b}n=t.length;for(let e=0,i=4;e<n;e++,i+=4){let n=t[e];this.colorOverTime[i+3]=n}},updateRotationScaleOverTime(){const e=this.data.overTimeSlots;let t=Ft(this.data.rotation,[0]),i=Ft(this.data.scale,[1]);t.length>2*e&&(t.length=2*e),i.length>2*e&&(i.length=2*e),this.rotationScaleOverTime.fill(0),this.rotationScaleOverTime[0]=t.length/2,this.rotationScaleOverTime[1]=i.length/2;let n=t.length;for(let e=0,i=2;e<n;e++,i+=2)this.rotationScaleOverTime[i]=wt(t[e]);n=i.length;for(let e=0,t=2;e<n;e++,t+=2)this.rotationScaleOverTime[t+1]=i[e]},updateVec4XYZRange(e,t){const i=Dt(e,[0,0,0]);for(let e=0,n=0;e<i.length;)this[t][n++]=i[e++],this[t][n++]=i[e++],this[t][n++]=i[e++],n++;return i},updateAngularVec4XYZRange(e,t){const i=Dt(e,[0,0,0]);for(let e=0,n=0;e<i.length;)this[t][n++]=wt(i[e++]),this[t][n++]=wt(i[e++]),this[t][n++]=wt(i[e++]),n++},updateAngularVec2PartRange(e,t,i,n){const a=Dt(e,t);this[i][n]=wt(a[0]),this[i][n+2]=wt(a[1])},updateVec4WRange(e,t,i){let n=Dt(e,t);return this[i][3]=n[0],this[i][7]=n[1],n},updateBounds(){const e=this.data;let t=Math.max(this.lifeTime[0],this.lifeTime[1]);let i=[new Array(4),new Array(4)];e.drag>0&&(t*=1-.5*e.drag);for(let e=0;e<2;e++){const n=0===e?Math.min:Math.max;for(let a=0;a<4;a++){const r=n(this.offset[a],this.offset[a+4]),s=n(this.velocity[a],this.velocity[a+4]),o=n(this.acceleration[a],this.acceleration[a+4]);i[e][a]=r+(s+.5*o*t)*t,i[e][a]=n(i[e][a],r);const l=-s/o;l>0&&l<t&&(i[e][a]=n(i[e][a],r-.5*s*s/o))}}this.modelBounds&&(i[0][0]+=this.modelBounds.min.x,i[0][1]+=this.modelBounds.min.y,i[0][2]+=this.modelBounds.min.z,i[1][0]+=this.modelBounds.max.x,i[1][1]+=this.modelBounds.max.y,i[1][2]+=this.modelBounds.max.z);const n=this.el.getDOMAttribute(this.attrName),a=this.rotationScaleOverTime.reduce((e,t,i)=>1&i?Math.max(e,t):e,0),r=Math.max(Math.abs(i[0][3]),Math.abs(i[1][3]))+45e-5*e.particleSize*a,s="sphere"===e.radialType||n.angularVelocity||n.angularAcceleration||n.orbitalVelocity||n.orbitalAcceleration;i[0][0]-=r,i[0][1]-=r,i[0][2]-=s?r:0,i[1][0]+=r,i[1][1]+=r,i[1][2]+=s?r:0,i[0].length=3,i[0].length=3;const o=Math.max(...i[0].map(Math.abs),...i[1].map(Math.abs));this.geometry.boundingSphere||(this.geometry.boundingSphere=new THREE.Sphere),this.geometry.boundingSphere.radius=o,this.geometry.boundingBox||(this.geometry.boundingBox=new THREE.Box3),this.geometry.boundingBox.min.set(...i[0]),this.geometry.boundingBox.max.set(...i[1]);const l=this.el.getObject3D("mesh");l&&l.isParticlesEditorObject&&this.enableEditorObject(!0)},updateDestinationEntity:function(){let e=new THREE.Vector3,t=new THREE.Vector3;return function(){this.data.destination.object3D.getWorldPosition(e),this.el.object3D.getWorldPosition(t),e.sub(t);for(let t=0,i=Mt.length;t<i;t++)this.destination[t]=e[Mt[t]]+this.destinationOffset[t],this.destination[t+4]=e[Mt[t]]+this.destinationOffset[t+3]}}(),enableEditorObject(e){const t=this.el.getObject3D("mesh");if(!e||t&&!t.isParticlesEditorObject)!e&&t&&t.isParticlesEditorObject&&this.el.removeObject3D("mesh");else{const e=.25,t=new THREE.Vector3(e,e,e).max(this.geometry.boundingBox.max),i=new THREE.Vector3(-e,-e,-e).min(this.geometry.boundingBox.min);let n=new THREE.Box3(i,t),a=new THREE.Box3Helper(n,8421376);a.isParticlesEditorObject=!0,a.visible=!1,this.el.setObject3D("mesh",a)}},updateAttributes(){if(this.geometry){const e=this.count;let t=new Float32Array(e);if(this.startDisabled||this.data.delay>0||this.data.model)t.fill(-1);else for(let i=0;i<e;i++)t[i]=i;if(this.geometry.addAttribute("vertexID",new THREE.Float32BufferAttribute(t,1)),this.geometry.addAttribute("position",new THREE.Float32BufferAttribute(new Float32Array(3*e).fill(0),3)),this.data.source&&this.geometry.addAttribute("quaternion",new THREE.Float32BufferAttribute(new Float32Array(4*e).fill(0),4)),this.isRibbon()){this.geometry.clearGroups();const t=2*this.trailCount;for(let i=0;i<e;i+=t)this.geometry.addGroup(i,t,0)}}},updateDefines(){const e=this.data,t=Object.keys(this.el.getDOMAttribute(this.attrName)),i=t.map(e=>Ct[e]).filter(e=>e);let n={PARAMS_LENGTH:5,OVER_TIME_ARRAY_LENGTH:this.overTimeArrayLength,RANDOM_REPEAT_COUNT:131072,USE_MAP:!0};for(let e of i)n[e]=!0;e.velocityScale>0&&(n.USE_PARTICLE_VELOCITY_SCALE=!0),e.trailInterval>0&&(this.isRibbon()?"ribbon"===e.trailType?n.USE_RIBBON_TRAILS=!0:n.USE_RIBBON_3D_TRAILS=!0:n.USE_PARTICLE_TRAILS=!0),e.randomizeFrames&&(n.USE_PARTICLE_RANDOMIZE_FRAMES=!0),t.includes("rotation")&&(this.isRibbon()?n.USE_RIBBON_ROTATION=!0:n.USE_PARTICLE_ROTATION=!0);let a="1.";if("taperout"===e.ribbonShape?a="1. - p":"taperin"===e.ribbonShape?a="p":"taper"===e.ribbonShape?a="2. * ( p < .5 ? p : 1. - p )":"="===e.ribbonShape[0]&&(a=e.ribbonShape.slice(1)),n.RIBBON_SHAPE_FUNCTION=a,e.source?n.PARTICLE_ORDER=2:n.PARTICLE_ORDER=Ot.indexOf(e.particleOrder),n.PARTICLE_TRAIL_ORDER=Ot.indexOf(e.particleOrder),Object.keys(n).filter(e=>this.material.defines[e]!==n[e]).length>0)if(this.isPlaying){const e=t.filter(e=>{const t=Ct[e];return t&&!this.material.defines[t]});console.error(`cannot add attributes (${e.join(",")}) at run-time`)}else this.material.defines=n,this.material.needsUpdate=!0},updateModelMesh(e){if(!e)return;this.modelBounds=new THREE.Box3,this.modelVertices;let t=0,i=0,n=0;const a=e=>{if(!e.geometry)return;let a=e.geometry.getAttribute("position");a&&3!==a.itemSize||(0==n?i+=a.array.length:(this.modelVertices.set(a.array,t),t+=a.array.length))};n=0,e.traverse(a),i>0&&(n=1,this.modelVertices=new Float32Array(i),e.traverse(a),jt(this.modelVertices,e.el.object3D.scale),this.modelBounds.setFromArray(this.modelVertices),this.updateBounds())},spawnParticles:function(){let e=new THREE.Vector3,t=new THREE.Quaternion,i=new THREE.Vector3,n=new THREE.Vector3,a=new THREE.Matrix4;return function(r){const s=this.data,o=this.count,l=this.data.spawnRate,c="burst"===s.spawnType,d=c?0:1/l,h=s.source&&null!=s.source.object3D,u=this.modelVertices&&this.modelVertices.length,m=this.isRibbon(),f=u||h;let p=this.geometry.getAttribute("vertexID"),g=this.geometry.getAttribute("position"),v=this.geometry.getAttribute("quaternion");h&&(this.el.object3D.updateMatrixWorld(),s.source.object3D.updateMatrixWorld(),a.getInverse(this.el.object3D.matrixWorld),a.multiply(s.source.object3D.matrixWorld),a.decompose(e,t,i),this.geometry.boundingSphere.center.copy(e));let y=this.nextID%o,b=0,E=y,x=this.nextID,T=zt;switch(s.modelFill){case"edge":T=Vt;break;case"vertex":T=Bt}for(;this.nextTime<r&&b<this.count;){u&&T(this.modelVertices,n);for(let i=0,a=m?2:1;i<a;i++)for(let i=0;i<this.trailCount;i++)x=this.nextID,u&&g.setXYZ(E,n.x,n.y,n.z),h&&(g.setXYZ(E,e.x,e.y,e.z),v.setXYZW(E,t.x,t.y,t.z,t.w)),p.setX(E,s.enabled?x:-1),E=(E+1)%o,b++,f?this.nextID++:this.nextID=E;this.nextTime+=d}if(b>0){const e=this.trailCount*(m?2:1);this.params[1]=Math.floor(x/e),c&&(this.nextTime+=this.lifeTime[1],s.trailInterval>0&&(this.nextTime+=this.trailLifeTime[1])),E<y&&(y=0,b=this.count),(h||u)&&(g.updateRange.offset=y,g.updateRange.count=b,g.needsUpdate=!0),h&&(v.updateRange.offset=y,v.updateRange.count=b,v.needsUpdate=!0),p.updateRange.offset=y,p.updateRange.count=b,p.needsUpdate=!0,this.nextID=this.nextID%131072}}}()});const jt=(e,t)=>{if(1!==t.x&&1!==t.y&&1!==t.z)for(let i=0,n=e.length;i<n;i+=3)e[i]*=t.x,e[i+1]*=t.y,e[i+2]*=t.z},zt=function(){let e=new THREE.Vector3,t=new THREE.Vector3;return function(i,n){let a,r,s=9*Math.floor(Math.random()*i.length/9);e.fromArray(i,s),t.fromArray(i,s+3),n.fromArray(i,s+6);do{a=Math.random(),r=Math.random()}while(a+r>1);t.sub(e).multiplyScalar(a),n.sub(e).multiplyScalar(r).add(t).add(e)}}(),Vt=function(){let e=new THREE.Vector3,t=new THREE.Vector3,i=new THREE.Vector3;return function(n,a){let r=9*Math.floor(Math.random()*n.length/9);e.fromArray(n,r),t.fromArray(n,r+3),i.fromArray(n,r+6);let s=Math.random();s>2/3?a.copy(e).sub(i).multiplyScalar(3*s-2).add(i):s>1/3?a.copy(i).sub(t).multiplyScalar(3*s-1).add(t):a.copy(t).sub(e).multiplyScalar(3*s).add(e)}}();function Bt(e,t){let i=3*Math.floor(Math.random()*e.length/3);t.fromArray(e,i)}const Ut="\n#include <common>\n// #include <color_pars_vertex>\n#include <fog_pars_vertex>\n// #include <morphtarget_pars_vertex>\n// #include <logdepthbuf_pars_vertex>\n// #include <clipping_planes_pars_vertex>\n\nattribute float vertexID;\n\n#if defined(USE_PARTICLE_SOURCE)\nattribute vec4 quaternion;\n#endif\n\nuniform vec4 params[PARAMS_LENGTH];\nuniform vec4 offset[2];\nuniform vec4 velocity[2];\nuniform vec4 acceleration[2];\nuniform vec4 angularVelocity[2];\nuniform vec4 angularAcceleration[2];\nuniform vec2 orbital[2];\nuniform vec4 colorOverTime[OVER_TIME_ARRAY_LENGTH];\nuniform vec2 rotationScaleOverTime[OVER_TIME_ARRAY_LENGTH];\nuniform vec4 textureFrames;\nuniform vec3 velocityScale;\nuniform vec4 destination[2];\n\nvarying vec4 vParticleColor;\nvarying vec2 vCosSinRotation;\nvarying vec2 vUv;\nvarying float vOverTimeRatio;\nvarying float vFrame;\n\nfloat VERTS_PER_RIBBON = 2.;\n\n// alternative random algorithm, used for the initial seed.  Provides a better\n// result than using rand()\nfloat pseudoRandom( const float seed )\n{\n  return mod( 1664525.*seed + 1013904223., 4294967296. )/4294967296.; // we don't have enough precision in 32-bit float, but results look ok\n}\n\n// each call to random will produce a different result by varying randI\nfloat randI = 0.;\nfloat random( const float seed )\n{\n  randI += 0.001;\n  return rand( vec2( seed, randI ));\n}\n\nvec3 randVec3Range( const vec3 range0, const vec3 range1, const float seed )\n{\n  vec3 lerps = vec3( random( seed ), random( seed ), random( seed ) );\n  return mix( range0, range1, lerps );\n}\n\nvec2 randVec2Range( const vec2 range0, const vec2 range1, const float seed )\n{\n  vec2 lerps = vec2( random( seed ), random( seed ) );\n  return mix( range0, range1, lerps );\n}\n\nfloat randFloatRange( const float range0, const float range1, const float seed )\n{\n  float lerps = random( seed );\n  return mix( range0, range1, lerps );\n}\n\n// theta.x is the angle in XY, theta.y is the angle in XZ\nvec3 radialToVec3( const float r, const vec2 theta )\n{\n  vec2 cosTheta = cos(theta);\n  vec2 sinTheta = sin(theta);\n  float rc = r * cosTheta.x;\n  float x = rc * cosTheta.y;\n  float y = r * sinTheta.x;\n  float z = rc * sinTheta.y;\n  return vec3( x, y, z );\n}\n\n// array lengths are stored in the first slot, followed by actual values from slot 1 onwards\n// colors are packed min,max,min,max,min,max,...\n// color is packed in xyz and opacity in w, and they may have different length arrays\n\nvec4 calcColorOverTime( const float r, const float seed )\n{\n  vec3 color = vec3(1.);\n  float opacity = 1.;\n\n#if defined(USE_PARTICLE_COLOR)\n  int colorN = int( colorOverTime[0].x );\n  if ( colorN == 1 )\n  {\n    color = randVec3Range( colorOverTime[1].xyz, colorOverTime[2].xyz, seed );\n  }\n  else if ( colorN > 1 )\n  {\n    float ck = r * ( float( colorN ) - 1. );\n    float ci = floor( ck );\n    int i = int( ci )*2 + 1;\n    vec3 sColor = randVec3Range( colorOverTime[i].xyz, colorOverTime[i + 1].xyz, seed );\n    vec3 eColor = randVec3Range( colorOverTime[i + 2].xyz, colorOverTime[i + 3].xyz, seed );\n    color = mix( sColor, eColor, ck - ci );\n  }\n#endif\n\n#if defined(USE_PARTICLE_OPACITY)\n  int opacityN = int( colorOverTime[0].y );\n  if ( opacityN == 1 )\n  {\n    opacity = randFloatRange( colorOverTime[1].w, colorOverTime[2].w, seed );\n  }\n  else if ( opacityN > 1 )\n  {\n    float ok = r * ( float( opacityN ) - 1. );\n    float oi = floor( ok );\n    int j = int( oi )*2 + 1;\n    float sOpacity = randFloatRange( colorOverTime[j].w, colorOverTime[j + 1].w, seed );\n    float eOpacity = randFloatRange( colorOverTime[j + 2].w, colorOverTime[j + 3].w, seed );\n    opacity = mix( sOpacity, eOpacity, ok - oi );\n  }\n#endif\n\n  return vec4( color, opacity );\n}\n\n// as per calcColorOverTime but euler rotation is packed in xyz and scale in w\n\nvec2 calcRotationScaleOverTime( const float r, const float seed )\n{\n  float rotation = 0.;\n  float scale = 1.;\n\n#if defined(USE_PARTICLE_ROTATION) || defined(USE_RIBBON_ROTATION)\n  int rotationN = int( rotationScaleOverTime[0].x );\n  if ( rotationN == 1 )\n  {\n    rotation = randFloatRange( rotationScaleOverTime[1].x, rotationScaleOverTime[2].x, seed );\n  }\n  else if ( rotationN > 1 )\n  {\n    float rk = r * ( float( rotationN ) - 1. );\n    float ri = floor( rk );\n    int i = int( ri )*2 + 1; // *2 because each range is 2 vectors, and +1 because the first vector is for the length info\n    float sRotation = randFloatRange( rotationScaleOverTime[i].x, rotationScaleOverTime[i + 1].x, seed );\n    float eRotation = randFloatRange( rotationScaleOverTime[i + 2].x, rotationScaleOverTime[i + 3].x, seed );\n    rotation = mix( sRotation, eRotation, rk - ri );\n  }\n#endif\n\n#if defined(USE_PARTICLE_SCALE)\n  int scaleN = int( rotationScaleOverTime[0].y );\n  if ( scaleN == 1 )\n  {\n    scale = randFloatRange( rotationScaleOverTime[1].y, rotationScaleOverTime[2].y, seed );\n  }\n  else if ( scaleN > 1 )\n  {\n    float sk = r * ( float( scaleN ) - 1. );\n    float si = floor( sk );\n    int j = int( si )*2 + 1; // *2 because each range is 2 vectors, and +1 because the first vector is for the length info\n    float sScale = randFloatRange( rotationScaleOverTime[j].y, rotationScaleOverTime[j + 1].y, seed );\n    float eScale = randFloatRange( rotationScaleOverTime[j + 2].y, rotationScaleOverTime[j + 3].y, seed );\n    scale = mix( sScale, eScale, sk - si );\n  }\n#endif\n\n  return vec2( rotation, scale );\n}\n\n// assumes euler order is YXZ (standard convention for AFrame)\nvec4 eulerToQuaternion( const vec3 euler )\n{\n  // from https://github.com/mrdoob/three.js/blob/master/src/math/Quaternion.js\n\n  vec3 c = cos( euler * .5 );\n  vec3 s = sin( euler * .5 );\n\n  return vec4(\n    s.x * c.y * c.z + c.x * s.y * s.z,\n    c.x * s.y * c.z - s.x * c.y * s.z,\n    c.x * c.y * s.z - s.x * s.y * c.z,\n    c.x * c.y * c.z + s.x * s.y * s.z\n  );\n}\n\n// from http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm\nvec4 axisAngleToQuaternion( const vec3 axis, const float angle ) \n{\n  return vec4( axis * sin( angle*.5 ), cos( angle*.5 ) );\n}\n\nvec3 applyQuaternion( const vec3 v, const vec4 q )\n{\n  return v + 2. * cross( q.xyz, cross( q.xyz, v ) + q.w * v );\n}\n\nvec3 displacement( const vec3 v, const vec3 a, const float t )\n{\n  return (v + 0.5 * a * t) * t;\n}\n\nfloat displacement1D( const float v, const float a, const float t )\n{\n  return (v + 0.5 * a * t) * t;\n}\n\nfloat ribbonShape( const float p )\n{\n  return RIBBON_SHAPE_FUNCTION;\n}\n\nvec3 particleMotion( const vec3 p, const vec3 v, const vec3 a, const vec3 av, const vec3 aa, const vec3 axis, const float ov, const float oa, const vec3 dest, const float weight, const float t )\n{\n  vec3 pos = p + displacement(v, a, t);\n\n#if defined(USE_PARTICLE_ANGULAR_VELOCITY) || defined(USE_PARTICLE_ANGULAR_ACCELERATION)\n  pos = applyQuaternion( pos, eulerToQuaternion( displacement(av, aa, t) ) );\n#endif\n\n#if defined(USE_PARTICLE_ORBITAL)\n  pos = applyQuaternion( pos, axisAngleToQuaternion( axis, displacement1D(ov, oa, t) ) );\n#endif\n\n#if defined(USE_PARTICLE_SOURCE)\n  pos = applyQuaternion( pos, quaternion );\n#endif\n\npos += position;\n\n#if defined(USE_PARTICLE_DESTINATION)\n  pos = mix( pos, dest, weight );\n#endif\n\n  return pos;\n}\n\nvec2 toScreen( const vec4 clipSpacePos )\n{\n  return clipSpacePos.xy / clipSpacePos.w;\n}\n\nvoid main() {\n\n  float time = params[0].x;\n  float cpuID = params[0].y;\n  float radialTypeX = params[0].z;\n  float radialTypeY = params[4].w;\n  float duration = params[0].w;\n  float spawnType = params[1].x;\n  float spawnRate = params[1].y;\n  float baseSeed = params[1].z;\n  float vertexCount = params[1].w;\n  float direction = params[2].z; // 0 is forward, 1 is backward  \n  float trailInterval = params[3].x;\n  float particleCount = params[3].y;\n  float trailCount = params[3].z;\n  float maxParticleLifeTime = angularVelocity[1].w; // lifeTime packed into w component of angularVelocity\n  float maxTrailLifeTime = angularAcceleration[1].w; // trailLifeTime packed into angularAcceleration.w\n  float particleLoopTime = particleCount / spawnRate;\n  float motionAge = -1.; // used to determine the age for particle movement\n\n#if defined(USE_PARTICLE_TRAILS) || defined(USE_RIBBON_TRAILS) || defined(USE_RIBBON_3D_TRAILS)\n  float maxAge = maxParticleLifeTime + maxTrailLifeTime;\n#else\n  float maxAge = maxParticleLifeTime;\n#endif\n\n  // the CPU manages IDs if it sets the position or disables particles, otherwise cpuID is -1\n  float particleID0 = cpuID > -EPSILON ? cpuID : floor( mod( time, particleLoopTime ) * spawnRate ); // this will lose precision eventually\n\n  vOverTimeRatio = -1.; // the vOverTimeRatio will be used for the lerps on over-time attributes\n\n  // particles are either emitted in a burst (spawnType == 0) or spread evenly\n  // throughout 0..particleLoopTime (spawnType == 1).  We calculate the ID of the last spawned particle particleID0 \n  // for this frame, any vertex IDs after particleID0 are assumed to belong to the previous loop\n\n  // vertex 0 = trail0 of particle0, vertex 1 = trail1 of particle0, ..., vertex k = trail0 of particle1, ...\n#if defined(USE_RIBBON_TRAILS) || defined(USE_RIBBON_3D_TRAILS)\n  float rawParticleID = floor( vertexID / VERTS_PER_RIBBON / trailCount );\n#else\n  float rawParticleID = floor( vertexID / trailCount );\n#endif\n\n  float particleLoop = floor( time / particleLoopTime );\n\n#if defined(USE_PARTICLE_SOURCE)\n  // find particleID relative to the last loop\n  float particleID = rawParticleID - floor( particleID0 / particleCount ) * particleCount;\n#else // defined(USE_PARTICLE_SOURCE)\n\n#if PARTICLE_ORDER == 0\n  float particleID = particleID0 - (particleCount - 1. - rawParticleID); // newest last\n#elif PARTICLE_ORDER == 1\n  float particleID = particleID0 - rawParticleID; // oldest last\n#else\n  float particleID = rawParticleID > particleID0 ? rawParticleID - particleCount : rawParticleID; // cyclic (any)\n#endif\n\n#endif // defined(USE_PARTICLE_SOURCE)\n\n  // for burst mode we use the rawParticleID, because the concept of particleID0 is irrelevant\n  particleID = mix( rawParticleID, particleID, spawnType ); \n\n  float particleStartTime = particleLoop * particleLoopTime + particleID / spawnRate * spawnType;\n\n  // we use the id as a seed for the randomizer, but because the IDs are fixed in \n  // the range 0..particleCount we calculate a virtual ID by taking into account\n  // the number of loops that have occurred (note, particles from the previous \n  // loop will have a negative particleID). We use the modoulo of the RANDOM_REPEAT_COUNT \n  // to ensure that the virtualID doesn't exceed the floating point precision\n\n  float virtualID = mod( particleID + particleLoop * particleCount, float( RANDOM_REPEAT_COUNT ) );\n  float seed = pseudoRandom( virtualID*baseSeed*110. );\n\n  float particleLifeTime = randFloatRange( angularVelocity[0].w, angularVelocity[1].w, seed );\n\n  float particleAge = time - particleStartTime;\n  particleAge = particleAge + direction * ( particleLoopTime - 2. * particleAge );\n\n  // don't show particles that would be emitted after the duration\n  if ( duration > 0. && time - particleAge >= duration ) \n  {\n    particleAge = -1.;\n  } \n\n  // always calculate the trailLifeTime, even if we don't use it, so the particles\n  // with the same seed give consistent results\n  float trailLifeTime = randFloatRange( angularAcceleration[0].w, angularAcceleration[1].w, seed );\n\n#if defined(USE_PARTICLE_TRAILS)\n\n  // +1 beceause we show both the lead particle and the first trail at the start\n  // we cap the particleAge to ensure it never goes past the particleLifeTime\n  float cappedParticleAge = min( particleLifeTime - trailInterval, particleAge );\n  float trailID0 = floor( cappedParticleAge / trailInterval ) + 1.;\n  float rawTrailID = mod( vertexID, trailCount );\n\n#if PARTICLE_TRAIL_ORDER == 0\n  float trailID = trailID0 - ( trailCount - 1. - rawTrailID ); // newest last\n#elif PARTICLE_TRAIL_ORDER == 1\n  float trailID = trailID0 - rawTrailID; // oldest last\n#else\n  float trailID = floor( trailID0 / trailCount ) * trailCount;\n  trailID += rawTrailID > mod( trailID0, trailCount ) ? rawTrailID - trailCount : rawTrailID; // cyclic (any order)\n#endif\n\n  float trailStartAge = trailID * trailInterval;\n  \n  if (particleAge > -EPSILON && trailStartAge > -EPSILON && trailStartAge < particleLifeTime + EPSILON)\n  {\n    if (particleAge < trailStartAge)\n    {\n      motionAge = particleAge;\n      vOverTimeRatio = 0.;\n    }\n    else if (particleAge < trailStartAge + trailLifeTime)\n    {\n      motionAge = trailStartAge;\n      vOverTimeRatio = (particleAge - trailStartAge)/trailLifeTime;\n    }\n  }\n\n#elif defined(USE_RIBBON_TRAILS) || defined(USE_RIBBON_3D_TRAILS)\n\n  // +1 to the trailID0 because the ribbon needs two elements to start\n  // we cap the particleAge to ensure it never goes past the particleLifeTime\n  float cappedParticleAge = min( particleLifeTime - trailInterval, particleAge );\n  float trailID0 = floor( cappedParticleAge / trailInterval ) + 1.;\n  float rawTrailID = floor( mod( vertexID / VERTS_PER_RIBBON, trailCount ) );\n  float trailID = max( 0., trailID0 - ( trailCount - 1. - rawTrailID ) ); // newest last\n\n  float trailStartAge = trailID * trailInterval;\n\n  if (particleAge > -EPSILON && trailStartAge > -EPSILON && trailStartAge < particleLifeTime + EPSILON)\n  {\n    // motionAge will typically be the trailStartAge, but the lead particle will be the \n    // cappedParticleAge, and the last particle will be the particleAge - trailLifeTime\n\n    motionAge = min( cappedParticleAge, max( particleAge - trailLifeTime, trailStartAge ) );\n    vOverTimeRatio = ( particleAge - motionAge ) / trailLifeTime;\n  }\n  else\n  {\n    motionAge = particleLifeTime;\n    vOverTimeRatio = 1.0;\n  }\n\n#else // defined(USE_PARTICLE_TRAILS) || defined(USE_RIBBON_TRAILS) || defined(USE_RIBBON_3D_TRAILS)\n\n  motionAge = particleAge;\n  vOverTimeRatio = particleAge/particleLifeTime;\n\n#endif // defined(USE_PARTICLE_TRAILS) || defined(USE_RIBBON_TRAILS) || defined(USE_RIBBON_3D_TRAILS)\n\n  // these checks were around large blocks of code above, but this caused instability\n  // in some of the particle systems, so instead we do all of the work, then cancel \n  // it out here\n  if ( particleStartTime < 0. || vertexID < 0. )\n  {\n    vOverTimeRatio = -1.;\n  }\n\n#if defined(USE_PARTICLE_DRAG)\n  // simulate drag by blending the motionAge to (1-.5*drag)*particleLifeTime\n  float drag = params[2].w;\n  motionAge = mix( .5*drag*vOverTimeRatio, 1. - .5*drag, vOverTimeRatio ) * particleLifeTime;\n#endif\n\n  vec3 p = vec3(0.); // position\n  vec3 v = vec3(0.); // velocity\n  vec3 a = vec3(0.); // acceleration\n  vec3 av = vec3(0.); // angular velocity\n  vec3 aa = vec3(0.); // angular acceleration\n  vec3 axis = vec3( 1., 0., 0. ); // axis of orbital motion\n  float ov = 0.; // orbital velocity\n  float oa = 0.; // orbital acceleration\n  vec3 dest = vec3(0.); // destination position\n  float destWeight = 0.; // destination weighting\n\n#if defined(USE_PARTICLE_OFFSET)\n  p = randVec3Range( offset[0].xyz, offset[1].xyz, seed );\n#endif\n\n#if defined(USE_PARTICLE_VELOCITY)\n  v = randVec3Range( velocity[0].xyz, velocity[1].xyz, seed );\n#endif\n\n#if defined(USE_PARTICLE_ACCELERATION)\n  a = randVec3Range( acceleration[0].xyz, acceleration[1].xyz, seed );\n#endif\n\n#if defined(USE_PARTICLE_RADIAL_OFFSET) || defined(USE_PARTICLE_RADIAL_VELOCITY) || defined(USE_PARTICLE_RADIAL_ACCELERATION)\n  vec2 ANGLE_RANGE[2];\n  vec2 radialDir = vec2( radialTypeX, radialTypeY );\n  ANGLE_RANGE[0] = vec2( 0., 0. ) * radialDir;\n  ANGLE_RANGE[1] = vec2( 2.*PI, 2.*PI ) * radialDir;\n\n  vec2 theta = randVec2Range( ANGLE_RANGE[0], ANGLE_RANGE[1], seed );\n#endif\n\n#if defined(USE_PARTICLE_RADIAL_OFFSET)\n  float pr = randFloatRange( offset[0].w, offset[1].w, seed );\n  vec3 p2 = radialToVec3( pr, theta );\n  p += p2;\n#endif\n\n#if defined(USE_PARTICLE_RADIAL_VELOCITY)\n  float vr = randFloatRange( velocity[0].w, velocity[1].w, seed );\n  vec3 v2 = radialToVec3( vr, theta );\n  v += v2;\n#endif\n\n#if defined(USE_PARTICLE_RADIAL_ACCELERATION)\n  float ar = randFloatRange( acceleration[0].w, acceleration[1].w, seed );\n  vec3 a2 = radialToVec3( ar, theta );\n  a += a2;\n#endif\n\n#if defined(USE_PARTICLE_ANGULAR_VELOCITY)\n  av = randVec3Range( angularVelocity[0].xyz, angularVelocity[1].xyz, seed );\n#endif\n\n#if defined(USE_PARTICLE_ANGULAR_ACCELERATION)\n  aa = randVec3Range( angularAcceleration[0].xyz, angularAcceleration[1].xyz, seed );\n#endif\n\n#if defined(USE_PARTICLE_ORBITAL)\n  if ( length(p) > EPSILON ) {\n    ov = randFloatRange( orbital[0].x, orbital[1].x, seed );\n    float oa = randFloatRange( orbital[0].y, orbital[1].y, seed );\n    float angle = displacement1D(ov, oa, motionAge);\n\n    vec3 randomOribit = vec3( random( seed ), random( seed ), random( seed ) ); // should never equal p or 0,0,0\n    axis = normalize( cross( normalize( p ), normalize( randomOribit ) ) );\n  }\n#endif\n\n#if defined(USE_PARTICLE_DESTINATION)\n  destWeight = randFloatRange( destination[0].w, destination[1].w, seed );\n  dest = randVec3Range( destination[0].xyz, destination[1].xyz, seed );\n#endif\n\n  vec3 transformed = particleMotion( p, v, a, av, aa, axis, ov, oa, dest, motionAge/particleLifeTime*destWeight, motionAge );\n\n  vec2 rotScale = calcRotationScaleOverTime( vOverTimeRatio, seed );\n  float particleScale = rotScale.y;\n  float c = cos( rotScale.x );\n  float s = sin( rotScale.x );\n\n  vParticleColor = calcColorOverTime( vOverTimeRatio, seed ); // rgba format\n\n#if defined(USE_PARTICLE_VELOCITY_SCALE)\n  // We repeat all of the displacement calculations at motionAge + a small amount (velocityScaleDelta).\n  // We convert the current position and the future position in screen space and determine\n  // the screen space velocity. VelocityScaleDelta is reasonably small to give better\n  // results for the angular and orbital displacement, and when drag is applied the effective\n  // velocity will tend to 0 as the vOverTimeRatio increases\n\n  float velocityScaleDelta = .02;\n\n#if defined(USE_PARTICLE_DRAG)\n  float futureT = motionAge + velocityScaleDelta*mix(1., 1. - drag, vOverTimeRatio);\n#else\n  float futureT = motionAge + velocityScaleDelta;\n#endif\n\n  vec4 pos2D = projectionMatrix * modelViewMatrix * vec4( transformed, 1. );\n\n  // use min(1) to ensure the particle stops at the destination position\n  vec3 transformedFuture = particleMotion( p, v, a, av, aa, axis, ov, oa, dest, min( 1., futureT/particleLifeTime )*destWeight, futureT );\n\n  vec4 pos2DFuture = projectionMatrix * modelViewMatrix * vec4( transformedFuture, 1. );\n\n  vec2 screen = pos2DFuture.xy / pos2DFuture.z - pos2D.xy / pos2D.z; // TODO divide by 0?\n  screen /= velocityScaleDelta; // gives screen units per second\n\n  float lenScreen = length( screen );\n  vec2 sinCos = vec2(screen.x, screen.y)/max( EPSILON, lenScreen); // 0 degrees is y == 1, x == 0\n  float c2 = c*sinCos.y + s*sinCos.x; // cos(a-b)\n  float s2 = s*sinCos.y - c*sinCos.x; // sin(a-b)\n\n  // replace rotation with our new rotation\n  c = c2;\n  s = s2;\n\n  // rescale the particle length by the z depth, because perspective will be applied later\n  float screenScale = clamp( lenScreen * pos2D.z * velocityScale.x, velocityScale.y, velocityScale.z );\n\n  particleScale *= screenScale;\n\n#endif // defined(USE_PARTICLE_VELOCITY_SCALE)\n\n  vCosSinRotation = vec2( c, s );\n\n  // #include <color_vertex>\n  // #include <begin_vertex> replaced by code above\n  // #include <morphtarget_vertex>\n  // #include <project_vertex> replaced below\n\n#if defined(USE_RIBBON_3D_TRAILS)\n  float ribbonID = mod( vertexID, VERTS_PER_RIBBON );\n  \n  {\n    float nextT = motionAge + trailInterval;\n    float ribbonWidth = params[4].x * ribbonShape( vOverTimeRatio );\n\n    vec3 nextPosition = particleMotion( p, v, a, av, aa, axis, ov, oa, dest, min( 1., nextT/particleLifeTime )*destWeight, nextT );\n    vec3 dir = nextPosition - transformed;\n    float dirLen = length( dir );\n\n    vec3 normal = dir;\n    vec3 up = vec3( 0., c, -s ); // rotation in YZ\n    if ( dirLen > EPSILON && abs( dot( dir, up ) ) < dirLen * 0.99 ) {\n      normal = normalize( cross( up, dir ) );\n    }\n\n    transformed += ribbonWidth * normal * ( 0.5 - ribbonID );  // +normal for ribbonID 0, -normal for ribbonID 1\n  }\n#endif\n\n  vec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );\n  gl_Position = projectionMatrix * mvPosition;\n\n  float usePerspective = params[2].y;\n\n#if defined(USE_RIBBON_TRAILS)\n  float ribbonID = mod( vertexID, VERTS_PER_RIBBON );\n  \n  {\n    mat4 m = projectionMatrix * modelViewMatrix;\n    vec2 curr = toScreen( gl_Position );\n\n    float nextT = motionAge + trailInterval;\n    vec3 nextPosition = particleMotion( p, v, a, av, aa, axis, ov, oa, dest, min( 1., nextT/particleLifeTime )*destWeight, nextT );\n    vec2 next2D = toScreen( m * vec4( nextPosition, 1. ) ) - curr;\n\n    vec2 dir = normalize( next2D );\n    vec2 normal = vec2( -dir.y, dir.x );\n\n    float ribbonWidth = params[4].x * ribbonShape( vOverTimeRatio );\n    float halfWidth = .5 * ribbonWidth * mix( 1., 1. / - mvPosition.z, usePerspective );\n  \n    gl_Position.xy += halfWidth * normal * ( 1. - ribbonID * 2. ); // +normal for ribbonID 0, -normal for ribbonID 1\n  }\n#endif\n\n#if defined(USE_PARTICLE_SCREEN_DEPTH_OFFSET)\n  float screenDepthOffset = params[3].w;\n\n#if defined(USE_PARTICLE_TRAILS) || defined(USE_RIBBON_TRAILS) || defined(USE_RIBBON_3D_TRAILS)\n  // multiply trailCount by 2 because trailID ranges from [-trailCount, trailCount]\n  gl_Position.z -= (particleID*trailCount*2. + trailID - trailID0)*gl_Position.w*screenDepthOffset/vertexCount;\n#else\n  gl_Position.z -= particleID*gl_Position.w*screenDepthOffset/vertexCount;\n#endif\n\n#endif // defined(USE_PARTICLE_SCREEN_DEPTH_OFFSET)\n\n// vFrame is an int, but we must pass it as a float, so add .5 now and floor() in the\n// fragment shader to ensure there is no rounding error\n#if defined(USE_PARTICLE_RANDOMIZE_FRAMES)\n  vFrame = floor ( random( seed ) * textureFrames.z ) + .5;\n#else\n  float textureCount = textureFrames.z;\n  float textureLoop = textureFrames.w;\n\n  vFrame = floor( mod( vOverTimeRatio * textureCount * textureLoop, textureCount ) ) + .5;\n#endif\n\n#if !defined(USE_RIBBON_TRAILS) && !defined(USE_RIBBON_3D_TRAILS)\n  float particleSize = params[2].x;\n\n  gl_PointSize = particleSize * particleScale * mix( 1., 1. / - mvPosition.z, usePerspective );\n#endif\n\n  // #include <logdepthbuf_vertex>\n  // #include <clipping_planes_vertex>\n  // #include <worldpos_vertex>\n  #include <fog_vertex>\n\n#if defined(USE_RIBBON_TRAILS) || defined(USE_RIBBON_3D_TRAILS)\n  float ribbonUVMultiplier = params[4].y;\n  float ribbonUVType = params[4].z;\n\n  vUv = vec2( mix( 1. - vOverTimeRatio, motionAge/trailInterval, ribbonUVType ) * ribbonUVMultiplier, 1. - ribbonID );\n#endif\n}",Nt="\n#include <common>\n#include <packing>\n// #include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n// #include <logdepthbuf_pars_fragment>\n// #include <clipping_planes_pars_fragment>\n\nuniform vec4 textureFrames;\nuniform vec3 emitterColor;\n\nvarying vec4 vParticleColor;\nvarying vec2 vCosSinRotation;\nvarying vec2 vUv;\nvarying float vOverTimeRatio;\nvarying float vFrame;\n\nvoid main() {\n  if ( vOverTimeRatio < 0. || vOverTimeRatio > 1. ) {\n    discard;\n  }\n\n  #include <clipping_planes_fragment>\n\n  vec3 outgoingLight = vec3( 0. );\n  vec4 diffuseColor = vec4( emitterColor, 1. );\n  mat3 uvTransform = mat3( 1. );\n\n#if defined(USE_PARTICLE_ROTATION) || defined(USE_PARTICLE_FRAMES) || defined(USE_PARTICLE_VELOCITY_SCALE)\n  {\n    vec2 invTextureFrame = 1. / textureFrames.xy;\n    float textureCount = textureFrames.z;\n    float textureLoop = textureFrames.w;\n\n    float frame = floor(vFrame);\n    float c = vCosSinRotation.x;\n    float s = vCosSinRotation.y;\n    float tx = mod( frame, textureFrames.x ) * invTextureFrame.x;\n    float ty = (textureFrames.y - 1. - floor( frame * invTextureFrame.x )) * invTextureFrame.y; // assumes textures are flipped on y\n    float sx = invTextureFrame.x;\n    float sy = invTextureFrame.y;\n    float cx = tx + invTextureFrame.x * .5;\n    float cy = ty + invTextureFrame.y * .5;\n  \n    uvTransform[0][0] = sx * c;\n    uvTransform[0][1] = -sx * s;\n    uvTransform[1][0] = sy * s;\n    uvTransform[1][1] = sy * c;\n    uvTransform[2][0] = c * tx + s * ty - ( c * cx + s * cy ) + cx;\n    uvTransform[2][1] = -s * tx + c * ty - ( -s * cx + c * cy ) + cy;\n  }\n#endif // defined(USE_PARTICLE_ROTATION) || defined(USE_PARTICLE_FRAMES) || defined(USE_PARTICLE_VELOCITY_SCALE)\n\n  // #include <logdepthbuf_fragment>\n  // #include <map_particle_fragment>\n  // #include <color_fragment>\n\n#ifdef USE_MAP\n\n#if defined(USE_RIBBON_TRAILS) || defined(USE_RIBBON_3D_TRAILS)\n  vec2 uv = ( uvTransform * vec3( vUv, 1. ) ).xy;\n#else\n  vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1. ) ).xy;\n#endif\n\n  vec4 mapTexel = texture2D( map, uv );\n  diffuseColor *= mapTexelToLinear( mapTexel );\n#endif // USE_MAP\n\n  #include <alphatest_fragment>\n\n  diffuseColor *= vParticleColor;\n  outgoingLight = diffuseColor.rgb;\n\n  gl_FragColor = diffuseColor;\n\n  // #include <premultiplied_alpha_fragment>\n  // #include <tonemapping_fragment>\n  // #include <encodings_fragment>\n  #include <fog_fragment>\n}";AFRAME.registerComponent("store",{schema:{type:{default:"temporary",oneOf:["temporary","local","session"],parse:function(e){return"string"==typeof e?e.toLowerCase():e}}},multiple:!0,updateSchema(e){"object"!=typeof e&&console.error(`invalid properties, expected format <property>:<value>; '${e}'`);const t=AFRAME.components[this.name].schema;let i={};for(let n in e)n in t||(i[n]={type:"string"});Object.keys(i).length>0&&this.extendSchema(i)},init(){this.binds=[],this.firstTime=!0,this.loadStorage(),this.el.emit("store-loaded",{store:this,name:this.attrName})},update(e){const t=this.data;for(let i of this.binds){const n=i.key;t[n]!==e[n]&&U(i.target,i.prop,t[n])}this.firstTime||this.saveStorage(),this.firstTime=!1},loadStorage(){const e=AFRAME.components[this.name].schema,t=this.data;if("temporary"!==t.type)for(let i in this.data)if(!(i in e)){let e=null;"local"===t.type?e=localStorage.getItem(i):"session"===t.type&&(e=sessionStorage.getItem(i)),null!==e&&(t[i]=e)}},saveStorage(){const e=AFRAME.components[this.name].schema,t=this.data;if("temporary"!==t.type)for(let i in this.data)i in e||("local"===t.type?localStorage.setItem(i,t[i]):"session"===t.type&&sessionStorage.setItem(i,t[i]))},bind(e,t,i){this.binds.find(e=>e.target===t&&e.prop===i)&&$(`bind '${t}.${i}' already exists`),this.binds.push({key:e,target:t,prop:i})},unbind(e,t,i){const n=this.binds.findIndex(n=>n.target===t&&n.prop===i&&n.key===e);n>=0?this.binds.splice(n,1):$(`unable to find bind '${t}.${i}' for store key '${e}'`)}}),AFRAME.registerComponent("store-bind",{schema:{store:{type:"selector"},from:{default:""},to:{default:""}},multiple:!0,init(){this.onStoreLoaded=this.onStoreLoaded.bind(this)},remove(){const e=this.data;this.removeListeners(e.store),this.unbind(e.store,e.from,e.to)},update(e){const t=this.data;this.unbind(e.store,e.from,e.to),this.bind(t.store,t.from,t.to),e.store!==t.store&&(this.removeListeners(e.store),this.addListeners(t.store))},addListeners(e){e&&e.addEventListener("store-loaded",this.onStoreLoaded)},removeListeners(e){e&&e.removeEventListener("store-loaded",this.onStoreLoaded)},onStoreLoaded(e){const t=this.data;this.bind(t.store,t.from,t.to)},bind(e,t,i){if(e&&t&&i){const[n,a]=t.split("."),r=e.components[n];r&&"bind"in r&&r.bind(a,this.el,i)}},unbind(e,t,i){if(e&&t&&i){const[n,a]=t.split("."),r=e.components[n];r&&"unbind"in r&&r.unbind(a,this.el,i)}}});function qt(e,t){for(let i=0;i<t.length;i++)e.includes(t[i])||e.push(t[i]);return e}AFRAME.registerComponent("svg-ui",{schema:{template:{default:""},clickSelectors:{default:""},hoverSelectors:{default:""},touchSelectors:{default:""},touchDistance:{default:.07},resolution:{type:"vec2",default:{x:512,y:512}},touchDeadZone:{default:.5},bubbles:{default:!1},debug:{default:!1},enabled:{default:!0},useHoverClass:{default:!1},interactIfOccluded:{default:!1}},updateSchema(e){"object"!=typeof e&&Q(this,`invalid properties, expected format <property>:<value>; '${e}'`);const t=AFRAME.components[this.name].schema;let i={};for(let n in e)n in t||(i[n]={type:"string"});Object.keys(i).length>0&&this.extendSchema(i)},init(){this.hasUIListeners=!1,this.raycasters=[],this.hoverEls=[],this.touchEls=new Map,this.hasPendingUpdateSVGTexture=!1,this.onSetObject3D=this.onSetObject3D.bind(this),this.onRaycasterIntersected=this.onRaycasterIntersected.bind(this),this.onRaycasterIntersectedCleared=this.onRaycasterIntersectedCleared.bind(this),this.onClick=this.onClick.bind(this),this.el.addEventListener("setobject3d",this.onSetObject3D),this.createSVGTexture()},remove(){this.el.removeEventListener("setobject3d",this.onSetObject3D),this.proxyEl&&this.proxyEl.parent&&this.proxyEl.parent.removeChild(this.proxyEl)},play(){this.addUIListeners()},pause(){this.removeUIListeners()},update(e){const t=this.data;e.template!==t.template?Y(t.template,"<svg",e=>{this.templateContent=e,(e=>"string"==typeof e&&/\<svg/.test(e))(e)||$(this,`template '${t.template}' doesn't look like SVG: ${e}`),this.createSVGFunction(e),this.requestUpdateSVGTexture()}):this.templateContent&&(Object.keys(e)!==Object.keys(t)&&this.createSVGFunction(this.templateContent),this.requestUpdateSVGTexture()),this.addUIListeners()},tick(){this.hasPendingUpdateSVGTexture&&this.updateSVGTexture(),this.data.enabled&&this.raycasters&&this.proxySVGEl&&this.updateHoverAndTouch()},setTemplate(e){this.templateContent=e,this.requestUpdateSVGTexture()},isSelectable(){const e=this.data;return e.clickSelectors||e.hoverSelectors||e.touchSelectors},addUIListeners(){!this.hasUIListeners&&this.isSelectable()&&(this.el.addEventListener("raycaster-intersected",this.onRaycasterIntersected),this.el.addEventListener("raycaster-intersected-cleared",this.onRaycasterIntersectedCleared),this.el.addEventListener("click",this.onClick),this.hasUIListeners=!1)},removeUIListeners(){this.hasUIListeners&&(this.el.removeEventListener("raycaster-intersected",this.onRaycasterIntersected),this.el.removeEventListener("raycaster-intersected-cleared",this.onRaycasterIntersectedCleared),this.el.removeEventListener("click",this.onClick),this.hasUIListeners=!1)},createSVGTexture(){const e=this.data;this.imageEl=document.createElement("img"),this.imageEl.width=e.resolution.x,this.imageEl.height=e.resolution.y,this.imageEl.isReady=!0;const t=this.texture=new THREE.Texture(this.imageEl);this.imageEl.onload=(()=>{t.needsUpdate=!0}),this.imageEl.onerror=(()=>{Q(this,"invalid svg",this.lastContent),t.image.isReady=!0}),t.onUpdate=(()=>{t.image.isReady=!0}),this.requestUpdateSVGTexture(),this.showSVGTextureOnMesh()},requestUpdateSVGTexture(){this.hasPendingUpdateSVGTexture=!0},updateSVGTexture(){if(this.templateContent){let e=this.processTemplate(this.templateContent);if(this.data.debug&&console.log(e),this.isSelectable()&&(this.proxyEl||(this.proxyEl=document.createElement("div"),this.proxyEl.style.position="absolute",this.proxyEl.style.top="0",this.proxyEl.style.left="0",this.proxyEl.style.zIndex="-999",this.el.appendChild(this.proxyEl)),this.proxyEl.innerHTML=e,this.proxySVGEl=this.proxyEl.children[0],this.proxySVGEl.setAttribute("width",256),this.proxySVGEl.setAttribute("height",256),this.data.useHoverClass)){for(let e of this.hoverEls)if(e.id){const t=this.proxyEl.querySelector("#"+e.id);t&&t.classList.add("hover")}else $(this,`an element (${z(e)}) matching the hoverSelectors (${this.data.hoverSelectors}), does not have an id`);e=this.proxyEl.innerHTML}this.pendingContent=e,this.updatePendingContent()}this.hasPendingUpdateSVGTexture=!1},updatePendingContent(){this.imageEl.isReady&&this.pendingContent&&(this.imageEl.src="data:image/svg+xml;utf8,"+this.pendingContent,this.imageEl.isReady=!1,this.lastContent=this.pendingContent,this.pendingContent=void 0)},showSVGTextureOnMesh(){const e=this.el.getObject3D("mesh");if(e&&!Array.isArray(e.material)){e.material.map=this.texture;const t=e.material.color;t&&(t.r<.95||t.g<.95||t.b<.95)&&$(this,"svg-ui material color is not white, it may be difficult to see the ui")}},createSVGFunction(e){const t=Object.keys(this.data).concat("return `"+e+"`");this.svgTextFunction=new Function(...t)},processTemplate(e){if(this.svgTextFunction){return this.svgTextFunction(...Object.values(this.data)).replace(/%/g,"%25").replace(/#/g,"%23")}},calcViewXYFomUV:function(){let e=new THREE.Vector2;return function(t){e.copy(t),this.texture.transformUv(e);const i=this.proxySVGEl.viewBox.animVal;return{x:i.width*e.x+i.x,y:i.height*e.y+i.y}}}(),calcElementsFromUV:function(){let e=new THREE.Vector2;return function(t,i,n){e.copy(t),this.texture.transformUv(e);const a=256*e.x,r=256*e.y;let s=document.elementsFromPoint(a,r).filter(e=>(function(e,t){let i=e;for(;i&&t!==i;)i=i.parentNode;return!!i})(e,this.proxySVGEl));return n&&console.log("hitElements",a,r,s),i&&(s=s.map(e=>(function(e,t){let i=e;for(;i&&"matches"in i&&!i.matches(t);)i=i.parentNode;return i&&"matches"in i?i:void 0})(e,i)).filter(e=>e),n&&console.log("selectedElements",s)),s}}(),updateHoverAndTouch(){let e=[];const t=this.data.interactIfOccluded,i=this.el;function n(e){const n=e.components.raycaster.intersections;return t?n.find(e=>e.object.el===i):n.length>0?n[0].object.el===e?n[1]:n[0]:void 0}for(let t of this.raycasters){const i=n(t);if(i.object.el===this.el){let n=[],a=!1;const r=this.touchEls.get(t);i&&(i.svg=this.calcViewXYFomUV(i.uv),r.lastMove&&(a=Math.hypot(r.lastMove.x-i.svg.x,r.lastMove.y-i.svg.y)>this.data.touchDeadZone),qt(e,this.calcElementsFromUV(i.uv,this.data.hoverSelectors,!1)),i.distance<this.data.touchDistance&&(n=this.calcElementsFromUV(i.uv,this.data.touchSelectors,this.data.debug)));const s=n.map(e=>e.id);for(let e of r.elements)n.find(t=>t.id===e.id)||this.sendEvent("svg-ui-touchend",{uiTarget:e,intersection:i,touches:s},t);for(let e of n)r.elements.find(t=>t.id===e.id)?a&&this.sendEvent("svg-ui-touchmove",{uiTarget:e,intersection:i,touches:s},t):this.sendEvent("svg-ui-touchstart",{uiTarget:e,intersection:i,touches:s},t);!a&&r.lastMove||(r.lastMove=i.svg),r.elements=n}}const a=e.map(e=>e.id);let r=!1;for(let t of this.hoverEls)e.find(e=>e.id===t.id)||(this.sendEvent("svg-ui-hoverend",{uiTarget:t,hovers:a}),r=!0);for(let t of e)this.hoverEls.find(e=>e.id===t.id)||(this.sendEvent("svg-ui-hoverstart",{uiTarget:t,hovers:a}),r=!0);this.data.useHoverClass&&r&&this.requestUpdateSVGTexture(),this.hoverEls=e},sendEvent(e,t,i){this.data.debug&&console.log("emit",e,t,i),this.el.emit(e,t,this.data.bubbles),i&&i.emit(e,t,this.data.bubbles)},onSetObject3D(e){this.showSVGTextureOnMesh()},onRaycasterIntersected(e){this.data.debug&&console.log("onRaycasterIntersected",this.el.id);const t=e.detail.el;this.touchEls.set(t,{elements:[]}),this.raycasters.push(t)},onRaycasterIntersectedCleared(e){this.data.debug&&console.log("onRaycasterIntersectedCleared",this.el.id);const t=e.detail.el;this.raycasters.splice(this.raycasters.indexOf(t),1),this.touchEls.delete(t)},onClick(e){const t=this.data;if(t.debug&&console.log("click",this.el.id),e.detail.intersection&&t.enabled){let i=this.calcElementsFromUV(e.detail.intersection.uv,t.clickSelectors,t.debug);const n={...e.detail.intersection,svg:this.calcViewXYFomUV(e.detail.intersection.uv)};i&&i.length>0&&this.sendEvent("svg-ui-click",{uiTarget:i[0],intersection:n})}}}),AFRAME.registerComponent("texture-updater",{schema:{maps:{default:"map"},meshName:{default:"mesh"}},update(){this.maps=this.data.maps.split(",").map(e=>e.trim())},tick(){const e=this.el.getObject3D(this.data.meshName);if(e&&e.material)for(let t of this.maps)if(Array.isArray(e.material))for(let i of e.material)i[t]&&"object"==typeof i[t]&&(i[t].needsUpdate=!0);else e.material[t]&&"object"==typeof e.material[t]&&(e.material[t].needsUpdate=!0)}}),AFRAME.registerComponent("timer-emit",{schema:{src:{type:"selector"},target:{default:""},targetScope:{default:"document",oneOf:["document","self","parent"]},stopOnPause:{default:!0}},multiple:!0,init(){this.sendEvents=this.sendEvents.bind(this),this.mediaEl=void 0,this.restartMedia=!1,this.clockStartTime=Date.now(),this.targets=[]},remove(){this.removeListeners()},updateSchema(e){"object"!=typeof e&&console.error(`invalid properties, expected format <property>:<value>; '${e}'`);const t=AFRAME.components["timer-emit"].schema;let i={};for(let n in e)n in t||(i[n]={type:"string"});Object.keys(i).length>0&&this.extendSchema(i)},pause(){const e=this.data;this.removeListeners(),e.stopOnPause&&(this.pauseTime=Date.now(),clearTimeout(this.sendEventsTimer),this.sendEventsTimer=void 0,this.mediaEl&&!this.mediaEl.paused&&(this.mediaEl.pause(),this.restartMedia=!0))},play(){this.pauseTime&&(this.clockStartTime+=Date.now()-this.pauseTime,delete this.pauseTime),this.mediaEl&&(this.addListeners(),this.restartMedia&&(this.mediaEl.play(),this.restartMedia=!1)),this.sendEvents()},update(e){const t=this.data,i=AFRAME.components["timer-emit"].schema;e.src!==t.src&&(this.removeListeners(),this.mediaEl=t.src instanceof HTMLMediaElement?t.src:void 0),e.target!==t.target&&(this.targets=this.querySelectorAll(t.targetScope,t.target)),this.events=[];for(let e in t)if(!(e in i)){let i=t[e].split(",").map(e=>Number(e));for(let t of i)isNaN(t)||this.events.push([t,e])}this.events.sort((e,t)=>e[0]-t[0]),this.lastSendEventsTime=-1},querySelectorAll(e,t){if(""==t)return[this.el];switch(e){case"self":return this.el.querySelectorAll(t)||[this.el];case"parent":return this.el.parentNode.querySelectorAll(t)||[this.el];case"document":default:return document.querySelectorAll(t)||[this.el]}},addListeners(){this.mediaEl&&this.mediaEl.addEventListener("play",this.sendEvents)},removeListeners(){this.mediaEl&&this.mediaEl.removeEventListener("play",this.sendEvents)},sendEvents(){if(this.mediaEl&&this.mediaEl.paused)return;let e,t=this.mediaEl?this.mediaEl.currentTime:(Date.now()-this.clockStartTime)/1e3,i=[];for(let n of this.events)if(!(n[0]<=this.lastSendEventsTime)){if(!(n[0]<=t)){e=n[0];break}i.push(n[1])}if(i.length>0){const e=this.el;for(let t of this.targets){const n={source:e,target:t};for(let e of i)t.emit(e,n)}}this.lastSendEventsTime=t,e&&(this.sendEventsTimer=setTimeout(this.sendEvents,1e3*(e-t)))}});const Wt=THREE.Math.radToDeg,Gt=THREE.Math.degToRad;AFRAME.registerComponent("tool",{dependencies:["position","rotation","scale"],schema:{debug:{default:!1},handPosition:{type:"vec3"},handRotation:{type:"vec3"},handScale:{type:"vec3",default:{x:1,y:1,z:1}},usage:{default:"respawnondrop",oneOf:["respawnOnDrop","reparentOnEquip","stayOnDrop"],parse:e=>"string"==typeof e?e.toLowerCase():e},hand:{default:""}},init(){this.handA=void 0,this.onToolEquip=this.onToolEquip.bind(this),this.onToolDrop=this.onToolDrop.bind(this),this.handMatrix=new THREE.Matrix4,this.objectMatrixOnEquip=new THREE.Matrix4},play(){this.el.addEventListener("toolequip",this.onToolEquip),this.el.addEventListener("tooldrop",this.onToolDrop)},pause(){this.el.removeEventListener("toolequip",this.onToolEquip),this.el.removeEventListener("tooldrop",this.onToolDrop)},update(e){const t=this.data;if(e.handRotation!==t.handRotation||e.handPosition!==t.handPosition||e.handScale!==t.handScale){const e=(new THREE.Euler).set(Gt(t.handRotation.x),Gt(t.handRotation.y),Gt(t.handRotation.z),"YXZ"),i=(new THREE.Quaternion).setFromEuler(e);this.handMatrix.compose(t.handPosition,i,t.handScale)}e.hand!==t.hand&&(this.handA=t.hand?document.querySelector(t.hand):void 0)},tick:function(){const e=new THREE.Matrix4,t=new THREE.Matrix4;return function(){if(!this.handA)return void this.el.sceneEl.removeBehavior(this);const i=this.data;if(this.handA&&"reparentonequip"!==i.usage){const i=this.el.object3D,n=this.handA.object3D;n.updateMatrixWorld(!0),i.parent.updateMatrixWorld(!0),t.getInverse(i.parent.matrixWorld),e.copy(this.handMatrix).premultiply(n.matrixWorld).premultiply(t),e.decompose(i.position,i.quaternion,i.scale)}}}(),onToolEquip(e){const t=this.data;this.handA=e.detail.hand,this.el.setAttribute("tool",{hand:"#"+e.detail.hand.id}),"reparentonequip"===t.usage?(this.el.setAttribute("position",t.handPosition),this.el.setAttribute("rotation",t.handRotation),this.el.flushToDOM(),this.handA.appendChild(this.el)):(this.objectMatrixOnEquip.copy(this.el.object3D.matrix),this.el.sceneEl.addBehavior(this))},onToolDrop(e){const t=this.data,i=this.el.object3D;if(this.handA=void 0,this.el.setAttribute("tool",{hand:""}),"reparentonequip"===t.usage){const e=new THREE.Vector3,t=new THREE.Quaternion,n=new THREE.Euler(0,0,0,"YXZ");i.getWorldPosition(e),i.getWorldQuaternion(t),n.setFromQuaternion(t,"YXZ"),this.el.setAttribute("position",e),this.el.setAttribute("rotation",`${Wt(n.x)} ${Wt(n.y)} ${Wt(n.z)}`),this.el.flushToDOM(),this.el.sceneEl.appendChild(this.el)}else"respawnondrop"===t.usage&&this.objectMatrixOnEquip.decompose(i.position,i.quaternion,i.scale)}}),AFRAME.registerComponent("trigger-zone",{schema:{triggerSelectors:{default:""},watch:{default:!1},debug:{default:!1},tickMS:{default:100},bubbles:{default:!1},enabled:{default:!0},test:{default:"overlap",oneOf:["overlap","within"]}},multiple:!0,init(){this.firstTime=!0,this.debugShape=void 0,this.overlapping=[],this.triggerElements=[],this.observer=void 0,this.onSceneLoaded=this.onSceneLoaded.bind(this),this.onSceneChanged=this.onSceneChanged.bind(this),this.el.sceneEl.addEventListener("loaded",this.onSceneLoaded)},remove(){this.el.sceneEl.removeEventListener("loaded",this.onSceneLoaded),this.observer&&(this.observer.disconnect(),this.observer=void 0),this.hideDebugShape()},update(e){const t=this.data;this.firstTime||e.triggerSelectors===t.triggerSelectors||this.gatherElements(),this.firstTime||e.watch===t.watch&&e.enabled===t.enabled||this.setupWatch(),e.tickMS!==t.tickMS&&(this.tick=AFRAME.utils.throttleTick(this.tick,t.tickMS,this)),e.debug===t.debug&&e.enabled===t.enabled||this.showDebugShape(),this.firstTime=!1},tick(){this.triggerElements.length>0&&this.data.enabled&&this.checkForEnterLeave()},gatherElements(){const e=this.data;this.triggerElements=e.triggerSelectors?Array.from(document.querySelectorAll(e.triggerSelectors)):[],e.debug&&console.log(`gathering ${this.triggerElements.length} elements`),0===this.triggerElements.length&&$(`no trigger elements using '${e.triggerSelectors}' for trigger-zone`)},checkForEnterLeave(){const e=this.findOverlapping(this.triggerElements,"cyan");for(let t of this.overlapping)e.includes(t)||this.sendTwoEvents("trigger-zone-leave",t);for(let t of e)this.overlapping.includes(t)||this.sendTwoEvents("trigger-zone-enter",t);this.overlapping=e},findOverlapping:function(){const e=new THREE.Vector3,t=new THREE.Vector3,i=new THREE.Vector3,n=new THREE.Vector3(-.5,-.5,-.5),a=new THREE.Vector3(.5,.5,.5);return function(r,s){let o=[];const l=this.el.object3D;l.updateMatrixWorld(!0),l.getWorldPosition(t),l.getWorldScale(i).multiplyScalar(.5);const c=Math.hypot(i.x,i.y,i.z);for(let i of r){if(!i.isEntity||!i.object3D)continue;let r=i.object3D;if(r.boundingSphere&&r.boundingBox&&!r.boundingBox.isEmpty()||Me(r,s),r.boundingBox.isEmpty())continue;e.copy(r.boundingSphere.center).applyMatrix4(r.matrixWorld);const g=r.boundingSphere.radius*Math.max(r.scale.x,r.scale.y,r.scale.z);if(t.distanceTo(e)>g+c)continue;let v=!1;"overlap"===this.data.test?(d=r.boundingBox.min,h=r.boundingBox.max,u=r.matrixWorld.elements,m=n,f=a,p=l.matrixWorld.elements,v=Ae(d,h,u,m,f,p)<0):v=Se(r.boundingBox.min,r.boundingBox.max,r.matrixWorld.elements,n,a,l.matrixWorld.elements),v&&o.push(i)}var d,h,u,m,f,p;return o}}(),sendTwoEvents(e,t){this.data.debug&&console.log(e,z(this.el),z(t));const i=this.data.bubbles;this.el.emit(e,{zoneTarget:t,zoneSource:this.el},i),t.emit(e,{zoneTarget:t,zoneSource:this.el},i)},setupWatch(){this.data.watch&&this.data.enabled?(this.observer=this.observer?this.observer:new MutationObserver(this.onSceneChanged),this.observer.observe(this.el.sceneEl,{childList:!0,subtree:!0})):this.observer&&this.observer.disconnect()},showDebugShape(){this.hideDebugShape();const e=new THREE.BoxBufferGeometry,t=new THREE.WireframeGeometry(e);this.debugShape=new THREE.LineSegments(t,new THREE.LineBasicMaterial({color:this.data.enabled?"blue":"grey"})),this.el.object3D.add(this.debugShape)},hideDebugShape(){this.debugShape&&(this.el.object3D.remove(this.debugShape),this.debugShape=void 0)},onSceneLoaded(e){this.gatherElements(),this.setupWatch()},onSceneChanged(e){V(this.triggerElements,e,this.data.triggerSelectors)}});const Yt=new THREE.Vector3(1,1,1);function $t(e){return e.toLowerCase()}AFRAME.registerComponent("two-handed-transform",{schema:{handSelectors:{type:"selectorAll"},startEvent:{default:"gripdown"},endEvent:{default:"gripup"},target:{type:"selector"},enable:{default:!0},debug:{default:!1}},init(){this.onStartEvent=this.onStartEvent.bind(this),this.onEndEvent=this.onEndEvent.bind(this),this.isEnabled=!1,this.sides=[],this.activeHands=[],this.target={object3D:void 0,startPosition:new THREE.Vector3,startQuaternion:new THREE.Quaternion,startScale:new THREE.Vector3,handGap:new THREE.Vector3,startGap:new THREE.Vector3,invPivotMatrix:new THREE.Matrix4,startWorldPosition:new THREE.Vector3}},update(e){const t=this.data;if(t.handSelectors!==e.handSelectors&&(this.sides.length=0,t.handSelectors))for(let e=0;e<t.handSelectors.length;e++)this.sides.push({handEl:t.handSelectors[e],grabPosition:new THREE.Vector3});e.enable!==t.enable&&(t.enable?this.enable():this.disable())},play(){this.data.enable&&this.enable()},pause(){this.disable()},tick(){1===this.activeHands.length?this.oneHanded(this.activeHands[0]):2===this.activeHands.length&&this.twoHanded(this.activeHands)},enable(){if(!this.isEnabled){for(let e of this.sides)this.addListeners(e.handEl);this.isEnabled=!0}},disable(){if(this.isEnabled){this.activeHands.length=0;for(let e of this.sides)this.removeListeners(e.handEl);this.isEnabled=!1}},onStartEvent(e){this.data.debug&&console.log(z(this.el),this.attrName,"onStartEvent",e.type,z(e.target));for(let t of this.sides)e.target===t.handEl&&this.activate(t)},onEndEvent(e){this.data.debug&&console.log(z(this.el),this.attrName,"onEndEvent",e.type,z(e.target));for(let t of this.sides)e.target===t.handEl&&this.deactivate(t)},addListeners(e){e&&(this.data.debug&&console.log(z(this.el),this.attrName,"addListeners",this.data.startEvent,this.data.endEvent,z(e)),e.addEventListener(this.data.startEvent,this.onStartEvent),e.addEventListener(this.data.endEvent,this.onEndEvent))},removeListeners(e){e&&(this.data.debug&&console.log(z(this.el),this.attrName,"removeListeners",this.data.startEvent,this.data.endEvent,z(e)),e.removeEventListener(this.data.startEvent,this.onStartEvent),e.removeEventListener(this.data.endEvent,this.onEndEvent))},activate(e){-1===this.activeHands.indexOf(e)&&(this.activeHands.push(e),this.captureStartPositions())},deactivate(e){const t=this.activeHands.indexOf(e);-1!==t&&(this.activeHands.splice(t,1),this.captureStartPositions())},captureStartPositions:function(){const e=new THREE.Vector3,t=new THREE.Quaternion,i=new THREE.Matrix4;return function(){const n=this.data.target?this.data.target.object3D:this.el.object3D;if(this.target.object3D=n,n){for(let e of this.activeHands)e.handEl.object3D.getWorldPosition(e.grabPosition);if(n.updateMatrixWorld(),n.getWorldPosition(this.target.startWorldPosition),this.target.startPosition.copy(n.position),this.target.startQuaternion.copy(n.quaternion),this.target.startScale.copy(n.scale),this.activeHands.length>=2){const a=this.activeHands[0].handEl.object3D,r=this.activeHands[1].handEl.object3D;this.target.handGap.copy(r.position).sub(a.position),this.calcMatrixFromHands(e,t,a.position,a.quaternion,r.position,r.quaternion),i.compose(e,t,Yt),i.getInverse(i),this.target.startGap.copy(r.position).applyMatrix4(i).normalize(),this.target.invPivotMatrix.copy(i).multiply(n.matrix)}}else $(`unable to find Object3D for '${this.data.target}'`)}}(),oneHanded:function(){const e=new THREE.Vector3,t=new THREE.Vector3,i=new THREE.Vector3,n=new THREE.Vector3(1,1,1),a=new THREE.Euler(0,0,0,"YXZ"),r=new THREE.Quaternion;return function(s){const o=this.target.object3D;if(o){const l=s.handEl.object3D;l.getWorldPosition(e).sub(s.grabPosition),t.copy(s.grabPosition).sub(this.target.startWorldPosition),l.getWorldPosition(i).sub(this.target.startWorldPosition);const c=i.length()/t.length();n.set(c,c,c),r.setFromUnitVectors(t.normalize(),i.normalize()),a.setFromQuaternion(r,"YXZ"),r.setFromEuler(a),o.position.copy(e.add(this.target.startPosition))}}}(),twoHanded:function(){const e=new THREE.Vector3,t=new THREE.Vector3,i=new THREE.Vector3,n=new THREE.Vector3,a=new THREE.Vector3,r=new THREE.Vector3(1,1,1),s=new THREE.Quaternion,o=new THREE.Matrix4,l=new THREE.Quaternion,c=new THREE.Matrix4;return function(){const d=this.target.object3D;if(d){const h=this.activeHands[0].handEl.object3D,u=this.activeHands[1].handEl.object3D;e.copy(h.position),t.copy(u.position),i.copy(t).sub(e);const m=i.length()/this.target.handGap.length();r.set(m,m,m),d.scale.copy(r.multiply(this.target.startScale)),this.calcMatrixFromHands(a,l,h.position,h.quaternion,u.position,u.quaternion),o.compose(a,l,Yt),c.getInverse(o),n.copy(t).applyMatrix4(c).normalize(),s.setFromUnitVectors(this.target.startGap,n),l.multiply(s),o.compose(a,l,Yt),o.multiply(this.target.invPivotMatrix),o.decompose(a,l,r),d.position.copy(a),d.quaternion.copy(l)}}}(),calcMatrixFromHands(e,t,i,n,a,r){e.copy(i).add(a).multiplyScalar(.5),t.copy(n).slerp(r,.5)}});const Qt={repeat:THREE.RepeatWrapping,clamptoedge:THREE.ClampToEdgeWrapping,mirroredrepeat:THREE.MirroredRepeatWrapping};AFRAME.registerComponent("uv-transform",{schema:{offset:{type:"vec2"},repeat:{type:"vec2",default:{x:1,y:1}},rotation:{type:"number"},center:{type:"vec2",default:{x:.5,y:.5}},meshName:{default:"mesh"},wrapS:{default:"repeat",oneOf:["repeat","clampToEdge","mirroredRepeat"],parse:$t},wrapT:{default:"repeat",oneOf:["repeat","clampToEdge","mirroredRepeat"],parse:$t},maps:{type:"string",default:"map"}},multiple:!0,init(){this.onObject3DSet=this.onObject3DSet.bind(this),this.el.addEventListener("object3dset",this.onObject3DSet)},remove(){this.el.removeEventListener("object3dset",this.onObject3DSet)},update(e){const t=this.data;e.rotation!==t.rotation&&(this.rotation=THREE.Math.degToRad(t.rotation)),e.wrapS===t.wrapS&&e.wrapT===t.wrapT||(this.wrapS=Qt[t.wrapS]||THREE.RepeatWrapping,this.wrapT=Qt[t.wrapT]||THREE.RepeatWrapping),e.maps!==t.maps&&(this.maps=t.maps.split(",").map(e=>e.trim())),this.updateUVs()},onObject3DSet(e){e.target===this.el&&e.detail.type===this.data.meshName&&this.updateUVs()},updateUVs(){const e=this.data,t=e.offset,i=e.repeat,n=this.rotation,a=e.center,r=this.wrapS,s=this.wrapT;const o=this.el.getObject3D(this.data.meshName);if(o&&o.material)for(let e of this.maps)(e=o.material[e])&&(e.wrapS=r,e.wrapT=s,e.offset.copy(t),e.repeat.copy(i),e.center.copy(a),e.rotation=n);var l}});function Xt(e){let t=function(e){let t={type:"",id:"",classes:[],attrs:{}},i="type",n=0,a="";function r(r,s){let o=e.slice(n,s);if(s>n)switch(i){case"type":t.type=o;break;case"id":t.id=o;break;case"class":t.classes.push(o);break;case"attr":a=o;break;case"value":a&&(t.attrs[a]=o)}i=r,n=s+1}for(let t=0,n=e.length;t<n;t++)switch(e[t]){case"\\":t++;break;case"#":"attr"!==i&&"value"!==i&&r("id",t);break;case".":"attr"!==i&&"value"!==i&&r("class",t);break;case"[":"attr"!==i&&"value"!==i&&r("attr",t);break;case"]":"attr"!==i&&"value"!==i||r("none",t);break;case"=":"attr"===i&&r("value",t)}return r("end",e.length),t}(e),i=t.type||"a-entity",n=document.createElement(i);if(n){t.id&&(n.id=t.id),t.classes.length>0&&n.classList.add(...t.classes);for(let e in t.attrs)AFRAME.utils.entity.setComponentProperty(n,e,Zt(t.attrs[e]))}return n}function Zt(e){const t="'"===(e=e.trim())[0]||'"'===e[0]?1:0,i=e.length;let n="'"===e[i-1]||'"'===e[i-1]?i-1:i;return 0===t&&n===i?e:e.slice(t,n)}function Kt(e,t,i){return e.replace(/\$([\.\w]+)/g,(e,n)=>(function(e,t,i){let n=e;0===e.indexOf("event")?i?n=H(B(i,e.slice(6).split("."))):console.log("value of $event but no event received"):n=H(N(t,e.slice(1)));return n})(n,t,i))}AFRAME.registerComponent("vertex-color",{schema:{color:{type:"color"},verts:{type:"array",parse:function(e){return"string"==typeof e?e.split(",").map(e=>parseInt(e,10)):e}},minPosition:{type:"vec3",default:{x:-1e10,y:-1e10,z:-1e10}},maxPosition:{type:"vec3",default:{x:1e10,y:1e10,z:1e10}},minSlope:{type:"int",default:0},maxSlope:{type:"int",default:90},meshName:{default:"mesh"}},multiple:!0,init(){this.onObject3DSet=this.onObject3DSet.bind(this),this.el.addEventListener("object3dset",this.onObject3DSet),this.isFirstFrame=!0},remove(){this.el.removeEventListener("object3dset",this.onObject3DSet)},update(){if(this.isFirstFrame)this.applyVertexColors(),this.isFirstFrame=!1;else{const e=this.el.components;for(let t in e)0===t.indexOf("vertex-color")&&e[t].applyVertexColors()}},onObject3DSet(e){e.target===this.el&&e.detail.type===this.data.meshName&&this.applyVertexColors()},applyVertexColors(){const e=this.data,t=this.el.getObject3D(e.meshName);if(t){const i=t.geometry,n=t.material,a=t.material.color;if(n.vertexColors=THREE.VertexColors,a.r<.3&&a.g<.3&&a.b<.3&&$("material color is very dark, vertex-color will also be dark"),console.assert(i.isBufferGeometry,"vertex-color only supports buffer geometry"),!i.getAttribute("color")){const e=new Float32Array(3*i.getAttribute("position").count).fill(1);i.addAttribute("color",new THREE.Float32BufferAttribute(e,3))}const r=i.getAttribute("position"),s=i.getAttribute("normal"),o=i.getAttribute("color"),l=e.minPosition.x-.5,c=e.minPosition.y,d=e.minPosition.z-.5,h=e.maxPosition.x-.5,u=e.maxPosition.y,m=e.maxPosition.z-.5,f=new THREE.Color(e.color),p=1e-5,g=THREE.Math.degToRad,v=Math.cos(g(Math.max(0,e.minSlope)))+p,y=Math.cos(g(Math.max(0,e.maxSlope)))-p;for(let t=0,i=o.count;t<i;t++){if(e.verts.length>0&&!e.verts.includes(t))continue;const i=r.getX(t),n=r.getY(t),a=r.getZ(t);if(i<l||i>h||n<c||n>u||a<d||a>m)continue;const p=Math.abs(s.getY(t));p<y||p>v||o.setXYZ(t,f.r,f.g,f.b)}o.needsUpdate=!0}}}),AFRAME.registerComponent("wait-add-remove",{schema:{delay:{default:"0"},events:{default:""},source:{default:""},sourceScope:{default:"document",oneOf:["parent","self","document"]},add:{type:"array"},addRepeat:{type:"int",default:1},remove:{type:"array"}},multiple:!0,init(){this.addRemoveEntities=this.addRemoveEntities.bind(this),this.onEvent=this.onEvent.bind(this),this.delayClock=q(),this.eventListener=G(this.el,this.onEvent)},remove(){this.delayClock.clearAllTimers(),this.eventListener.remove()},update(e){const t=this.data;e.events===t.events&&e.source===t.source&&e.sourceScope===t.sourceScope||this.eventListener.set(t.events,t.source,t.sourceScope,t.events),e.delay!==t.delay&&(this.delay=A(t.delay),""===t.events&&this.delayClock.startTimer(k(this.delay),this.addRemoveEntities))},pause(){this.delayClock.pause(),this.eventListener.remove()},play(){this.eventListener.add(),this.delayClock.resume()},onEvent(){this.data;this.delayClock.startTimer(k(this.delay),this.addRemoveEntities)},addRemoveEntities(){const e=this.data;for(let t of e.remove){this.el.querySelectorAll(t).forEach(e=>this.el.removeChild(e))}for(let t=0;t<e.addRepeat;++t)for(let t of e.add){let e=Xt(t);e&&this.el.appendChild(e)}}}),AFRAME.registerComponent("wait-emit",{schema:{events:{default:""},delay:{default:"0"},source:{default:""},sourceScope:{default:"document",oneOf:["parent","self","document"]},out:{default:""},target:{default:""},targetScope:{default:"document",oneOf:["parent","self","document","event"]},bubbles:{default:!1},debug:{default:!1}},multiple:!0,init(){this.onEvent=this.onEvent.bind(this),this.sendEvent=this.sendEvent.bind(this),this.sources=[],this.delayClock=q(),this.eventListener=G(this.el,this.onEvent)},remove(){this.eventListener.remove(),this.waitClock.clearAllTimeouts()},update(e){const t=this.data;t.events===e.events&&t.source===e.source&&t.sourceScope===e.sourceScope||this.eventListener.set(t.events,t.source,t.sourceScope,t.events),t.delay!==e.delay&&(this.delay=A(t.delay),""===t.events&&this.delayClock.startTimer(k(t.delay),this.sendEvent))},pause(){this.eventListener.remove(),this.delayClock.pause()},play(){this.eventListener.add(),this.delayClock.resume()},sendEvent(e){const t=this.data,i=W(this.el,t.target,t.targetScope,e?e.target:void 0),n=Object.assign(e,{source:this.el}),a=t.out?t.out:t.event,r=this.data.bubbles;for(let e of i)this.data.debug&&console.log(z(e),this.attrName,"send",a,n,r),e.emit(a,n,r)},onEvent(e){this.data.debug&&console.log(z(this.el),this.attrName,"onEvent",e.type);const t=this;this.delayClock.startTimer(k(this.delay),()=>t.sendEvent(e))}}),AFRAME.registerComponent("wait-set",{schema:{delay:{default:"0"},events:{default:""},source:{default:""},sourceScope:{default:"document",oneOf:["parent","self","document"]},target:{default:""},targetScope:{default:"document",oneOf:["parent","self","document","event"]},toggles:{default:""},seed:{type:"int",default:-1},debug:{default:!1}},multiple:!0,init(){this.onEvent=this.onEvent.bind(this),this.setProperties=this.setProperties.bind(this),this.rules={},this.toggles=[],this.eventListener=G(this.el,this.onEvent),this.delayClock=q(),this.lcg=p()},remove(){this.eventListener.remove(),this.delayClock.clearAllTimers()},updateSchema(e){"object"!=typeof e&&console.error(`invalid properties, expected format <property>:<value>; '${e}'`);const t=AFRAME.components[this.name].schema;let i={};for(let n in e)n in t||(i[n]={default:""});Object.keys(i).length>0&&this.extendSchema(i)},update(e){const t=AFRAME.components[this.name].schema,i=this.data;i.seed!==e.seed&&this.lcg.setSeed(i.seed);for(let e in this.rules)e in i||delete this.rules[e];for(let n in i)n in t||i[n]===e[n]||(this.rules[n]=A(i[n]));i.events===e.events&&i.source===e.source&&i.sourceScope===e.sourceScope||this.eventListener.set(i.events,i.source,i.sourceScope),i.toggles!==e.toggles&&(this.toggles=i.toggles.split(",").map(e=>e.trim()).filter(e=>e)),i.delay!==e.delay&&(this.delay=A(i.delay),""===i.events&&this.delayClock.startTimer(k(this.delay),this.setProperties))},pause(){this.eventListener.remove(),this.delayClock.pause()},play(){this.delayClock.resume(),this.eventListener.add()},setProperties(e){const t=Kt(this.data.target,this.el,e),i=W(this.el,t,this.data.targetScope,e?e.target:void 0);this.data.debug&&console.log(z(this.el),this.attrName,"setProperties","target=",t);for(let t of i){for(let i in this.rules){const n=H(k(this.rules[i],this.lcg.random)),a=Kt(n,this.el,e);this.data.debug&&console.log(z(this.el),this.attrName,"setProperties","element=",z(t),"property=",i,"value=",n,"$event=",e),U(t,i,a)}for(let e of this.toggles){const i=!N(t,e);U(t,e,i)}}},onEvent(e){this.data.debug&&console.log(z(this.el),this.attrName,"onEvent",e.type,e);const t=this;this.delayClock.startTimer(k(this.delay),()=>t.setProperties(e))}})});