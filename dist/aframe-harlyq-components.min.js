!function(e){"function"==typeof define&&define.amd?define(e):e()}(function(){"use strict";const e=new THREE.Vector3(0,1,0);AFRAME.registerComponent("arm-swinger",{schema:{handSelectors:{type:"selectorAll"},startEvent:{default:"gripdown"},endEvent:{default:"gripup"},cameraRig:{type:"selector"},scaling:{default:1},enabled:{default:!0}},init(){this.onStartEvent=this.onStartEvent.bind(this),this.onEndEvent=this.onEndEvent.bind(this),this.tick=AFRAME.utils.throttleTick(this.tick,100,this),this.newOffset=new THREE.Vector3,this.isMoving=!1,this.isEnabled=!1,this.sides=[]},update(e){const t=this.data;if(e.handSelectors!==t.handSelectors&&(this.sides.length=0,t.handSelectors))for(let e of t.handSelectors)this.sides.push({handEl:e,active:!1,positions:[],forwards:[]});e.enabled!==t.enabled&&(t.enabled?this.enable():this.disable())},play(){this.data.enabled&&this.enable()},pause(){this.disable()},tick(e,t){const i=this.data,n=.001*t;let[a,s]=this.sides.length>0?this.tickSide(this.sides[0]):[void 0,void 0],[r,o]=this.sides.length>1?this.tickSide(this.sides[1]):[void 0,void 0];if(this.isMoving=!1,s||o){this.newOffset.set(0,0,0);let e=0;s&&(this.newOffset.add(s),e=Math.max(e,a)),o&&(this.newOffset.add(o),e=Math.max(e,r)),this.newOffset.y=0,this.newOffset.normalize().multiplyScalar(-i.scaling*e*n),this.isMoving=!0}},tock(){const e=this.data,t=e.cameraRig?e.cameraRig.object3D:this.el.object3D;this.isMoving&&t&&t.position.add(this.newOffset)},enable(){if(!this.isEnabled){for(let e of this.sides)this.addListeners(e.handEl);this.isEnabled=!0}},disable(){if(this.isEnabled){for(let e of this.sides)this.deactivate(e),this.removeListeners(e.handEl);this.isEnabled=!1}},onStartEvent(e){for(let t of this.sides)e.target===t.handEl&&this.activate(t)},onEndEvent(e){for(let t of this.sides)e.target===t.handEl&&this.deactivate(t)},addListeners(e){e&&(e.addEventListener(this.data.startEvent,this.onStartEvent),e.addEventListener(this.data.endEvent,this.onEndEvent))},removeListeners(e){e&&(e.removeEventListener(this.data.startEvent,this.onStartEvent),e.removeEventListener(this.data.endEvent,this.onEndEvent))},activate(e){e.active=!0,e.positions.length=0,e.forwards.length=0},deactivate(e){e.active=!1},tickSide(t){if(!t.active)return[void 0,void 0];let i,n;t.positions.length>=3?(i=t.positions.shift(),n=t.forwards.shift()):(i=new THREE.Vector3,n=new THREE.Vector3);const a=t.handEl.object3D.matrixWorld;t.positions.push(i.setFromMatrixPosition(a)),t.forwards.push(n.setFromMatrixColumn(a,0).cross(e));let s=0;const r=t.positions.length;for(let e=1;e<r;e++)s+=t.positions[e].distanceTo(t.positions[e-1]);return[s,n]}});AFRAME.registerSystem("audio-vis",{schema:{src:{type:"selector"},fftSize:{default:32}},init:function(){this.context=void 0,this.analysers={}},getOrCreateAnalyser:function(){this.context||(this.context=new AudioContext);const e=this.data.src,t=(e=>{const t=e.className.split(" ");return e.localName.toLowerCase()+(t[0]?"."+t.join("."):"")+"#"+e.id})(e);if(this.analysers[t])return this.analysers[t];const i=this.data.fftSize;let n=this.context.createAnalyser();return this.context.createMediaElementSource(e).connect(n),n.connect(this.context.destination),n.fftSize=i,n.fetchTime=-1,n.frequencyData=new Uint8Array(i),this.analysers[t]=n,n},getByteFrequencyData:function(e,t){return t!==e.fetchTime&&(e.getByteFrequencyData(e.frequencyData),e.fetchTime=t),e.frequencyData}});const t=e=>Number(e),i=e=>e.trim().split(" ").map(t),n=e=>e.includes(".."),a=e=>e.split("..").map(i),s=(e,t)=>{if(e.length<1)return e[0];let i=[];const n=e[0],a=e[1];for(let e=0,s=Math.max(n.length,a.length);e<s;e++)i[e]=THREE.Math.lerp(n[e]||0,a[e]||0,t);return i},r={bins:{type:"array",default:[0],parse:e=>"string"==typeof e?e.split(",").map(t):e},threshold:{default:0,min:0,max:1}};AFRAME.registerComponent("audio-vis",{schema:r,multiple:!0,init:function(){this.ranges={},this.analyser=this.system.getOrCreateAnalyser()},updateSchema:function(e){"object"!=typeof e&&console.error(`invalid properties, expected format <property>:<value>; '${e}'`);let t={};for(let i in e)i in this.schema||(t[i]={type:"string"});(e=>{for(let t in e)if(e.hasOwnProperty(t))return!1;return!0})(t)||this.extendSchema(t)},update:function(e){const t=this.data;for(let e in t)e in r||!n(t[e])||(this.ranges[e]=a(t[e]))},tick:function(e,t){const i=this.data,n=this.system.getByteFrequencyData(this.analyser,e),a=i.bins,r=a.length;let o=0;for(let e of a)o+=n[e];let l=o/r/255,c=l>i.threshold?l:0,d=this.el;for(let e in this.ranges){const t=s(this.ranges[e],c);switch(e){case"position":case"scale":d.object3D[e].set(...t);break;case"rotation":d.object3D[e].set(...t.map(THREE.Math.degToRad));break;default:d.setAttribute(e,t.map(e=>e.toFixed(4)).join(" "))}}}});Object.freeze({x:0,y:0,z:0}),Object.freeze({x:1,y:0,z:0}),Object.freeze({x:0,y:1,z:0}),Object.freeze({x:0,y:0,z:1});function o(e,t){return e.x=t.x,e.y=t.y,e.z=t.z,e}function l(e,t,i){return e.x=Math.max(t.x,i.x),e.y=Math.max(t.y,i.y),e.z=Math.max(t.z,i.z),e}const c=Math.sqrt(.5);Object.freeze({x:0,y:0,z:0,w:1}),Object.freeze({x:1,y:0,z:0,w:0}),Object.freeze({x:0,y:1,z:0,w:0}),Object.freeze({x:0,y:0,z:1,w:0}),Object.freeze({x:c,y:0,z:0,w:c}),Object.freeze({x:0,y:c,z:0,w:c}),Object.freeze({x:0,y:0,z:c,w:c});function d(e,t,i){const n=i.x,a=i.y,s=i.z;return e.x=t[0]*n+t[4]*a+t[8]*s+t[12],e.y=t[1]*n+t[5]*a+t[9]*s+t[13],e.z=t[2]*n+t[6]*a+t[10]*s+t[14],e}function h(e,t,i){const n=t[0],a=t[1],s=t[2],r=t[4],o=t[5],l=t[6],c=t[8],d=t[9],h=t[10],u=t[12],m=t[13],p=t[14],f=h*o-l*d,g=l*c-h*r,v=d*r-o*c,y=1/(n*f+a*g+s*v),b=f*y,E=(s*d-h*a)*y,x=(l*a-s*o)*y,T=g*y,w=(h*n-s*c)*y,A=(s*r-l*n)*y,R=v*y,S=(a*c-d*n)*y,M=(o*n-a*r)*y,C=i.x-u,I=i.y-m,O=i.z-p;return e.x=b*C+T*I+R*O,e.y=E*C+w*I+S*O,e.z=x*C+A*I+M*O,e}function u(e,t=Math.random){return e[function(e,t=Math.random){return~~Math.min(e-1,t()*e)}(e.length,t)]}function m(e,t,i=Math.random){return t===e?e:i()*(t-e)+e}function p(){let e=-1;return{setSeed:function(t){e=t},random:function(){return e<0?Math.random():(e=(1664525*e+1013904223)%4294967296)/4294967296}}}function f(e,t,i){return e<t?t:e>i?i:e}function g(e){return"object"==typeof e&&"r"in e&&"g"in e&&"b"in e}const v=function(){function e(e,t,i){return i<0&&(i+=1),i>1&&(i-=1),i<1/6?e+6*(t-e)*i:i<.5?t:i<2/3?e+6*(t-e)*(2/3-i):e}return function(t,i,n,a){var s;if(i=(i%(s=1)+s)%s,n=f(n,0,1),a=f(a,0,1),0===n)t.r=t.g=t.b=a;else{let s=a<=.5?a*(1+n):a+n-a*n,r=2*a-s;t.r=e(r,s,i+1/3),t.g=e(r,s,i),t.b=e(r,s,i-1/3)}return t}}();const y={aliceblue:15792383,antiquewhite:16444375,aqua:65535,aquamarine:8388564,azure:15794175,beige:16119260,bisque:16770244,black:0,blanchedalmond:16772045,blue:255,blueviolet:9055202,brown:10824234,burlywood:14596231,cadetblue:6266528,chartreuse:8388352,chocolate:13789470,coral:16744272,cornflowerblue:6591981,cornsilk:16775388,crimson:14423100,cyan:65535,darkblue:139,darkcyan:35723,darkgoldenrod:12092939,darkgray:11119017,darkgreen:25600,darkgrey:11119017,darkkhaki:12433259,darkmagenta:9109643,darkolivegreen:5597999,darkorange:16747520,darkorchid:10040012,darkred:9109504,darksalmon:15308410,darkseagreen:9419919,darkslateblue:4734347,darkslategray:3100495,darkslategrey:3100495,darkturquoise:52945,darkviolet:9699539,deeppink:16716947,deepskyblue:49151,dimgray:6908265,dimgrey:6908265,dodgerblue:2003199,firebrick:11674146,floralwhite:16775920,forestgreen:2263842,fuchsia:16711935,gainsboro:14474460,ghostwhite:16316671,gold:16766720,goldenrod:14329120,gray:8421504,green:32768,greenyellow:11403055,grey:8421504,honeydew:15794160,hotpink:16738740,indianred:13458524,indigo:4915330,ivory:16777200,khaki:15787660,lavender:15132410,lavenderblush:16773365,lawngreen:8190976,lemonchiffon:16775885,lightblue:11393254,lightcoral:15761536,lightcyan:14745599,lightgoldenrodyellow:16448210,lightgray:13882323,lightgreen:9498256,lightgrey:13882323,lightpink:16758465,lightsalmon:16752762,lightseagreen:2142890,lightskyblue:8900346,lightslategray:7833753,lightslategrey:7833753,lightsteelblue:11584734,lightyellow:16777184,lime:65280,limegreen:3329330,linen:16445670,magenta:16711935,maroon:8388608,mediumaquamarine:6737322,mediumblue:205,mediumorchid:12211667,mediumpurple:9662683,mediumseagreen:3978097,mediumslateblue:8087790,mediumspringgreen:64154,mediumturquoise:4772300,mediumvioletred:13047173,midnightblue:1644912,mintcream:16121850,mistyrose:16770273,moccasin:16770229,navajowhite:16768685,navy:128,oldlace:16643558,olive:8421376,olivedrab:7048739,orange:16753920,orangered:16729344,orchid:14315734,palegoldenrod:15657130,palegreen:10025880,paleturquoise:11529966,palevioletred:14381203,papayawhip:16773077,peachpuff:16767673,peru:13468991,pink:16761035,plum:14524637,powderblue:11591910,purple:8388736,rebeccapurple:6697881,red:16711680,rosybrown:12357519,royalblue:4286945,saddlebrown:9127187,salmon:16416882,sandybrown:16032864,seagreen:3050327,seashell:16774638,sienna:10506797,silver:12632256,skyblue:8900331,slateblue:6970061,slategray:7372944,slategrey:7372944,snow:16775930,springgreen:65407,steelblue:4620980,tan:13808780,teal:32896,thistle:14204888,tomato:16737095,turquoise:4251856,violet:15631086,wheat:16113331,white:16777215,whitesmoke:16119285,yellow:16776960,yellowgreen:10145074},b=/^((?:rgb|hsl)a?)\(\s*([^\)]*)\)/;function E(e){let t;if(t=b.exec(e)){let e;const i=t[1],n=t[2];switch(i){case"rgb":case"rgba":if(e=/^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(n)){const t={r:Math.min(255,parseInt(e[1],10))/255,g:Math.min(255,parseInt(e[2],10))/255,b:Math.min(255,parseInt(e[3],10))/255};return e[5]&&(t.a=parseFloat(e[5])),t}if(e=/^(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(n)){const t={r:Math.min(100,parseInt(e[1],10))/100,g:Math.min(100,parseInt(e[2],10))/100,b:Math.min(100,parseInt(e[3],10))/100};return e[5]&&(t.a=parseFloat(e[5])),t}break;case"hsl":case"hsla":if(e=/^([0-9]*\.?[0-9]+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(n)){const t=v({r:0,g:0,b:0,a:0},parseFloat(e[1])/360,parseInt(e[2],10)/100,parseInt(e[3],10)/100);return e[5]&&(t.a=parseFloat(e[5])),t}}}else if(t=/^\#([A-Fa-f0-9]+)$/.exec(e)){const e=t[1],i=e.length;if(3===i)return{r:parseInt(e.charAt(0)+e.charAt(0),16)/255,g:parseInt(e.charAt(1)+e.charAt(1),16)/255,b:parseInt(e.charAt(2)+e.charAt(2),16)/255};if(6===i)return{r:parseInt(e.charAt(0)+e.charAt(1),16)/255,g:parseInt(e.charAt(2)+e.charAt(3),16)/255,b:parseInt(e.charAt(4)+e.charAt(5),16)/255}}if(e&&e.length>0){const t=y[e];if(void 0!==t)return(i={r:0,g:0,b:0}).r=((t=t)>>16&255)/255,i.g=(t>>8&255)/255,i.b=(255&t)/255,i}var i,n}function x(e,t){let i=e,n=t&&Array.isArray(t)?t.slice().reverse():[];for(;i&&n.length>0;)i=i[n.pop()];return i}const T=e=>e,w=Symbol("nested"),A="|",R="->";function S(e,t=M,i=T){const n=function(e){if(U.test(e))return{variable:e};const t=e.split(A);if(t.length>1)return{options:t};const i=e.split(R);if(i.length>1)return{range:[i[0],i[1]]};return{options:t}}(e.trim());return n.variable?{variable:n.variable}:n.range?{range:n.range.map(e=>i(t(e)))}:{options:n.options.map(e=>i(t(e)))}}const M=function(){const e=e=>Number(e.trim());return function(t){if(""===t)return"";let i=t.split(" ").filter(e=>""!==e).map(e);if(!i.some(isNaN))switch(i.length){case 1:return i[0];case 2:return{x:i[0],y:i[1]};case 3:return{x:i[0],y:i[1],z:i[2]};case 4:return{x:i[0],y:i[1],z:i[2],w:i[3]}}let n=E(t.trim());return n||t.trim()}}();function C(e){const t=Number(e.trim());return!e||isNaN(t)?void 0:t}function I(e){const t=function(e){return e.split(" ").filter(e=>""!==e).map(e=>Number(e.trim()))}(e);return t.length<3||t.some(isNaN)?void 0:{x:Number(t[0]),y:Number(t[1]),z:Number(t[2])}}function O(e){return E(e.trim())}function L(e){return"number"==typeof e}function D(e){return"object"==typeof e&&"x"in e&&"y"in e&&"z"in e&&"number"==typeof e.x&&"number"==typeof e.y&&"number"==typeof e.z}function F(e){return"object"==typeof e&&"r"in e&&"g"in e&&"b"in e&&"number"==typeof e.r&&"number"==typeof e.g&&"number"==typeof e.b}function k(e,t){return e.range?e.range.every(t):e.options?e.options.every(t):!!e.variable}function P(e,t,i,n=T){const a=S(e,t,n);return k(a,i)?a:void 0}function H(e,t,i,n,a=T){if(""===e.trim())return[];const s=W(e,",").flatMap(e=>{const i=e.trim();return!n||i?S(i,t,a):void 0});return s.every(e=>!(!n||void 0!==e)||k(e,i))?s:void 0}function j(e,t=T){return H(e,O,F,!1,t)}function _(e,t=T){return P(e,C,L,t)}function z(e,t=T){return H(e,C,L,!1,t)}function V(e,t=T){return P(e,I,D,t)}function B(e){if(e.options){if(e.options.length>0&&"number"==typeof e.options[0])return Math.max(...e.options)}else if(e.range&&"number"==typeof e.range[0])return Math.max(...e.range)}const U=/\$([\.\w]+)\$/g;function N(e,t=Math.random){if(e&&e.range){const i=e.range[0],n=e.range[1];return g(i)?function(e,t,i,n=Math.random){return e.r=m(t.r,i.r,n),e.g=m(t.g,i.g,n),e.b=m(t.b,i.b,n),e}({r:0,g:0,b:0},i,n,t):"object"==typeof i&&"x"in i&&"object"==typeof n&&"x"in n?function(e,t,i,n=Math.random){return e.x=m(t.x,i.x,n),e.y=m(t.y,i.y,n),"z"in t&&"z"in i&&(e.z=m(t.z,i.z,n)),"w"in t&&"w"in i&&(e.w=m(t.w,i.w,n)),e}({x:0,y:0},i,n,t):"number"==typeof i&&"number"==typeof n?m(i,n,t):i}if(e&&e.options)return u(e.options,t)}function G(e,t=Math.random){return e&&e.map(e=>N(e,t))}function q(e){if("object"==typeof e){if(e.range)return q(e.range[0])+R+q(e.range[1]);if(e.options)return e.options.map(e=>q(e)).join(A);if(g(e))return"#"+function(e){return 255*e.r<<16^255*e.g<<8^255*e.b<<0}(e).toString(16).padStart(6,"0");if("x"in e&&"y"in e)return e.x+" "+e.y+("z"in e?" "+e.z:"")+("w"in e?" "+e.w:"");if(e.length&&"0"in e)return e.join(",");if(e instanceof HTMLElement)return"#"+e.id}return void 0!==e?e.toString():void 0}function W(e,t=",",i=["''",'""',"{}","[]","()"]){let n=[],a=[],s=0,r=0;for(let o=0,l=e.length;o<l;o++){const l=e[o];if(a.length>0&&l===a[a.length-1][1])a.pop();else for(let e of i)l===e[0]&&a.push(e);0===a.length&&l===t[r]?++r===t.length&&(n.push(e.substring(s,o-r+1)),s=o+1,r=0):r=0}return n.push(e.substring(s,e.length)),n}const $=Symbol("default"),Q=Symbol("last"),Y=Symbol("first"),X=Symbol("append");function Z(e){return e.tagName.toLowerCase()+(e.id?"#"+e.id:"")+(e.classList.length>0?"."+Array.from(e.classList).join("."):"")}const K=(()=>{const e=e=>e.trim(),t={rotation:e=>isNaN(e)?0:THREE.Math.degToRad(e),position:e=>isNaN(e)?0:e,scale:e=>isNaN(e)?1:e};return function(i,n,a){let s=t[n];if(s)return Array.isArray(a)||(a="object"==typeof a?[a.x,a.y,a.z]:"number"==typeof a?[a]:a.split(" ").map(e)),a.length=3,void i.object3D[n].set(...a.map(s));const r=n.split(".");if(r.length<=2)return r[0]=r[0].replace(/[A-Z]/g,e=>"-"+e.toLowerCase()),void(a||"boolean"==typeof a||"number"==typeof a?AFRAME.utils.entity.setComponentProperty(i,r.join("."),q(a)):i.removeAttribute(r[0],r[1]));const o=x(i,r.slice(0,-1));o?o[r[r.length-1]]=a:console.warn(`unknown path for setProperty() '${n}'`)}})();function J(e,t){const i=t.split(".");if(1===i.length)return e.getAttribute(t);if(i.length<=2){i[0]=i[0].replace(/[A-Z]/g,e=>"-"+e.toLowerCase());const t=e.getAttribute(i[0]);return"object"==typeof t?t[i[1]]:void 0}return x(e,i)}function ee(){let e=[];function t(e,t,n){e.id=setTimeout(()=>{i(e),n()},1e3*t),e.startTime=Date.now(),e.callback=n}function i(t){const i=e.indexOf(t);i>=0&&(clearTimeout(t.id),e.splice(i,1))}return{startTimer:function(i,n){if(i>0){const a={};return t(a,i,n),e.push(a),a}n()},clearTimer:i,clearAllTimers:function(){for(let t of e)clearTimeout(t.id);e.length=0},pause:function(){for(let t of e)t.resumeTime=Date.now()-t.startTime,clearTimeout(t.id)},resume:function(){for(let i of e)i.resumeTime&&(t(i,i.resumeTime,i.callback),delete i.resumeTime)}}}function te(e,t,i,n){switch(i){case"self":return t?e.querySelectorAll(t):[e];case"parent":return t?e.parentNode.querySelectorAll(t):[e];case"event":return t&&n instanceof HTMLElement?n.querySelectorAll(t):[e];case"document":default:return t?document.querySelectorAll(t):[e]}}function ie(e,t){let i,n,a,s=!1,r=[],o=l(i);function l(e){return e&&"string"==typeof e?e.split(",").map(e=>e.trim()):[]}function c(){if(!s){for(let e of r)for(let i of o)e.addEventListener(i,t);s=!0}}function d(){if(s){for(let e of r)for(let i of o)e.removeEventListener(i,t);s=!1}}return{set:function(t,h,u){const m=s;!m||t===i&&h===n&&u===a||d(),n=h,a=u,i!==t&&(o=l(i=t)),r=te(e,n,a,void 0),m&&c()},add:c,remove:d}}function ne(e,t,i){const n=e&&e.match(/url\((.+)\)/);if(n){const e=n[1];(new THREE.FileLoader).load(e,e=>i(e),()=>{},t=>{console.error(`unable to load: ${e} `,t)})}else if(t&&e.includes(t))i(e.trim());else{const t=e?document.querySelector(e):void 0;i(t?t.textContent.trim():e.trim())}}function ae(e,...t){console.log(oe(e),...t)}function se(e,...t){console.warn(oe(e),...t)}function re(e,...t){console.error(oe(e),...t)}function oe(e){return Z(e.el)+"["+e.attrName+"]"}function le(e,t,i,n=0,a=0,s=0){return e[s]=t[n]-i[a],e[s+1]=t[n+1]-i[a+1],e[s+2]=t[n+2]-i[a+2],e}function ce(e,t,i=0,n=0){const a=t[i],s=t[i+1],r=t[i+2],o=Math.hypot(a,s,r)||1;return e[n]=a/o,e[n+1]=s/o,e[n+2]=r/o,e}function de(e,t,i=0,n=0){return e[i]*t[n]+e[i+1]*t[n+1]+e[i+2]*t[n+2]}function he(e,t,i,n,a=0,s=0,r=0){return e[r]=t[a]+i[s]*n,e[r+1]=t[a+1]+i[s+1]*n,e[r+2]=t[a+2]+i[s+2]*n,e}function ue(e,t,i=1e-5,n=0,a=0){return Math.abs(e[n]-t[a])<i&&Math.abs(e[n+1]-t[a+1])<i&&Math.abs(e[n+2]-t[a+2])<i}function me(e,t,i,n=0,a=0,s=0){const r=t[n],o=t[n+1],l=t[n+2],c=i[a],d=i[a+1],h=i[a+2];return e[s]=o*h-l*d,e[s+1]=l*c-r*h,e[s+2]=r*d-o*c,e}const pe=function(){let e=new Float32Array(3),t=new Float32Array(3),i=new Float32Array(3);return function(n,a,s,r,o=0,l=0,c=0,d=0){return le(e,r,s,c,l),le(t,a,s,o,l),ce(n,me(i,e,t),0,d)}}();function fe(e,t,i,n=0){const a=i.length;let s=0,r=0,o=0;for(let e=0;e<i.length;e++){const n=i[e];s+=t[n]/a,r+=t[n+1]/a,o+=t[n+2]/a}return function(e,t=0,i=0,n=0,a=0){return e[a]=t,e[a+1]=i,e[a+2]=n,e}(e,s,r,o,n)}const ge=function(){const e=new Float32Array(3),t=new Float32Array(3),i=new Float32Array(3);return function(n,a,s,r,o=1e-5,l=0,c=0,d=0,h=0){return le(e,a,n,c,l),le(t,s,n,d,l),le(i,r,n,h,l),Math.abs(de(i,me(e,e,t)))<o}}();function ve(e,t,i,n=0,a=0){return e[a]=t[n]*i,e[a+1]=t[n+1]*i,e[a+2]=t[n+2]*i,e}function ye(e,t,i){return 0===i?e:e+(t-e)*i}function be(e,t,i){let n=Object.assign({},e);if(0===i)return n;for(let a in t)n[a]=void 0!==e[a]?ye(e[a],t[a],i):t[a];return n}function Ee(e,t,i=xe){const n=e.length;if(t<=0||n<=1)return[0,0];if(t>=1)return[n-2,1];const a=t*(n-1),s=~~a;return[s,i(a-s)]}function xe(e){return e}const Te={In:function(e){return e*e},Out:function(e){return e*(2-e)},InOut:function(e){return(e*=2)<1?.5*e*e:-.5*(--e*(e-2)-1)}},we={In:function(e){return e*e*e},Out:function(e){return--e*e*e+1},InOut:function(e){return(e*=2)<1?.5*e*e*e:.5*((e-=2)*e*e+2)}},Ae={In:function(e){return e*e*e*e},Out:function(e){return 1- --e*e*e*e},InOut:function(e){return(e*=2)<1?.5*e*e*e*e:-.5*((e-=2)*e*e*e-2)}},Re={In:function(e){return e*e*e*e*e},Out:function(e){return--e*e*e*e*e+1},InOut:function(e){return(e*=2)<1?.5*e*e*e*e*e:.5*((e-=2)*e*e*e*e+2)}},Se={In:function(e){return 1-Math.cos(e*Math.PI/2)},Out:function(e){return Math.sin(e*Math.PI/2)},InOut:function(e){return.5*(1-Math.cos(Math.PI*e))}},Me={In:function(e){return 0===e?0:Math.pow(1024,e-1)},Out:function(e){return 1===e?1:1-Math.pow(2,-10*e)},InOut:function(e){return 0===e?0:1===e?1:(e*=2)<1?.5*Math.pow(1024,e-1):.5*(2-Math.pow(2,-10*(e-1)))}},Ce={In:function(e){return 1-Math.sqrt(1-e*e)},Out:function(e){return Math.sqrt(1- --e*e)},InOut:function(e){return(e*=2)<1?-.5*(Math.sqrt(1-e*e)-1):.5*(Math.sqrt(1-(e-=2)*e)+1)}},Ie={In:function(e){return 0===e?0:1===e?1:-Math.pow(2,10*(e-1))*Math.sin(5*(e-1.1)*Math.PI)},Out:function(e){return 0===e?0:1===e?1:Math.pow(2,-10*e)*Math.sin(5*(e-.1)*Math.PI)+1},InOut:function(e){return 0===e?0:1===e?1:(e*=2)<1?-.5*Math.pow(2,10*(e-1))*Math.sin(5*(e-1.1)*Math.PI):.5*Math.pow(2,-10*(e-1))*Math.sin(5*(e-1.1)*Math.PI)+1}},Oe={In:function(e){var t=1.70158;return e*e*((t+1)*e-t)},Out:function(e){var t=1.70158;return--e*e*((t+1)*e+t)+1},InOut:function(e){var t=2.5949095;return(e*=2)<1?e*e*((t+1)*e-t)*.5:.5*((e-=2)*e*((t+1)*e+t)+2)}},Le={In:function(e){return 1-Le.Out(1-e)},Out:function(e){return e<1/2.75?7.5625*e*e:e<2/2.75?7.5625*(e-=1.5/2.75)*e+.75:e<2.5/2.75?7.5625*(e-=2.25/2.75)*e+.9375:7.5625*(e-=2.625/2.75)*e+.984375},InOut:function(e){return e<.5?.5*Le.In(2*e):.5*Le.Out(2*e-1)+.5}},De={linear:xe,ease:we.InOut,"ease-in":we.In,"ease-out":we.Out,"ease-in-out":we.InOut,"ease-cubic":we.In,"ease-in-cubic":we.In,"ease-out-cubic":we.Out,"ease-in-out-cubic":we.InOut,"ease-quad":Te.InOut,"ease-in-quad":Te.In,"ease-out-quad":Te.Out,"ease-in-out-quad":Te.InOut,"ease-quart":Ae.InOut,"ease-in-quart":Ae.In,"ease-out-quart":Ae.Out,"ease-in-out-quart":Ae.InOut,"ease-quint":Re.InOut,"ease-in-quint":Re.In,"ease-out-quint":Re.Out,"ease-in-out-quint":Re.InOut,"ease-sine":Se.InOut,"ease-in-sine":Se.In,"ease-out-sine":Se.Out,"ease-in-out-sine":Se.InOut,"ease-expo":Me.InOut,"ease-in-expo":Me.In,"ease-out-expo":Me.Out,"ease-in-out-expo":Me.InOut,"ease-circ":Ce.InOut,"ease-in-circ":Ce.In,"ease-out-circ":Ce.Out,"ease-in-out-circ":Ce.InOut,"ease-elastic":Ie.InOut,"ease-in-elastic":Ie.In,"ease-out-elastic":Ie.Out,"ease-in-out-elastic":Ie.InOut,"ease-back":Oe.InOut,"ease-in-back":Oe.In,"ease-out-back":Oe.Out,"ease-in-out-back":Oe.InOut,"ease-bounce":Le.InOut,"ease-in-bounce":Le.In,"ease-out-bounce":Le.Out,"ease-in-out-bounce":Le.InOut},Fe=function(){const e={x:0,y:0,z:0};return function(t,i,n,a,s,r){for(let p=0;p<8;p++)e.x=p%2?a.x:n.x,e.y=(p>>>1)%2?a.y:n.y,e.z=(p>>>2)%2?a.z:n.z,d(e,s,e),h(e,r,e),0===p?(o(t,e),o(i,e)):(u=e,m=t,(c=t).x=Math.min(u.x,m.x),c.y=Math.min(u.y,m.y),c.z=Math.min(u.z,m.z),l(i,e,i));var c,u,m}}(),ke=function(){let e={x:0,y:0,z:0},t={x:0,y:0,z:0};function i(i,n,a,s,r,o){return Fe(e,t,i,n,a,o),Math.max(e.x-r.x,e.y-r.y,e.z-r.z,s.x-t.x,s.y-t.y,s.z-t.z)}return function(e,t,n,a,s,r){const o=i(e,t,n,a,s,r),l=i(a,s,r,e,t,n);return Math.max(o,l)}}();function Pe(e,t,i,n,a,s){return ke(e,t,i,n,a,s)<0}const He=function(){let e={x:0,y:0,z:0},t={x:0,y:0,z:0};return function(i,n,a,s,r,o){return Fe(e,t,i,n,a,o),e.x>s.x&&e.y>s.y&&e.z>s.z&&t.x<r.x&&t.y<r.y&&t.z<r.z}}();function je(e,t){for(let i of["map","alphaMap","aoMap","bumpMap","displacementMap","emissiveMap","envMap","lighMap","metalnessMap","normalMap","roughnessMap"])e[i]&&e[i].image===t&&(e[i].needsUpdate=!0)}function _e(e,t){e.uniforms&&e.uniforms.map&&e.uniforms.map.value&&"object"==typeof e.uniforms.map.value&&e.uniforms.map.value.image===t&&(e.uniforms.map.value.needsUpdate=!0)}function ze(e,t){e.traverse(e=>{if(e.material)if(Array.isArray(e.material))for(let i of e.material)je(i,t),_e(i,t);else je(e.material,t),_e(e.material,t)})}const Ve=function(){let e=new THREE.Vector3,t=new THREE.Quaternion,i=new THREE.Vector3,n=new THREE.Box3;return function(a,s){e.copy(s.position),t.copy(s.quaternion),i.copy(s.scale);const r=s.parent;return s.parent=null,s.position.set(0,0,0),s.quaternion.set(0,0,0,1),s.scale.set(1,1,1),n.setFromObject(s),s.parent=r,s.position.copy(e),s.quaternion.copy(t),s.scale.copy(i),s.updateMatrixWorld(!0),a.min.x=n.min.x,a.min.y=n.min.y,a.min.z=n.min.z,a.max.x=n.max.x,a.max.y=n.max.y,a.max.z=n.max.z,a}}();function Be(e,t){if(e.boundingBox=e.boundingBox||new THREE.Box3,e.boundingSphere=e.boundingSphere||new THREE.Sphere,e.boundingBoxDebug&&(e.remove(e.boundingBoxDebug),e.boundingBoxDebug=void 0),Ve(e.boundingBox,e),!e.boundingBox.isEmpty()&&(e.boundingBox.getBoundingSphere(e.boundingSphere),t)){const i=new THREE.Vector3;e.boundingBox.getSize(i);const n=new THREE.Group,a=new THREE.Box3Helper(e.boundingBox,t),s=new THREE.AxesHelper(Math.min(i.x,i.y,i.z));n.add(s),n.add(a),n.name="orientedBoundingDebug",e.add(n),e.boundingBoxDebug=n}}var Ue=Math.PI/180,Ne=48,Ge=57,qe=44,We=32,$e=46,Qe=45;function Ye(e){'"'!==e[0]&&"'"!==e[0]||(e=e.substring(1,e.length-1));var t,i,n,a,s=new THREE.Shape,r=1,o=e.length,l=0,c=0,d=0,h=0,u=null,m=null,p=0,f=0,g=0,v=0,y=0,b=0,E=0,x=0,T=0;function w(){for(var t,i,n,a=!1;r<o&&((i=e.charCodeAt(r))===qe||i===We);)r++;for(t=i===Qe?r++:r;r<o;)if(i=e.charCodeAt(r),Ne<=i&&i<=Ge)r++;else{if(i!==$e)return n=e.substring(t,r),a?parseFloat(n):parseInt(n);r++,a=!0}return n=e.substring(t),a?parseFloat(n):parseInt(n)}function A(){for(var t;r<o&&((t=e.charCodeAt(r))===qe||t===We);)r++;return(t=e.charCodeAt(r))===Qe||Ne<=t&&t<=Ge}for(t=e[0];r<=o;){switch(a=!0,t){case"M":l=w(),c=w(),s.moveTo(l,c),t="L",u=l,m=c;break;case"m":l+=w(),c+=w(),s.moveTo(l,c),t="l",u=l,m=c;break;case"Z":case"z":a=!1,l===u&&c===m||s.lineTo(u,m);break;case"L":case"H":case"V":d="V"===t?l:w(),h="H"===t?c:w(),s.lineTo(d,h),l=d,c=h;break;case"l":case"h":case"v":d="v"===t?l:l+w(),h="h"===t?c:c+w(),s.lineTo(d,h),l=d,c=h;break;case"C":p=w(),g=w();case"S":"S"===t&&(p=2*l-f,g=2*c-v),f=w(),v=w(),d=w(),h=w(),s.bezierCurveTo(p,g,f,v,d,h),l=d,c=h;break;case"c":p=l+w(),g=c+w();case"s":"s"===t&&(p=2*l-f,g=2*c-v),f=l+w(),v=c+w(),d=l+w(),h=c+w(),s.bezierCurveTo(p,g,f,v,d,h),l=d,c=h;break;case"Q":p=w(),g=w();case"T":"T"===t&&(p=2*l-p,g=2*c-g),d=w(),h=w(),s.quadraticCurveTo(p,g,d,h),l=d,c=h;break;case"q":p=l+w(),g=c+w();case"t":"t"===t&&(p=2*l-p,g=2*c-g),d=l+w(),h=c+w(),s.quadraticCurveTo(p,g,d,h),l=d,c=h;break;case"A":y=w(),b=w(),E=w()*Ue,x=w(),T=w(),d=w(),h=w(),y!==b&&console.warn("Forcing elliptical arc to be a circular one :(",y,b),p=Math.cos(E)*(l-d)/2+Math.sin(E)*(c-h)/2,g=-Math.sin(E)*(l-d)/2+Math.cos(E)*(c-h)/2;var R=Math.sqrt((y*y*b*b-y*y*g*g-b*b*p*p)/(y*y*g*g+b*b*p*p));x===T&&(R=-R),f=R*y*g/b,v=R*-b*p/y,i=Math.cos(E)*f-Math.sin(E)*v+(l+d)/2,n=Math.sin(E)*f+Math.cos(E)*v+(c+h)/2;var S=new THREE.Vector2(1,0),M=new THREE.Vector2((p-f)/y,(g-v)/b),C=Math.acos(S.dot(M)/S.length()/M.length());S.x*M.y-S.y*M.x<0&&(C=-C),S.x=(-p-f)/y,S.y=(-g-v)/b;var I=Math.acos(M.dot(S)/M.length()/S.length());M.x*S.y-M.y*S.x<0&&(I=-I),!T&&I>0&&(I-=2*Math.PI),T&&I<0&&(I+=2*Math.PI),s.absarc(i,n,y,C,C+I,T),l=d,c=h;break;default:throw new Error("weird path command: "+t)}a&&A()||(t=e[r++])}return s}const Xe=function(){let e=new THREE.Vector3,t=new THREE.Vector3;return function(i,n){let a,s,r=9*Math.floor(Math.random()*i.length/9);e.fromArray(i,r),t.fromArray(i,r+3),n.fromArray(i,r+6);do{a=Math.random(),s=Math.random()}while(a+s>1);t.sub(e).multiplyScalar(a),n.sub(e).multiplyScalar(s).add(t).add(e)}}(),Ze=function(){let e=new THREE.Vector3,t=new THREE.Vector3;return function(i,n){const a=9*Math.floor(Math.random()*i.length/9),s=3*Math.random();s>2?(e.fromArray(i,a+6),t.fromArray(i,a)):s>1?(e.fromArray(i,a+3),t.fromArray(i,a+6)):(e.fromArray(i,a),t.fromArray(i,a+3)),n.copy(t).sub(e).multiplyScalar(s-Math.floor(s)).add(e)}}();AFRAME.registerComponent("chalk",{dependencies:["raycaster"],schema:{color:{type:"color"},length:{default:.1},radius:{default:.02},debug:{default:!1}},init(){this.boards=[],this.onRaycasterIntersection=this.onRaycasterIntersection.bind(this),this.onRaycasterIntersectionCleared=this.onRaycasterIntersectionCleared.bind(this);const e=this.data,t=new THREE.CylinderBufferGeometry(e.radius,e.radius,e.length,16);t.applyMatrix((new THREE.Matrix4).set(1,0,0,0,0,0,1,0,0,-1,0,0,0,0,0,1));const i=new THREE.Mesh(t,new THREE.MeshBasicMaterial({color:e.color}));this.el.setObject3D("mesh",i)},update(e){const t=this.data;if(t.color!==e.color){const e=this.el.getObject3D("mesh");e&&e.material&&!Array.isArray(e.material)&&e.material.color.setStyle(t.color)}},play(){this.el.addEventListener("raycaster-intersection",this.onRaycasterIntersection),this.el.addEventListener("raycaster-intersection-cleared",this.onRaycasterIntersectionCleared)},pause(){this.el.removeEventListener("raycaster-intersection",this.onRaycasterIntersection),this.el.removeEventListener("raycaster-intersection-cleared",this.onRaycasterIntersectionCleared)},onRaycasterIntersection(e){this.data.debug&&console.log("contact"),0===this.boards.length&&this.startTick(),this.boards.push(...e.detail.els.map(e=>({el:e,radius:-1,ctx:void 0,texture:void 0,prevIntersection:void 0})))},onRaycasterIntersectionCleared(e){this.data.debug&&console.log("cleared"),this.boards.length=0},tick(){if(0===this.boards.length)return void this.stopTick();const e=this.el.components.raycaster;for(let t of this.boards)this.tryDrawOnBoard(e,t)},startTick(){this.el.sceneEl.addBehavior(this)},stopTick(){this.el.sceneEl.removeBehavior(this)},tryDrawOnBoard:function(){const e=new THREE.Vector2;return function(t,i){const n=this.data,a=t.getIntersection(i.el);if(!a)return!1;if(!i.ctx){let e,t;a.object&&a.object.isMesh&&(t=a.object.material.map)&&t.image&&t.image instanceof HTMLCanvasElement&&(e=t.image),i.ctx=e?e.getContext("2d"):void 0,i.texture=t}const s=i.ctx,r=i.texture;if(i.radius<0&&s)if(i.prevIntersection){const e=a.point.distanceTo(i.prevIntersection.point);if(e>.001){const t=n.radius/e,r=t*(a.uv.x-i.prevIntersection.uv.x)*s.canvas.width,o=t*(a.uv.y-i.prevIntersection.uv.y)*s.canvas.height;i.radius=Math.hypot(r,o),i.prevIntersection=void 0}}else i.prevIntersection=a;const o=i.radius;if(s&&r&&o>0){e.set(a.uv.x,a.uv.y),r.transformUv(e);const t=s.canvas,o=e.x*t.width,l=e.y*t.height,c=i.radius;s.beginPath(),s.fillStyle=n.color,s.arc(o,l,c,0,2*Math.PI),s.fill(),ze(this.el.sceneEl.object3D,t)}return!0}}()});const Ke="a1,b1,c1,d1,e1,f1,g1,h1,a2,b2,c2,d2,e2,f2,g2,h2".split(","),Je="a8,b8,c8,d8,e8,f8,g8,h8,a7,b7,c7,d7,e7,f7,g7,h7".split(","),et={x:1,y:0,z:0},tt={x:0,y:1,z:0},it={x:0,y:0,z:1};function nt(e,t){const i=e.getObjectByProperty("isMesh",!0);if(i)return i.material=t}AFRAME.registerComponent("chess",{schema:{src:{default:""},whitePieces:{default:""},blackPieces:{default:""},boardMesh:{default:""},blackColor:{type:"color",default:""},whiteColor:{type:"color",default:""},debug:{default:!0}},init(){this.onObject3dSet=this.onObject3dSet.bind(this),this.onHoverStart=this.onHoverStart.bind(this),this.onHoverEnd=this.onHoverEnd.bind(this),this.onGrabStart=this.onGrabStart.bind(this),this.onGrabEnd=this.onGrabEnd.bind(this),this.el.addEventListener("object3dset",this.onObject3dSet),this.el.addEventListener("hoverstart",this.onHoverStart),this.el.addEventListener("hoverend",this.onHoverEnd),this.el.addEventListener("grabstart",this.onGrabStart),this.el.addEventListener("grabrend",this.onGrabEnd),this.oldMaterialMap=new Map,this.hoverMaterial=new THREE.MeshStandardMaterial({color:16776960}),this.whiteMaterial=void 0,this.blackMaterial=void 0},remove(){this.el.removeEventListener("object3dset",this.onObject3dSet),this.el.removeEventListener("hoverstart",this.onHoverStart),this.el.removeEventListener("hoverend",this.onHoverEnd),this.el.removeEventListener("grabstart",this.onGrabStart),this.el.removeEventListener("grabrend",this.onGrabEnd)},update(){const e=this.data;function t(e,t,i){const n=e.split(",").map((e,i)=>({index:i,meshName:e.trim(),obj3D:void 0,position:t[i]}));return n.length<t.length&&re(this,`not enough ${i}, listed ${n.length}, expecting ${t.length}`),n}this.el.setAttribute("gltf-model",e.src),this.blackPieces=t(e.blackPieces,Ke,"blackPieces"),this.whitePieces=t(e.whitePieces,Je,"whitePieces"),this.board={meshName:e.boardMesh.trim(),obj3D:void 0,bounds:new THREE.Box3,up:new THREE.Vector3},this.blackMaterial=e.blackColor?new THREE.MeshStandardMaterial({color:e.blackColor}):void 0,this.whiteMaterial=e.whiteColor?new THREE.MeshStandardMaterial({color:e.whiteColor}):void 0},createChessSet(e){const t=this.el.sceneEl.systems["grab-system"],i=this.el,n=new THREE.Quaternion,a=new THREE.Vector3,s=this,r=e.getObjectByName(this.board.meshName);function o(a,r,o){for(let l of a){const a="'"===l.meshName[l.meshName.length-1],c=a?l.meshName.slice(0,-1):l.meshName,d=e.getObjectByName(c);if(d){d.visible=!1;const s=d.clone();s.visible=!0,r&&(s.material=r),a&&s.quaternion.premultiply(n),e.add(s),l.obj3D=s,t.registerTarget(i,{obj3D:s,score:"horizontalnearest"})}else re(s,`unable to find ${o} mesh '${c}'`)}}r?(this.board.obj3D=r,this.board.bounds.setFromObject(r),this.board.bounds.getSize(a),this.board.up.copy(a.x<Math.min(a.y,a.z)?et:a.y<Math.min(a.x,a.z)?tt:it),n.setFromAxisAngle(this.board.up,Math.PI)):re(this,`unable to find board mesh '${this.board.meshName}'`),o(this.blackPieces,this.blackMaterial,"blackPieces"),o(this.whitePieces,this.whiteMaterial,"whitePieces")},setupBoard(){if(!this.board.obj3D||this.blackPieces.some(e=>!e.obj3D)||this.whitePieces.some(e=>!e.obj3D))return;const e=this.board.bounds.max.y;for(let t of this.blackPieces){const i=this.xzFromPosition(this.board.bounds,t.position);t.obj3D.position.set(i.x,e,i.z)}for(let t of this.whitePieces){const i=this.xzFromPosition(this.board.bounds,t.position);t.obj3D.position.set(i.x,e,i.z)}},xzFromPosition(e,t){const i=t.charCodeAt(0)-97,n=t.charCodeAt(1)-49,a=e.max.x-e.min.x,s=e.max.z-e.min.z;return{x:e.min.x+(i+.5)*a/8,z:e.min.z+(n+.5)*s/8}},positionFromXZ(e,t,i){const n=e.max.x-e.min.x,a=e.max.z-e.min.z,s=Math.trunc(8*(t-e.min.x)/n),r=Math.trunc(8*(i-e.min.z)/a);return String.fromCharCode(s+97,r+49)},onObject3dSet(e){this.createChessSet(e.detail.object),this.setupBoard()},onHoverStart(e){const t=e.detail.obj3D;t&&(this.oldMaterialMap.has(t)||(this.oldMaterialMap.set(t,function(e){const t=e.getObjectByProperty("isMesh",!0);if(t)return t.material}(t)),nt(t,this.hoverMaterial)))},onHoverEnd(e){const t=e.detail.obj3D;t&&this.oldMaterialMap.has(t)&&(nt(t,this.oldMaterialMap.get(t)),this.oldMaterialMap.delete(t))},onGrabStart(e){},onGrabEnd(e){}}),AFRAME.registerComponent("climb",{schema:{cameraRig:{type:"selector"},enabled:{default:!0},debug:{default:!1}},init(){this.onGrabStart=this.onGrabStart.bind(this),this.onGrabEnd=this.onGrabEnd.bind(this),this.onSceneLoaded=this.onSceneLoaded.bind(this),this.grab={hand:void 0,target:void 0,position:new THREE.Vector3}},tick:function(){let e=new THREE.Vector3;return function(){const t=this.data;if(t.enabled&&this.grab.hand&&this.grab.target){const i=t.cameraRig?t.cameraRig.object3D:this.el.object3D;i&&(this.grab.hand.object3D.getWorldPosition(e).sub(this.grab.position),i.position.sub(e))}}}(),play(){this.addListeners()},pause(){this.removeListeners()},addListeners(){this.el.addEventListener("grabstart",this.onGrabStart),this.el.addEventListener("grabend",this.onGrabEnd)},removeListeners(){this.el.removeEventListener("grabstart",this.onGrabStart),this.el.removeEventListener("grabend",this.onGrabEnd)},onGrabStart(e){this.data.debug&&console.log(Z(this.el),this.attrName,"onGrabStart",Z(e.detail.hand),Z(e.detail.object)),this.grab.hand=e.detail.hand,this.grab.target=e.detail.object,this.grab.hand.object3D.getWorldPosition(this.grab.position)},onGrabEnd(e){this.data.debug&&console.log(Z(this.el),this.attrName,"onGrabEnd",Z(e.detail.hand)),e.detail.hand===this.grab.hand&&(this.grab.hand=void 0)}});let at=0;AFRAME.registerComponent("clone-entity",{schema:{type:"selector"},multiple:!0,update(){const e=this.data;let t=document.importNode(e instanceof HTMLTemplateElement?e.content:e,!0);const i=e=>{e.id&&(e.id+="_clone"+at),e.children.forEach(i)};i(t),this.el.appendChild(t),at++}}),AFRAME.registerComponent("clone-geometry",{schema:{src:{type:"selector"}},init(){this.onObject3DSet=this.onObject3DSet.bind(this)},update(e){if(this.data.src!==e.src){e instanceof HTMLElement&&e.removeEventListener("object3dset",this.onObject3DSet);const t=this.data.src;t instanceof HTMLElement&&"object3D"in t&&(this.cloneObject3D(t),t.addEventListener("object3dset",this.onObject3DSet))}},onObject3DSet(e){e.target===this.data.src&&e.detail.type&&this.cloneObject3D(this.data.src)},cloneObject3D(e){const t=this.el.object3D;for(let e in this.el.object3DMap)this.el.removeObject3D(e);for(;t.children.length>0;)t.remove(t.children[0]);function i(t){for(let i in e.object3DMap)if(t===e.object3DMap[i])return i}for(let n=0;n<e.object3D.children.length;n++){const a=e.object3D.children[n],s=i(a);s?this.el.setObject3D(s,a.clone()):t.add(a.clone())}}});const st=[],rt=.5*Math.PI,ot=Math.PI,lt=3,ct=2**(6*lt);function dt(e,t,i){return(new THREE.Quaternion).setFromEuler(new THREE.Euler(e,t,i))}const ht={F2:{side:4,quaternion:dt(0,0,-ot)},R2:{side:0,quaternion:dt(-ot,0,0)},U2:{side:2,quaternion:dt(0,-ot,0)},L2:{side:1,quaternion:dt(ot,0,0)},D2:{side:3,quaternion:dt(0,ot,0)},B2:{side:5,quaternion:dt(0,0,ot)},"F'":{side:4,quaternion:dt(0,0,rt)},"R'":{side:0,quaternion:dt(rt,0,0)},"U'":{side:2,quaternion:dt(0,rt,0)},"L'":{side:1,quaternion:dt(-rt,0,0)},"D'":{side:3,quaternion:dt(0,-rt,0)},"B'":{side:5,quaternion:dt(0,0,-rt)},F:{side:4,quaternion:dt(0,0,-rt)},R:{side:0,quaternion:dt(-rt,0,0)},U:{side:2,quaternion:dt(0,-rt,0)},L:{side:1,quaternion:dt(rt,0,0)},D:{side:3,quaternion:dt(0,rt,0)},B:{side:5,quaternion:dt(0,0,rt)}};function ut(e){let t=0;for(let i=0;i<e.length;i++)t+=e[i]*Math.pow(2,(e.length-i-1)*lt);return t/ct}AFRAME.registerComponent("cube-puzzle",{schema:{hands:{type:"selectorAll",default:"[hand-controls], [oculus-touch-controls], [vive-controls], [windows-motion-controls]"},grabStart:{default:"triggerdown"},grabEnd:{default:"triggerup"},highlightColor:{type:"color",default:"#555"},snapAngle:{default:20},moves:{default:"",parse:function(e){return e.trim().toUpperCase()}},debug:{default:!1}},init(){this.onGrabStart=this.onGrabStart.bind(this),this.onGrabEnd=this.onGrabEnd.bind(this),this.onBeforeCompile=this.onBeforeCompile.bind(this),this.actionTick={idle:this.tickIdle.bind(this),hold:this.tickHold.bind(this),turn:this.tickTurn.bind(this),turning:this.tickTurning.bind(this)},this.highlightColor=new THREE.Color,this.state={name:"idle",hold:{side:-1,matrix:new THREE.Matrix4},turn:{side:-1,pieces:[],matrices:[],handStart:new THREE.Matrix4,startAngle:0},snapped:!0,activeHands:[]},this.cube=this.createCube(),this.el.setObject3D("mesh",this.cube)},update(e){const t=this.data;for(let e of t.hands)e.addEventListener(t.grabStart,this.onGrabStart),e.addEventListener(t.grabEnd,this.onGrabEnd);this.highlightColor.set(t.highlightColor),this.snapAngle=THREE.Math.degToRad(Math.abs(t.snapAngle)),t.moves!==e.moves&&(this.resetCube(),t.moves.split(" ").forEach(e=>{e&&!this.rotateCube(e)&&re(this,`unknown move "${e}"`)}))},tick(){this.actionTick[this.state.name]()},dispatch(e){this.data.debug&&console.log("action",e.name,e);const t=this.state,i=t.name;switch(e.name){case"grab":if(t.activeHands.push(e.hand),"idle"===t.name)t.name="hold",t.hold.side=-1,this.updateHoldMatrix(t.hold.matrix,t.activeHands[0]);else if("hold"===t.name){const i=t.hold.side;if(t.snapped&&-1!==i){const n=this.getSidePieces(i);t.name="turn",t.turn.side=i,t.turn.pieces=n,t.turn.quaternions=this.quaternions.slice(),t.turn.handStart.copy(e.hand.object3D.matrixWorld),t.turn.startAngle=0}else t.snapped||i!==t.turn.side||(t.name="turning",t.turn.handStart.copy(e.hand.object3D.matrixWorld))}break;case"release":if("hold"===t.name){const i=t.activeHands.indexOf(e.hand);t.activeHands.splice(i,1),t.activeHands.length>0?this.updateHoldMatrix(t.hold.matrix,t.activeHands[0]):t.name="idle"}else if("turn"===t.name||"turning"===t.name){if("turning"===t.name){const e=t.activeHands[1];t.turn.startAngle+=this.calcAngleBetween(t.turn.handStart,e.object3D.matrixWorld)}const i=t.activeHands.indexOf(e.hand);t.activeHands.splice(i,1),t.activeHands.length>0&&this.updateHoldMatrix(t.hold.matrix,t.activeHands[0]),t.name="hold"}break;case"unsnap":"turn"===t.name?(t.name="turning",t.snapped=!1):"turning"===t.name&&(t.snapped=!1);break;case"snap":"turning"===t.name&&(t.snapped=!0);break;case"hover":"hold"===t.name&&(t.hold.side=e.side)}this.data.debug&&t.name!==i&&console.log("newState",t.name)},updateHoldMatrix(e,t){e.getInverse(t.object3D.matrixWorld).multiply(this.el.object3D.matrixWorld)},tickIdle(){this.data.hands.find(e=>this.isNear(e))?this.highlightPieces(this.allPieces):this.highlightPieces(st)},tickHold(){const e=this.state;this.stickToHand(e.activeHands[0]);const t=this.data.hands.find(t=>!e.activeHands.includes(t)&&this.isNear(t));let i=st;if(t){let n=e.turn.side;e.snapped?(n=this.calcBestSide(t,e.hold.side))>=0&&(i=this.getSidePieces(n)):i=e.turn.pieces,e.hold.side!==n&&this.dispatch({name:"hover",side:n})}this.highlightPieces(i)},tickTurn(){const e=this.state;this.stickToHand(e.activeHands[0]),this.highlightPieces(e.turn.pieces);const t=e.activeHands[1],i=this.calcAngleBetween(e.turn.handStart,t.object3D.matrixWorld);Math.abs(i)>this.snapAngle&&this.dispatch({name:"unsnap"})},tickTurning:function(){const e=new THREE.Quaternion,t=new THREE.Quaternion,i=new THREE.Vector3(1,0,0),n=new THREE.Vector3(0,1,0),a=new THREE.Vector3(0,0,1);return function(){const s=this.state;this.stickToHand(s.activeHands[0]),this.highlightPieces(s.turn.pieces);const r=s.activeHands[1],o=s.turn.startAngle+this.calcAngleBetween(s.turn.handStart,r.object3D.matrixWorld),l=Math.round(o/rt)*rt,c=Math.abs(o-l)<this.snapAngle,d=c?l:o;switch(s.turn.side%6){case 0:t.setFromAxisAngle(i,d);break;case 1:t.setFromAxisAngle(i,-d);break;case 2:t.setFromAxisAngle(n,d);break;case 3:t.setFromAxisAngle(n,-d);break;case 4:t.setFromAxisAngle(a,d);break;case 5:t.setFromAxisAngle(a,-d)}for(let i=0;i<s.turn.pieces.length;i++){const n=s.turn.pieces[i];e.fromArray(s.turn.quaternions,4*n),e.premultiply(t),e.toArray(this.quaternions,4*n)}this.instanceQuaternion.needsUpdate=!0,c&&!s.snapped?this.dispatch({name:"snap"}):s.snapped&&!c&&this.dispatch({name:"unsnap"})}}(),calcAngleBetween:function(){const e=new THREE.Vector3,t=new THREE.Vector3,i=new THREE.Vector3;return function(n,a){i.setFromMatrixColumn(n,0),e.setFromMatrixColumn(n,1),t.setFromMatrixColumn(a,1);const s=t.dot(i)<=0?1:-1;return e.angleTo(t)*s}}(),stickToHand:function(){const e=new THREE.Matrix4,t=new THREE.Matrix4;return function(i){const n=this.el.object3D;e.getInverse(this.el.object3D.parent.matrixWorld),t.multiplyMatrices(i.object3D.matrixWorld,this.state.hold.matrix),t.premultiply(e),t.decompose(n.position,n.quaternion,n.scale)}}(),highlightPieces:function(){let e=[];return function(t){if(e!==t&&(e.length!==t.length||e.some(e=>!t.includes(e)))){this.highlights.fill(0);for(let e of t)this.highlights[e]=1;this.instanceHighlight.needsUpdate=!0,e=t}}}(),createCube(){const e=this.createCubeMaterial(),t=new THREE.BoxBufferGeometry(1/3,1/3,1/3),i=(new THREE.InstancedBufferGeometry).copy(t);this.positions=new Float32Array(78),this.quaternions=new Float32Array(104),this.packedFrames=new Float32Array(26),this.highlights=new Float32Array(26),this.allPieces=new Uint8Array(26);let n=0;for(let e=-1;e<=1;e++)for(let t=-1;t<=1;t++)for(let i=-1;i<=1;i++){if(0===e&&0===t&&0===i)continue;let a=3*n;this.positions[a]=e*(1/3),this.positions[a+1]=t*(1/3),this.positions[a+2]=i*(1/3),a=4*n,this.quaternions[a+3]=1;let s=[];for(let n=0;n<6;n++){let a=!1;switch(n){case 0:a=1===e;break;case 1:a=-1===e;break;case 2:a=1===t;break;case 3:a=-1===t;break;case 4:a=1===i;break;case 5:a=-1===i}s.push(a?n:7)}this.packedFrames[n]=ut(s),this.highlights[n]=0,this.allPieces[n]=n,n++}return this.instancePosition=new THREE.InstancedBufferAttribute(this.positions,3),this.instanceQuaternion=new THREE.InstancedBufferAttribute(this.quaternions,4),this.instancePackedFrame=new THREE.InstancedBufferAttribute(this.packedFrames,1),this.instanceHighlight=new THREE.InstancedBufferAttribute(this.highlights,1),i.addAttribute("instancePosition",this.instancePosition),i.addAttribute("instanceQuaternion",this.instanceQuaternion),i.addAttribute("instancePackedFrame",this.instancePackedFrame),i.addAttribute("instanceHighlight",this.instanceHighlight),i.maxInstanceCount=26,new THREE.Mesh(i,e)},createCubeMaterial(){const e=128,t=document.createElement("canvas");t.width=e,t.height=64;const i=t.getContext("2d");i.fillStyle="black",i.fillRect(0,0,e,64),i.fillStyle="red",i.fillRect(2,34,28,28),i.fillStyle="orange",i.fillRect(34,34,28,28),i.fillStyle="white",i.fillRect(66,34,28,28),i.fillStyle="yellow",i.fillRect(98,34,28,28),i.fillStyle="green",i.fillRect(2,2,28,28),i.fillStyle="blue",i.fillRect(34,2,28,28),i.fillStyle="grey",i.fillRect(66,2,28,28);const n=new THREE.CanvasTexture(t),a=new THREE.MeshStandardMaterial({map:n});return a.onBeforeCompile=this.onBeforeCompile,a},resetCube(){const e=new THREE.Matrix4;for(let t of this.cube.children)t.position.set(0,0,0),t.quaternion.set(0,0,0,1),t.matrix.copy(e)},shuffleCube(e=30){const t=Object.keys(ht);for(let i=0;i<e;i++){const e=~~(Math.random()*t.length);this.rotateCube(t[e])}},rotateCube:function(){const e=new THREE.Quaternion;return function(t){const i=ht[t];if(i){const i=ht[t],n=i.side,a=this.getSidePieces(n);for(let t of a)e.fromArray(this.quaternions,4*t),e.premultiply(i.quaternion),e.toArray(this.quaternions,4*t)}return this.instanceQuaternion.needsUpdate=!0,i}}(),calcBestSide:function(){const e=new THREE.Matrix4,t=new THREE.Vector3,i=[{x:1,y:0,z:0},{x:-1,y:0,z:0},{x:0,y:1,z:0},{x:0,y:-1,z:0},{x:0,y:0,z:1},{x:0,y:0,z:-1}];return function(n,a){e.getInverse(this.el.object3D.matrixWorld).multiply(n.object3D.matrixWorld),t.setFromMatrixPosition(e);let s=-1,r=0;for(let e=0;e<i.length;e++){const n=i[e],a=t.dot(n);a>r&&(s=e,r=a)}return r>.6?s:a%6+6}}(),isNear:function(){const e=new THREE.Vector3,t=new THREE.Vector3,i=new THREE.Vector3;return function(n){const a=this.el.object3D;return i.setFromMatrixScale(a.matrixWorld),e.setFromMatrixPosition(n.object3D.matrixWorld),t.setFromMatrixPosition(a.matrixWorld),e.distanceTo(t)<i.length()}}(),getSidePieces:function(){const e=new THREE.Vector3,t=new THREE.Quaternion,i=[e=>e.x>.3,e=>e.x<-.3,e=>e.y>.3,e=>e.y<-.3,e=>e.z>.3,e=>e.z<-.3,e=>e.x>-.1,e=>e.x<.1,e=>e.y>-.1,e=>e.y<.1,e=>e.z>-.1,e=>e.z<.1];return function(n){if(n<0||n>=i.length)return[];const a=i[n];let s=[];for(let i of this.allPieces)e.fromArray(this.positions,3*i),t.fromArray(this.quaternions,4*i),e.applyQuaternion(t),a(e)&&s.push(i);return s}}(),onBeforeCompile(e){let t=e.vertexShader,i=e.fragmentShader;t=(t=(t=(t=t.replace("void main()","\n    attribute vec3 instancePosition;\n    attribute vec4 instanceQuaternion;\n    attribute float instancePackedFrame;\n    attribute float instanceHighlight;\n\n    varying vec3 vHighlightColor;\n\n    vec3 applyQuaternion( const vec3 v, const vec4 q ) \n    {\n      return v + 2. * cross( q.xyz, cross( q.xyz, v ) + q.w * v );\n    }\n\n    void main()")).replace("#include <uv_vertex>",`\n    #include <uv_vertex>\n    {\n      float faceDot = dot( normal, vec3(1., 3., 5.) );\n      float face = abs( faceDot ) - max( 0., sign( faceDot ) );\n      \n      float singleMultipler = ${2**lt}.0;\n      float faceMultipler = pow(2., face * ${lt}.0);\n      float prevFaces = floor( instancePackedFrame * faceMultipler );\n      float frame = floor( instancePackedFrame * faceMultipler * singleMultipler ) - prevFaces * singleMultipler;\n\n      float u0 = mod(frame, 4.0) / 4.0;\n      float v0 = floor(frame / 4.0) / 2.0;\n      vUv = mix( vec2(u0, v0), vec2(u0 + .25, v0 + .5), vUv );\n\n      vHighlightColor = mix(vec3(0.), vec3(.4), float( instanceHighlight ));\n    }`)).replace("#include <begin_vertex>","\n    vec3 transformed = applyQuaternion( position + instancePosition, instanceQuaternion );")).replace("#include <defaultnormal_vertex>","\n    vec3 transformedNormal = normalMatrix * applyQuaternion( objectNormal, -instanceQuaternion );\n    \n    #ifdef FLIP_SIDED\n      transformedNormal = - transformedNormal;\n    #endif\n\n    #ifdef USE_TANGENT\n      vec3 transformedTangent = normalMatrix * applyQuaternion( objectTangent, -instanceQuaternion );\n      #ifdef FLIP_SIDED\n        transformedTangent = - transformedTangent;\n      #endif\n    #endif"),i=(i=i.replace("#include <color_pars_fragment>","\n    #include <color_pars_fragment>\n    varying vec3 vHighlightColor;")).replace("vec3 totalEmissiveRadiance = emissive;","\n    vec3 totalEmissiveRadiance = emissive;\n    totalEmissiveRadiance += vHighlightColor;"),e.vertexShader=t,e.fragmentShader=i},onGrabStart(e){const t=e.target;-1===this.state.activeHands.indexOf(t)&&this.isNear(t)&&this.dispatch({name:"grab",hand:t})},onGrabEnd(e){const t=e.target;-1!==this.state.activeHands.indexOf(t)&&this.isNear(t)&&this.dispatch({name:"release",hand:t})}}),AFRAME.registerComponent("cube-sphere",{schema:{radius:{default:1},segments:{default:16}},update(){this.createMesh()},createMesh(){const e=this.data.segments,t=new THREE.BoxBufferGeometry(1,1,1,e,e,e),i=t.getAttribute("position"),n=t.getAttribute("normal"),a=new THREE.Vector3;for(let e=0;e<i.count;e++){const t=3*e;a.fromArray(i.array,t),a.normalize(),a.toArray(i.array,t),a.toArray(n.array,t)}i.needsUpdate=!0,n.needsUpdate=!0;const s=new THREE.Mesh(t,["red","green","blue","yellow","orange","purple"].map(e=>new THREE.MeshBasicMaterial({color:e})));this.el.setObject3D("mesh",s)}}),AFRAME.registerComponent("extrude",{schema:{shape:{default:""},depth:{default:100},curveSegments:{type:"int",default:12},bevelEnabled:{default:!0},bevelThickness:{default:6},bevelSize:{default:2},bevelSegments:{type:"int",default:3},extrudePath:{default:""},steps:{type:"int",default:1}},update(){const e=this.data,t=Ye(e.shape),i={...e,extrudePath:e.extrudePath?Ye(e.extrudePath):void 0},n=new THREE.ExtrudeBufferGeometry(t,i),a=new THREE.Mesh(n,new THREE.MeshBasicMaterial);this.el.setObject3D("mesh",a)}});AFRAME.registerComponent("face-color",{schema:{color:{type:"color"},faces:{type:"array",parse:function(e){return"string"==typeof e?e.split(",").map(e=>parseInt(e,10)):e}},minPosition:{type:"vec3",default:{x:-1e10,y:-1e10,z:-1e10}},maxPosition:{type:"vec3",default:{x:1e10,y:1e10,z:1e10}},minSlope:{type:"int",default:0},maxSlope:{type:"int",default:90},meshName:{default:"mesh"}},multiple:!0,init(){this.onObject3DSet=this.onObject3DSet.bind(this),this.el.addEventListener("object3dset",this.onObject3DSet),this.isFirstFrame=!0,this.applyingFaceColors=!1},remove(){this.el.removeEventListener("object3dset",this.onObject3DSet)},update(){if(this.isFirstFrame)this.applyFaceColors(),this.isFirstFrame=!1;else{const e=this.el.components;for(let t in e)0===t.indexOf("face-color")&&e[t].applyFaceColors()}},onObject3DSet(e){e.target===this.el&&e.detail.type===this.data.meshName&&this.applyFaceColors()},applyFaceColors(){const e=this.data,t=this.el.getObject3D(e.meshName);if(t&&!this.applyingFaceColors){let i=t.geometry,n=!1;const a=t.material.color;if(a.r<.3&&a.g<.3&&a.b<.3&&se("material color is very dark, face-color will also be dark"),i.isInstancedBufferGeometry)return void se("face-color does not support InstancedBufferGeometry");if(this.applyingFaceColors=!0,i.isGeometry&&(i=(new THREE.BufferGeometry).copy(i),n=!0),i.index&&(i=i.toNonIndexed(),n=!0),!i.getAttribute("color")){const e=new Float32Array(3*i.getAttribute("position").count).fill(1);i.addAttribute("color",new THREE.Float32BufferAttribute(e,3))}const s=i.getAttribute("position"),r=i.getAttribute("normal"),o=i.getAttribute("color"),l=e.minPosition.x-.5,c=e.minPosition.y,d=e.minPosition.z-.5,h=e.maxPosition.x-.5,u=e.maxPosition.y,m=e.maxPosition.z-.5,p=new THREE.Color(e.color),f=1e-5,g=THREE.Math.degToRad,v=Math.cos(g(Math.max(0,e.minSlope)))+f,y=Math.cos(g(Math.max(0,e.maxSlope)))-f;for(let t=0,i=o.count,n=0;t<i;t+=3,n++){let i=!1;if(e.faces.length>0&&!e.faces.includes(n))i=!1;else{i=!0;for(let e=0;e<3;e++){const n=t+e,a=s.getX(n),o=s.getY(n),p=s.getZ(n);if(a<l||a>h||o<c||o>u||p<d||p>m){i=!1;break}const f=Math.abs(r.getY(n));if(f<y||f>v){i=!1;break}}}if(i)for(let e=0;e<3;e++)o.setXYZ(t+e,p.r,p.g,p.b)}o.needsUpdate=!0;const b=t.material;if(b.vertexColors=THREE.VertexColors,n){console.info(`face-color rebuilding mesh '${e.meshName}'`);const t=new THREE.Mesh(i,b);this.el.setObject3D(e.meshName,t)}this.applyingFaceColors=!1}}});const mt=(e,t,i)=>t*i+e,pt=(e,t)=>[e%t,Math.trunc(e/t)];AFRAME.registerComponent("foliage",{schema:{instancePool:{type:"selector"},cellSize:{default:10},avoidance:{default:1},densities:{default:"1"},rotations:{default:"0"},scales:{default:"1"},colors:{default:"white"},intensityMap:{type:"selector"},debugCanvas:{type:"selector"},seed:{default:-1}},multiple:!0,init(){this.cells=[],this.lcg=p(),this.onPoolAvailable=this.onPoolAvailable.bind(this)},remove(){this.data.instancePool&&this.data.instancePool.removeEventListener("pool-available",this.onPoolAvailable),this.removeModels()},update(e){const t=this.data;this.lcg.setSeed(t.seed),this.densities=z(t.densities),this.rotations=z(t.rotations),this.scales=z(t.scales),this.colors=j(t.colors),this.drawCtx=t.debugCanvas instanceof HTMLCanvasElement?t.debugCanvas.getContext("2d"):void 0,t.instancePool&&(this.pool=t.instancePool.components["instance-pool"],t.instancePool.addEventListener("pool-available",this.onPoolAvailable),this.pool.isAvailable()&&this.createFoliage())},tick(){},tock(){},createFoliage(){const e=this.data,t=e.intensityMap,i=t.width,n=t.height;let a;if(t instanceof HTMLCanvasElement)a=t.getContext("2d");else if(t instanceof HTMLImageElement||t instanceof SVGImageElement){const e=document.createElement("canvas");e.width=i,e.height=n,(a=e.getContext("2d")).drawImage(t,0,0)}const s=this.densities.length-1,r=a.getImageData(0,0,i,n).data,o=Float32Array.from({length:r.length/4},(e,t)=>(r[4*t]+r[4*t+1]+r[4*t+2])/766),l=Array.from(o.keys()).sort((e,t)=>o[t]-o[e]);for(let e of this.cells)this.removeModels(e);this.cells=[],this.drawGrid2D(i,n,"black");for(let t of l){const a=Math.trunc(o[t]*(s+2));if(0===a)break;const[r,l]=pt(t,i),c=this.densities[a-1]||1,d=this.rotations[Math.min(this.rotations.length-1,a-1)]||0,h=this.scales[Math.min(this.scales.length-1,a-1)]||1,u=this.colors[Math.min(this.colors.length-1,a-1)]||1,m=this.populateCell(a,t,r,l,i,n,e.cellSize,c,d,h,u,e.avoidance);this.cells[t]=m,this.addModels(m,i,n,e.cellSize)}ze(this.el.sceneEl.object3D,e.debugCanvas)},addModels(e,t,i,n){const a=new THREE.Vector3,s=new THREE.Euler,r=new THREE.Quaternion,o=e.objects.length;if((!e.indexCount||e.indexCount<o)&&(e.indexCount&&this.pool.releaseBlock(o),e.index=this.pool.reserveBlock(o),e.indexCount=o),void 0===e.index)return;const l=e.index;for(let c=0;c<o;c++){const o=e.objects[c];a.x=(o.x-t/2)*n,a.y=0,a.z=(o.y-i/2)*n,r.setFromEuler(s.set(0,o.rotation,0)),this.pool.setScaleAt(l+c,o.scale,o.scale,o.scale),this.pool.setPositionAt(l+c,a.x,a.y,a.z),this.pool.setQuaternionAt(l+c,r.x,r.y,r.z,r.w),this.pool.setColorAt(l+c,o.color.r,o.color.g,o.color.b)}return e.objects.length},removeModels(e){this.poolIndex&&e.indexCount>0&&(this.pool.releaseBlock(e.index),e.indexCount=0,e.index=void 0)},populateCell(e,t,i,n,a,s,r,o,l,c,d,h){const u=h/r,m=e=>e*e,p={id:t,objects:[]};function f(e,t,i,n){if(e)for(let a of e.objects)if(m(a.x-t)+m(a.y-i)<m(n+a.r))return!0;return!1}this.lcg.setSeed(1761*t);const g=N(o,this.lcg.random);let v=0,y=4*g;for(;v<g&&y-- >0;){const t=this.lcg.random()+i,r=this.lcg.random()+n;let o=f(p,t,r,u);if(o=(o=(o=(o=o||i>0&&f(this.cells[mt(i-1,n,a)],t,r,u))||n>0&&f(this.cells[mt(i,n-1,a)],t,r,u))||i<a-1&&f(this.cells[mt(i+1,n,a)],t,r,u))||n<s-1&&f(this.cells[mt(i,n+1,a)],t,r,u))this.drawCircle2D(t/a,r/s,u/a,"red");else{const i=N(l,this.lcg.random),n=N(c,this.lcg.random),o=N(d,this.lcg.random);p.objects.push({level:e,x:t,y:r,r:u,scale:n,rotation:i,color:o}),this.drawCircle2D(t/a,r/s,u/a,"blue",!0),v++}}return p},onPoolAvailable(e){e.detail.pool===this.pool&&this.createFoliage()},drawCircle2D(e,t,i,n,a=!1){this.drawCtx&&(e*=this.drawCtx.canvas.width,t*=this.drawCtx.canvas.height,i*=this.drawCtx.canvas.width,this.drawCtx.beginPath(),this.drawCtx.arc(e,t,i,0,2*Math.PI),a?(this.drawCtx.fillStyle=n,this.drawCtx.fill()):(this.drawCtx.strokeStyle=n,this.drawCtx.stroke()))},drawPoint2D(e,t,i){this.drawCtx&&(e*=this.drawCtx.canvas.width,t*=this.drawCtx.canvas.height,this.drawCtx.fillStyle=i,this.drawCtx.fillRect(e,t,1,1))},drawGrid2D(e,t,i){if(this.drawCtx){this.drawCtx.strokeStyle=i;const n=this.drawCtx.canvas.width/e,a=this.drawCtx.canvas.height/t;for(let i=0;i<e;i++)for(let e=0;e<t;e++)this.drawCtx.strokeRect(i*n,e*a,n,a)}}});var ft={},gt={};AFRAME.registerComponent("gltf-part",{schema:{part:{type:"string"},src:{type:"asset"}},update:function(){var e=this.el;!this.data.part&&this.data.src||this.getModel(function(t){t&&e.setObject3D("mesh",t)})},getModel:function(e){var t=this;if(!gt[this.data.src])return ft[this.data.src]?ft[this.data.src].then(function(i){e(t.selectFromModel(i))}):void(ft[this.data.src]=new Promise(function(i){(new THREE.GLTFLoader).load(t.data.src,function(n){var a=n.scene||n.scenes[0];gt[t.data.src]=a,delete ft[t.data.src],e(t.selectFromModel(a)),i(a)},function(){},console.error)}));e(this.selectFromModel(gt[this.data.src]))},selectFromModel:function(e){var t;if(t=e.getObjectByName(this.data.part))return t.clone();console.error("[gltf-part] `"+this.data.part+"` not found in model.")}});const vt=Symbol("idle"),yt=Symbol("hover"),bt=Symbol("grab");AFRAME.registerSystem("grab-system",{schema:{hands:{type:"selectorAll",default:"[hand-controls], [oculus-touch-controls], [vive-controls], [windows-motion-controls]"},grabStart:{default:"triggerdown"},grabEnd:{default:"triggerup"},debug:{default:!1}},init(){this.grabEvents=new Set,this.onGrabEvent=this.onGrabEvent.bind(this),this.targets=[],this.hands=[]},remove(){this.grabEvents.forEach(e=>this.removeHandListeners(e,this.onGrabEvent))},update(e){const t=this.data;e.hands!==t.hands&&(this.grabEvents.forEach(e=>this.removeHandListeners(e,this.onGrabEvent)),this.hands=t.hands?t.hands.map(e=>({el:e,target:void 0,name:vt})):[],this.grabEvents.forEach(e=>this.addHandListeners(e,this.onGrabEvent)),t.debug&&ae(this,`found ${this.hands.length} hands`))},tick(){for(let e of this.hands)e.name!==bt&&this.checkHover(e)},checkHover(e){const t=this.findOverlapping(e.el,this.targets);this.transition(e,{name:t?yt:vt,target:t})},registerTarget(e,t={}){const i=this.data,n=Object.assign({el:e,obj3D:e.object3D,grabStart:i.grabStart,grabEnd:i.grabEnd},t);-1===this.targets.findIndex(t=>t.el===e&&t.obj3D==n.obj3D)&&(this.targets.push(n),this.grabEvents.add(n.grabStart),this.grabEvents.add(n.grabEnd),this.addHandListeners(n.grabStart,this.onGrabEvent),this.addHandListeners(n.grabEnd,this.onGrabEvent),i.debug&&ae(this,`registered: ${Z(e)}, grabStart: ${n.grabStart}, grabEnd: ${n.grabEnd}`))},unregisterTarget(e,t){const i=t||e.object3D,n=this.targets.findIndex(t=>t.el===e&&t.obj3D===i);-1!==n&&(this.targets.splice(n),this.data.debug&&ae(this,`unregistered ${Z(e)}`))},addHandListeners(e,t){for(let i of this.hands)i.el.addEventListener(e,t),this.data.debug&&ae(this,`add listener '${e}' to ${Z(i.el)}`)},removeHandListeners(e,t){for(let i of this.hands)i.el.removeEventListener(e,t),this.data.debug&&ae(this,`remove listener '${e}' from ${Z(i.el)}`)},sendEvent(e,t,i){this.data.debug&&ae(this,`send '${t}' to '${Z(e)}'`),e.emit(t,i)},findOverlapping(e,t){const i=this.data;let n=Number.MAX_VALUE,a=void 0;const s=e.object3D;s.boundingSphere&&s.boundingBox&&!s.boundingBox.isEmpty()||Be(s,i.debug?65535:void 0);for(let e of t){const t=e.obj3D;t&&(t.boundingSphere&&t.boundingBox&&!t.boundingBox.isEmpty()||Be(t,i.debug?16776960:void 0))}if(!s.boundingBox.isEmpty()){for(let e of t){const t=e.obj3D;if(!t)continue;if(t.boundingBox.isEmpty())continue;if(!Pe(s.boundingBox.min,s.boundingBox.max,s.matrixWorld.elements,t.boundingBox.min,t.boundingBox.max,t.matrixWorld.elements))continue;const i=this.getScore(s,e);i<n&&(n=i,a=e)}return a}},transition(e,t){switch(e.name){case vt:t.name===yt&&(this.sendEvent(t.target.el,"hoverstart",{hand:e.el,obj3D:t.target.obj3D}),e.name=yt,e.target=t.target);break;case yt:t.name===vt?(this.sendEvent(e.target.el,"hoverend",{hand:e.el,obj3D:e.target.obj3D}),e.name=vt,e.target=void 0):t.name===bt?(this.sendEvent(e.target.el,"hoverend",{hand:e.el,obj3D:e.target.obj3D}),this.sendEvent(e.target.el,"grabstart",{hand:e.el,obj3D:e.target.obj3D}),e.name=bt):t.name===yt&&t.target!==e.target&&(this.sendEvent(e.target.el,"hoverend",{hand:e.el,obj3D:e.target.obj3D}),this.sendEvent(t.target.el,"hoverstart",{hand:e.el,obj3D:t.target.obj3D}),e.target=t.target);break;case bt:t.name===vt&&(this.sendEvent(e.target.el,"grabend",{hand:e.el,obj3D:e.target.obj3D}),e.name=vt,e.target=void 0)}return e},onGrabEvent(e){const t=this.hands.find(t=>t.el===e.target);t&&(t.name===bt&&t.target&&t.target.grabEnd===e.type&&t.target.el?this.transition(t,{name:vt}):t.name===yt&&t.target&&t.target.el&&t.target.grabStart===e.type&&this.transition(t,{name:bt}))},getScore(e,t){switch(t.score){case"horizontalnearest":const n=(new THREE.Vector3).setFromMatrixPosition(e.matrixWorld),a=(new THREE.Vector3).setFromMatrixPosition(t.obj3D.matrixWorld),s=(new THREE.Vector3).setFromMatrixColumn(t.obj3D.matrixWorld,3),r=(new THREE.Vector3).subVectors(n,a);return r.setComponent(1,0),r.normalize(),s.setComponent(1,0),s.normalize(),-s.dot(r);case"volume":default:return((i=t.obj3D.boundingBox).max.x-i.min.x)*(i.max.y-i.min.y)*(i.max.z-i.min.z)}var i}}),AFRAME.registerComponent("handle",{schema:{target:{default:"parent"},debug:{default:!1}},events:{grabstart:function(e){this.onGrabStart(e)},grabend:function(e){this.onGrabEnd(e)}},init(){this.onGrabStart=this.onGrabStart.bind(this),this.onGrabEnd=this.onGrabEnd.bind(this),this.grabHand=void 0,this.invHandMatrix=new THREE.Matrix4},tick(){this.grabHand?this.repositionTarget():this.el.sceneEl.removeBehavior(this)},repositionTarget:function(){const e=new THREE.Matrix4,t=new THREE.Matrix4,i=new THREE.Vector3;return function(){const n=this.getTargetObject3D(this.data.target);if(!n)return;const a=this.grabHand.object3D;a.updateMatrixWorld(),n.updateMatrixWorld(),t.getInverse(n.parent.matrixWorld),e.copy(this.invHandMatrix).premultiply(a.matrixWorld).premultiply(t),e.decompose(n.position,n.quaternion,i)}}(),getTargetObject3D(e){switch(e){case"self":return this.el.object3D;case"parent":return this.el.object3D.parent;default:const t=document.querySelector(this.data.target);return t?t.object3D:void 0}},onGrabStart(e){this.data.debug&&console.log(Z(this.el),"onGrabStart",Z(e.detail.hand)),this.grabHand=e.detail.hand,this.el.sceneEl.addBehavior(this);const t=this.getTargetObject3D(this.data.target);if(t){const e=this.grabHand.object3D;e.updateMatrixWorld(),t.updateMatrixWorld(),this.invHandMatrix.getInverse(e.matrixWorld).multiply(t.matrixWorld)}},onGrabEnd(e){this.data.debug&&console.log(Z(this.el),"onGrabEnd",Z(e.detail.hand)),this.grabHand===e.detail.hand&&(this.grabHand=void 0)}});const Et={rgb:[1/765,1/765,1/765,0],rgba:[1/765,1/765,1/765,1/765],r:[1/255,0,0,0],g:[0,1/255,0,0],b:[0,0,1/255,0],a:[0,0,0,1/255]};function xt(e){let t=[];e.parent.updateMatrixWorld();const i=(new THREE.Matrix4).getInverse(e.matrixWorld),n=new THREE.Matrix4,a=new THREE.Vector3;return e.traverse(e=>{const s=e.isMesh?e:void 0;if(s&&s.geometry)if(n.copy(s.matrixWorld).multiply(i),s.geometry.isBufferGeometry){const e=s.geometry.getAttribute("position").array,i=s.geometry.getAttribute("position").itemSize,r=e.length;for(let s=0;s<r;s+=i)a.set(e[s],e[s+1],e[s+2]).applyMatrix4(n),t.push(a.x,a.y,a.z)}else{const e=s.geometry.vertices,i=s.geometry.vertices.length;for(let s=0;s<i;s++)a.copy(e[s]).applyMatrix4(n),t.push(a.x,a.y,a.z)}}),t.length>0?t:void 0}AFRAME.registerComponent("heightfield",{schema:{src:{type:"selector"},numRows:{type:"int",default:32},numCols:{type:"int",default:32},heightScale:{default:.2},channels:{default:"rgb",oneOf:Object.keys(Et)},smooth:{default:!1}},init(){this.onLoaded=this.onLoaded.bind(this),this.loadTextureCallback=this.loadTextureCallback.bind(this),this.geometry=void 0,this.image=void 0},update(e){const t=this.data;e.src!==t.src?this.loadTexture(t.src):e.numRows!==t.numRows||e.numCols!==t.numCols||e.smooth!==t.smooth?this.createHeightfield(this.image):e.heightScale===t.heightScale&&e.channels===t.channels||this.el.getObject3D("mesh")===this.mesh&&this.updateHeightfield(this.image)},loadTexture(e){this.el.sceneEl.systems.material.loadTexture(e,{src:e},this.loadTextureCallback)},loadTextureCallback(e){e&&e.image&&e.image instanceof HTMLElement?this.createHeightfield(e.image):se(`heightfield: unable to access image '${this.data.src}'`)},onLoaded(e){this.createHeightfield(e.target)},createHeightfield(e){this.image!==e&&(this.image&&this.image.removeEventListener("loaded",this.onLoaded),this.image=e,e&&e.addEventListener("loaded",this.onLoaded));const t=this.data.numRows,i=this.data.numCols;let n;if(this.data.smooth)(n=new THREE.PlaneBufferGeometry(1,1,i,t)).applyMatrix((new THREE.Matrix4).set(1,0,0,0,0,0,-1,0,0,-1,0,0,0,0,0,1));else{const e=6*(i*t),a=new Float32Array(3*e),s=new Float32Array(3*e),r=new Float32Array(2*e);n=new THREE.BufferGeometry;for(let e=0;e<t;e++)for(let n=0;n<i;n++){const s=6*(e*i+n)*3,o=6*(e*i+n)*2,l=n/i,c=(n+1)/i,d=e/t,h=(e+1)/t;a[s+3]=a[s+9]=a[s+15]=l-.5,a[s+2]=a[s+5]=a[s+17]=d-.5,a[s+0]=a[s+6]=a[s+12]=c-.5,a[s+8]=a[s+11]=a[s+14]=h-.5,r[o+2]=r[o+6]=r[o+10]=l,r[o+1]=r[o+3]=r[o+11]=1-d,r[o+0]=r[o+4]=r[o+8]=c,r[o+5]=r[o+7]=r[o+9]=1-h}n.addAttribute("position",new THREE.Float32BufferAttribute(a,3)),n.addAttribute("normal",new THREE.Float32BufferAttribute(s,3)),n.addAttribute("uv",new THREE.Float32BufferAttribute(r,2))}const a=this.el.getObject3D("mesh");this.mesh=new THREE.Mesh(n,a?a.material:new THREE.MeshBasicMaterial),this.updateHeightfield(this.image),this.el.setObject3D("mesh",this.mesh)},updateHeightfield(e){let t;e instanceof HTMLCanvasElement?t=e:((t=document.createElement("canvas")).width=e.width,t.height=e.height,t.getContext("2d").drawImage(e,0,0));const i=t.width,n=t.height,a=t.getContext("2d").getImageData(0,0,i,n).data,s=this.data.numRows,r=this.data.numCols,o=this.mesh.geometry.getAttribute("uv"),l=this.mesh.geometry.getAttribute("position"),c=Et[this.data.channels]||Et.rgb,d=this.data.heightScale,h=s*r,u=new Float32Array((s+1)*(r+1)),m=new Float32Array(h),p=(i-1)/r,f=(n-1)/s;for(let e=0;e<=s;e++)for(let t=0;t<=r;t++){const n=4*(Math.floor(t*p)+Math.floor(e*f)*i);u[t+e*(r+1)]=(a[n]*c[0]+a[n+1]*c[1]+a[n+2]*c[2]+a[n+3]*c[3])*d}for(let e=0;e<s;e++)for(let t=0;t<r;t++){const n=4*(Math.floor((t+.5)*p)+Math.floor((e+.5)*f)*i);m[t+e*r]=(a[n]*c[0]+a[n+1]*c[1]+a[n+2]*c[2]+a[n+3]*c[3])*d}if(this.data.smooth)for(let e=0;e<l.count;e++)l.setY(e,u[e]);else for(let e=0;e<s;e++)for(let t=0;t<r;t++){const i=t+e*(r+1),n=t+e*r,a=6*n,s=u[i],c=u[i+1],d=u[i+r+1],h=u[i+r+2],p=m[n],f=t/r,g=(t+1)/r;l.setY(a,c),l.setY(a+1,s),l.setY(a+3,d),l.setY(a+4,h),Math.abs(.5*(s+h)-p)>Math.abs(.5*(d+c)-p)?(l.setX(a+2,f-.5),l.setY(a+2,d),l.setX(a+5,g-.5),l.setY(a+5,c),o.setX(a+2,f),o.setX(a+5,g)):(l.setX(a+2,g-.5),l.setY(a+2,h),l.setX(a+5,f-.5),l.setY(a+5,s),o.setX(a+2,g),o.setX(a+5,f))}this.mesh.geometry.computeVertexNormals(),l.needsUpdate=!0}}),AFRAME.registerComponent("hull",{schema:{points:{default:""},src:{type:"selector"},computeNormals:{default:!1}},init(){this.onObject3DSet=this.onObject3DSet.bind(this)},update(e){const t=this.data;let i;if(t.src===this.el&&re("cannot set 'src' to yourself"),t.src!==e.src&&(e.src&&e.src.removeEventListener("object3dset",this.onObject3DSet),t.src&&(t.src.object3D?(i=xt(t.src.object3D),t.src.addEventListener("object3dset",this.onObject3DSet)):se("'src' must point to an entity"))),t.points!==e.points&&t.points&&!i){const e=t.points.split(",").map(e=>AFRAME.utils.coordinates.parse(e)),n=["x","y","z"];i=Float32Array.from({length:3*e.length},(t,i)=>e[~~(i/3)][n[i%3]])}i&&this.generateHull(i)},generateHull(e){const t=function(e,t=3){const i=e.length;if(i<12)return;const n=[],a=new Float32Array(3),s=new Float32Array(3),r=1e-5;function o(t,i,n){const r=new Float32Array(3);return pe(r,e,e,e,t,i,n),de(r,le(s,e,a,t))>0?{ai:t,bi:i,ci:n,normal:r}:{ai:t,bi:n,ci:i,normal:ve(r,r,-1)}}function l(t){let i=[];for(let a=0;a<n.length;a++)ce(s,le(s,e,e,t,n[a].ai)),de(s,n[a].normal)>r&&i.push(a);return i}function c(e){for(let t=0;t<e.length;){let i=!1;for(let n=t+1;n<e.length;n++)if(e[t][0]===e[n][0]&&e[t][1]===e[n][1]||e[t][1]===e[n][0]&&e[t][0]===e[n][1]){e.splice(n,1),e.splice(t,1),i=!0;break}i||t++}return e}let d=0,h=0;for(let s=0,r=0,l=0,c=t;c<i;c+=t)if(0===r)ue(e,e,1e-5,c,s)||(r=c);else if(0===l)ue(e,e,1e-5,c,r)||(l=c);else if(0===h&&!ue(e,e,1e-5,c,l)&&!ge(e,e,e,e,1e-5,s,r,l,c)){fe(a,e,[s,r,l,h=c]),n.push(o(s,r,l)),n.push(o(s,r,h)),n.push(o(s,l,h)),n.push(o(r,l,h)),d=4;break}if(0!==d){for(let s=3*t;s<i;s+=t){if(s===h)continue;const t=l(s),i=t.flatMap(e=>{const t=n[e];return[[t.ai,t.bi],[t.ai,t.ci],[t.bi,t.ci]]});t.length>1&&c(i),he(a,e,a,d,s,0),ve(a,a,1/(d+1));for(let e=t.length-1;e>=0;--e)n.splice(t[e],1);for(let e of i)n.push(o(e[0],e[1],s));d++}return n.flatMap(e=>[e.ai,e.bi,e.ci])}}(e).flatMap(t=>[e[t],e[t+1],e[t+2]]),i=new THREE.BufferGeometry;i.addAttribute("position",new THREE.BufferAttribute(Float32Array.from(t),3)),this.data.computeNormals&&i.computeVertexNormals();const n=new THREE.Mesh(i,new THREE.MeshBasicMaterial({color:"white"}));this.el.setObject3D("mesh",n)},onObject3DSet(e){const t=this.data;if(e.target===t.src){const e=xt(t.src.object3D);e&&this.generateHull(e)}}}),AFRAME.registerComponent("instance",{schema:{src:{type:"selector"},color:{type:"color",default:"#fff"},dynamic:{default:!1}},init(){this.instancePool=void 0,this.blockIndex=void 0,this.color=new THREE.Color},remove(){this.freeInstance()},update(e){const t=this.data;if(e.src!==t.src){const e=t.src.components["instance-pool"];e?(this.freeInstance(),this.blockIndex=e.reserveBlock(1),this.instancePool=e,void 0===this.blockIndex&&se("no more instances available")):se("no 'instance-pool' found on src")}else re("missing 'src' on 'instance' component");e.dynamic!==t.dynamic&&t.dynamic&&this.el.sceneEl.addBehavior(this),e.color!==t.color&&this.color.set(t.color)},tick(){this.syncTransform(),this.data.dynamic||this.el.sceneEl.removeBehavior(this)},syncTransform(){const e=this.blockIndex;if(this.instancePool&&void 0!==e){let t=this.el.object3D.position;this.instancePool.setPositionAt(e,t.x,t.y,t.z),t=this.el.object3D.quaternion,this.instancePool.setQuaternionAt(e,t.x,t.y,t.z,t.w),t=this.el.object3D.scale,this.instancePool.setScaleAt(e,t.x,t.y,t.z);const i=this.color;this.instancePool.setColorAt(e,i.r,i.g,i.b)}},freeInstance(){this.instancePool&&void 0!==this.blockIndex&&this.instancePool.releaseBlock(this.blockIndex),this.instancePool=void 0,this.blockIndex=void 0}}),AFRAME.registerPrimitive("a-instance",{defaultComponents:{instance:{}},mappings:{src:"instance.src",color:"instance.color",dynamic:"instance.dynamic"}});AFRAME.registerComponent("instance-pool",{schema:{size:{default:1e3},patchShader:{default:!0}},init(){this.oldMesh=void 0,this.positions=void 0,this.colors=void 0,this.quaternions=void 0,this.scales=void 0,this.instancedGeoemtry=void 0,this.reservedCount=0,this.occupiedBlocks=[],this.freeBlocks=[],this.inCreateInstances=!1,this.onObject3DSet=this.onObject3DSet.bind(this),this.onBeforeCompile=this.onBeforeCompile.bind(this),this.el.addEventListener("object3dset",this.onObject3DSet)},remove(){this.el.removeEventListener("object3dset",this.setobject3d),this.destroyInstances()},update(){this.createInstances()},onObject3DSet(e){this.inCreateInstances||e.target!==this.el||"mesh"!==e.detail.type||(this.destroyInstances(),this.createInstances())},createInstances(){const e=this.el.getObject3D("mesh"),t=e?e.getObjectByProperty("isMesh",!0):void 0;if(!t||!t.geometry||!t.material)return;this.inCreateInstances=!0,this.oldMesh=t;const i=this.data,n=(new THREE.InstancedBufferGeometry).copy(t.geometry),a=i.size;n.maxInstancedCount=0;const s=this.positions&&this.positions.length===a?this.positions:new Float32Array(3*a),r=this.scales&&this.scales.length===a?this.scales:new Float32Array(3*a).fill(0),o=this.colors&&this.colors.length===a?this.colors:new Float32Array(4*a).fill(1),l=this.quaternions&&this.quaternions===a?this.quaternions:new Float32Array(4*a).map((e,t)=>(t-3)%4?0:1);this.instancePosition=new THREE.InstancedBufferAttribute(s,3),this.instanceQuaternion=new THREE.InstancedBufferAttribute(l,4),this.instanceScale=new THREE.InstancedBufferAttribute(r,3),this.instanceColor=new THREE.InstancedBufferAttribute(o,4),n.addAttribute("instancePosition",this.instancePosition),n.addAttribute("instanceQuaternion",this.instanceQuaternion),n.addAttribute("instanceScale",this.instanceScale),n.addAttribute("instanceColor",this.instanceColor);let c=t.material;i.patchShader&&(Array.isArray(t.material)?(c=t.material.map(e=>e.clone())).forEach(e=>e.onBeforeCompile=this.onBeforeCompile(e.onBeforeCompile)):(c=t.material.clone()).onBeforeCompile=this.onBeforeCompile(c.onBeforeCompile));const d=new THREE.Mesh(n,c);d.frustumCulled=!1,this.el.setObject3D("mesh",d),this.instancedGeoemtry=n,this.positions=s,this.quaternions=l,this.scales=r,this.colors=o,this.reservedCount=0,this.freeBlocks=[[0,a]],this.occupiedBlocks=[],this.inCreateInstances=!1,this.el.emit("pool-available",{pool:this})},destroyInstances(){this.oldMesh&&(this.el.setObject3D("mesh",this.oldMesh),this.oldMesh=void 0),this.instancedGeoemtry=void 0,this.positions=void 0,this.quaternions=void 0,this.scales=void 0,this.colors=void 0,this.freeBlocks=[],this.occupiedBlocks=[]},onBeforeCompile(e){const t=e;return function(e){t&&t(e);let i=e.vertexShader,n=e.fragmentShader;i=(i=(i=(i=i.replace("void main()","\n      attribute vec3 instancePosition;\n      attribute vec4 instanceQuaternion;\n      attribute vec4 instanceColor;\n      attribute vec3 instanceScale;\n  \n      varying vec4 vInstanceColor;\n  \n      vec3 applyQuaternion( const vec3 v, const vec4 q ) \n      {\n        return v + 2. * cross( q.xyz, cross( q.xyz, v ) + q.w * v );\n      }\n  \n      void main()")).replace("#include <color_vertex>","\n      #include <color_vertex>\n      vInstanceColor = instanceColor;")).replace("#include <begin_vertex>","\n      vec3 transformed = applyQuaternion( position*instanceScale, instanceQuaternion ) + instancePosition;")).replace("#include <defaultnormal_vertex>","\n      vec3 transformedNormal = normalMatrix * applyQuaternion( objectNormal/instanceScale, -instanceQuaternion );\n      \n      #ifdef FLIP_SIDED\n        transformedNormal = - transformedNormal;\n      #endif\n  \n      #ifdef USE_TANGENT\n        vec3 transformedTangent = normalMatrix * applyQuaternion( objectTangent/instanceScale, -instanceQuaternion );\n        #ifdef FLIP_SIDED\n          transformedTangent = - transformedTangent;\n        #endif\n      #endif"),n=(n=n.replace("#include <color_pars_fragment>","\n      #include <color_pars_fragment>\n      varying vec4 vInstanceColor;")).replace("#include <color_fragment>","\n      #include <color_fragment>\n      diffuseColor *= vInstanceColor;"),e.vertexShader=i,e.fragmentShader=n}},isAvailable(){return!!this.instancedGeoemtry},reserveBlock(e){if(!(e<=0))for(let t=this.freeBlocks.length-1;t>=0;t--){const i=this.freeBlocks[t],n=i[1]-e;if(n>=0){const t=[i[0],e];if(this.occupiedBlocks.push(t),this.instancedGeoemtry.maxInstancedCount=Math.max(this.instancedGeoemtry.maxInstancedCount,t[0]+t[1]),n>0)i[0]+=e,i[1]=n;else{const e=this.freeBlocks;this.freeBlocks.splice(e,1)}return t[0]}}},releaseBlock(e){for(let t=0;t<this.occupiedBlocks.length;t++){const i=this.occupiedBlocks[t];if(i[0]===e){for(let t=e;t<e+i[1];t++)this.setScaleAt(t,0,0,0);this.occupiedBlocks.splice(t,1),this.freeBlocks.push(i),this.repartionBlocks(i);const n=this.occupiedBlocks.reduce((e,t)=>Math.max(e,t[0]+t[1]),0);return this.instancedGeoemtry.maxInstancedCount=Math.max(this.instancedGeoemtry.maxInstancedCount,n),!0}}return!1},repartionBlocks(){for(let e=this.freeBlocks.length-1;e>=0;e--){const t=this.freeBlocks[e];for(let i=0;i<e;i++){const n=this.freeBlocks[i];if(n[0]==t[0]+t[1]){n[0]=t[0],n[1]+=t[1],this.freeBlocks.splice(e,1);break}if(n[0]+n[1]===t[0]){n[1]+=t[1],this.freeBlocks.splice(e,1);break}}}},setColorAt(e,t,i,n,a){const s=4*e;this.colors[s]=t,this.colors[s+1]=i,this.colors[s+2]=n,this.colors[s+3]=void 0!==a?a:1,this.instanceColor.needsUpdate=!0},setPositionAt(e,t,i,n){const a=3*e;this.positions[a]=t,this.positions[a+1]=i,this.positions[a+2]=n,this.instancePosition.needsUpdate=!0},setScaleAt(e,t,i,n){const a=3*e;this.scales[a]=t,this.scales[a+1]=void 0!==i?i:t,this.scales[a+2]=void 0!==n?n:t,this.instanceScale.needsUpdate=!0},setQuaternionAt(e,t,i,n,a){const s=4*e;this.quaternions[s]=t,this.quaternions[s+1]=i,this.quaternions[s+2]=n,this.quaternions[s+3]=a,this.instanceQuaternion.needsUpdate=!0},getPositionAt(e,t){const i=3*e;return t.x=this.positions[i],t.y=this.positions[i+1],t.z=this.positions[i+2],t},getColorAt(e,t){const i=4*e;return t.r=this.colors[i],t.g=this.colors[i+1],t.b=this.colors[i+2],t.a=this.colors[i+3],t},getScaleAt(e,t){const i=3*e;return t.x=this.scales[i],t.y=this.scales[i+1],t.z=this.scales[i+2],t},getQuaternionAt(e,t){const i=4*e;return t.x=this.quaternions[i],t.y=this.quaternions[i+1],t.z=this.quaternions[i+2],t.w=this.quaternions[i+3],t}});function Tt(e,t,i,n=xe){const[a,s]=Ee(t,i,n);switch(e){case"object":return be(t[a],t[a+1],s);case"number":return ye(t[a],t[a+1],s);default:return t[a]}}function wt(e,t){const i=t.split(".");if(i.length<=2)return q(AFRAME.utils.entity.getComponentProperty(e,t));const n=x(e,i);if(n)return q(n[t]);se(`unknown path for getProperty() '${t}'`)}AFRAME.registerComponent("keyframe",{schema:{events:{default:""},delay:{default:0},duration:{default:1},direction:{default:"forward",oneOf:["forward","backward","alternate"]},loops:{default:-1},seed:{default:-1,type:"int"},easing:{default:"linear",oneOf:Object.keys(De)},randomizeEachLoop:{default:!0},enabled:{default:!0},debug:{default:!1},bubbles:{default:!1}},multiple:!0,init(){this.startKeyframes=this.startKeyframes.bind(this),this.lcg=p(),this.loopTime=0,this.loops=0,this.keys={},this.rules={},this.isStarted=!1,this.eventListener=ie(this.el,this.onEvent.bind(this)),this.delayClock=ee()},remove(){this.eventListener.remove(),this.delayClock.clearAllTimers()},play(){this.eventListener.add(),this.delayClock.resume()},pause(){this.eventListener.remove(),this.delayClock.pause()},updateSchema(e){"object"!=typeof e&&console.error(`invalid properties, expected format <property>:<value>; '${e}'`);const t=AFRAME.components[this.name].schema;let i={};for(let n in e)n in t||(i[n]={type:"string"});Object.keys(i).length>0&&this.extendSchema(i)},update(e){const t=this.data,i=AFRAME.components[this.name].schema;e.seed!==t.seed&&this.lcg.setSeed(t.seed);for(let e in this.rules)e in t||(delete this.rules[e],delete this.keys[e]);for(let n in t)if(e[n]!==t[n]&&!(n in i)){const e=t[n];this.rules[n]=e.split(",").map(e=>S(e))}if(e.duration===t.duration&&e.loops===t.loops||(this.loopTime=0,this.loops=0),e.direction!==t.direction&&(this.forward="backward"!==t.direction,this.loopTime=this.forward?0:t.duration),this.generateKeys(!0),this.isComplete()?this.el.sceneEl.removeBehavior(this):this.el.sceneEl.addBehavior(this),t.duration<=0)for(let e in this.keys)K(this.el,e,this.keys[e][0]);t.events!==e.events&&this.eventListener.set(t.events),t.events||t.delay===e.delay||this.delayClock.startTimer(t.delay,this.startKeyframes)},tick(e,t){if(this.data.enabled){const e=Math.min(t,100)/1e3;this.step(e)}},step(e){const t=this.data,i=this.isComplete();if(!i&&this.isStarted){let i=!1;this.loopTime=this.loopTime+(this.forward?e:-e),(this.loopTime>t.duration||this.loopTime<0)&&(this.loops++,i=!0),i&&(t.loops<0||this.loops<t.loops)&&("alternate"===t.direction?(this.forward=!this.forward,this.loopTime=this.loopTime<0?-this.loopTime:2*t.duration-this.loopTime):this.loopTime=this.loopTime+(this.forward?-t.duration:t.duration),t.randomizeEachLoop&&this.generateKeys(!1));const n=De[t.easing]||De.linear;for(let e in this.keys){let i=THREE.Math.clamp(this.loopTime/t.duration,0,1);const a=Tt(this.keyTypes[e],this.keys[e],i,n);K(this.el,e,a)}}else this.el.sceneEl.removeBehavior(this);this.isStarted&&i&&(this.sendEvent("keyframeend",{name:this.attrName}),this.isStarted=!1)},startKeyframes(){this.isStarted||(this.isStarted=!0,this.el.sceneEl.addBehavior(this),this.sendEvent("keyframestart",{name:this.attrName}))},isComplete(){const e=this.data;return e.duration<=0||e.loops>0&&this.loops>e.loops},generateKeys(e){let t;this.keys={},this.keyTypes={};for(let i in this.rules){this.keys[i]=[];for(let n=0,a=this.rules[i].length;n<a;n++){const s=this.forward?n:a-1-n,r=this.rules[i][s];if(e){const e=r.range&&r.range.includes(""),a=r.options&&r.options.includes("");if(e||a){let s=0==n?M(wt(this.el,i)):t;e&&(r.range=r.range.map(e=>""===e?s:e)),a&&(r.options=r.options.map(e=>""===e?s:e))}}t=N(r,this.lcg.random),this.keys[i][s]=t,this.keyTypes[i]=this.keyTypes[i]||typeof t}}},sendEvent(e,t){this.data.debug&&console.log(Z(this.el),this.attrName,"send",e,t,this.data.bubbles),this.el.emit(e,t,this.data.bubbles)},onEvent(e){this.data.debug&&console.log(Z(this.el),this.attrName,"onEvent",e.type),this.delayClock.startTimer(this.data.delay,this.startKeyframes)}});const At=THREE.Math.degToRad;AFRAME.registerComponent("lathe",{schema:{shape:{default:""},steps:{type:"int",default:1},segments:{type:"int",default:12},phiStart:{default:0},phiEnd:{default:360}},update(){const e=this.data,t=Ye(e.shape).extractPoints(e.steps).shape,i=new THREE.LatheBufferGeometry(t,e.segments,At(e.phiStart),At(e.phiEnd)),n=new THREE.Mesh(i,new THREE.MeshBasicMaterial);this.el.setObject3D("mesh",n)}});const Rt={error:"red",warn:"yellow",log:"white",info:"grey"};function St(e){if(0===e.length)return"";let t=1;return e[0].toString().replace(/%(\.(\d+))?([cdfios])/g,(i,n,a,s)=>{let r;switch(s){case"c":return t++,"";case"d":case"i":return r=parseInt(e[t++],10),a?r.toString().padStart(a,"0"):r;case"f":return r=parseFloat(e[t++]),a?r.toFixed(a):r;case"o":return"[object]";case"s":return e[t++]}})+(t<e.length?" "+e.slice(t).join(" "):"")}function Mt(e){return e.toLowerCase()}AFRAME.registerSystem("logger",{init(){this.loggers=[],this.isLogging=!1},remove(){this.releaseLogs(),console.assert(0===this.loggers.length)},captureLogs(){this.oldLog=console.log,this.oldError=console.error,this.oldWarn=console.warn,this.oldInfo=console.info,console.log=((...e)=>{this.sendToLogger("log",St(e)),this.oldLog(...e)}),console.error=((...e)=>{this.sendToLogger("error",St(e)),this.oldError(...e)}),console.warn=((...e)=>{this.sendToLogger("warn",St(e)),this.oldWarn(...e)}),console.info=((...e)=>{this.sendToLogger("info",St(e)),this.oldInfo(...e)})},releaseLogs(){console.log=this.oldLog,console.error=this.oldError,console.warn=this.oldWarn,console.info=this.oldInfo},sendToLogger(e,t){if(!this.isLogging){this.isLogging=!0;for(let i of this.loggers)i.showMessage(e,t);this.isLogging=!1}},registerLogger(e){this.loggers.push(e),1===this.loggers.length&&this.captureLogs()},unregisterLogger(e){this.loggers.splice(this.loggers.indexOf(e),1),0===this.loggers.length&&this.releaseLogs()}}),AFRAME.registerComponent("logger",{schema:{maxLines:{default:20},offset:{type:"vec2",default:{x:2,y:2}},lineHeight:{default:12},columnWidth:{default:80},characterWidth:{default:7.3},types:{type:"array",default:["log","error","warn"]},filter:{default:""},font:{default:"1em monospace"}},init(){this.dirty=!0,this.messages=[],this.onObject3DSet=this.onObject3DSet.bind(this),this.system.registerLogger(this),this.createTexture(),this.el.addEventListener("object3dset",this.onObject3DSet)},remove(){this.el.removeEventListener("object3dset",this.onObject3DSet),this.system.unregisterLogger(this)},update(e){const t=this.data;e.filter!==t.filter&&(this.filter=t.filter?new RegExp(t.filter):void 0)},tick(){this.dirty&&this.imageEl.isReady&&this.updateTexture()},createTexture(){this.imageEl=document.createElement("img"),this.imageEl.width=512,this.imageEl.height=512,this.imageEl.isReady=!0;const e=this.texture=new THREE.Texture(this.imageEl);this.imageEl.onload=(()=>{e.needsUpdate=!0}),this.imageEl.onerror=(()=>{e.image.isReady=!0}),e.onUpdate=(()=>{e.image.isReady=!0}),this.showTexture()},updateTexture(){const e=this.imageEl,t=this.data,i=t.columnWidth*t.characterWidth,n=(t.maxLines+1)*t.lineHeight;const a="data:image/svg+xml;utf8,"+function(e){return e.replace(/%/g,"%25").replace(/#/g,"%23")}(`<svg viewBox="0 0 ${i} ${n}" preserveAspectRatio="none" xmlns="http://www.w3.org/2000/svg" version="1.1">\n      <rect x="0" y="0" width="${i}" height="${n}" fill="#111"/>\n      <style> text { font: ${t.font}; }></style>\n      ${this.messages.map((e,i)=>{const n=t.offset.y+t.lineHeight*(i+1),a=t.offset.x,s=e[1].replace(/[^\x20-\x7E\n\t]/g,"").replace(/[&<>'"]/g,e=>"&"===e?"&amp;":"<"===e?"&lt;":">"===e?"&gt;":"'"===e?"&apos;":"&quot;");return`<text x="${a}" y="${n}" fill="${Rt[e[0]]}">${s}</text>`}).join("\n")}\n    </svg>`);e.src=a,e.isReady=!1,this.dirty=!1},showTexture(){const e=this.el.getObject3D("mesh");e&&e.material&&(e.material.map=this.texture)},showMessage(e,t){const i=this.data;if(!i.types.includes(e))return;if(this.filter&&!this.filter.test(t))return;const n=t.split("\n");for(let t of n)for(let n=0,a=t.length;n<a;n+=i.columnWidth)this.messages.push([e,t.slice(n,Math.min(a,n+i.columnWidth))]);for(;this.messages.length>=this.data.maxLines;)this.messages.shift();this.dirty=!0},onObject3DSet(e){this.showTexture()}}),AFRAME.registerPrimitive("a-logger",{defaultComponents:{geometry:{primitive:"plane",height:3,width:3},material:{color:"white",shader:"flat",side:"double"},logger:{}},mappings:{types:"logger.types",filter:"logger.filter"}}),AFRAME.registerComponent("manipulate",{schema:{hands:{type:"selectorAll"},oneHanded:{default:"grab"},twoHanded:{default:"grab, uniformscale",parse:Mt},pivot:{type:"vec3",default:{x:0,y:0,z:0}},startEvent:{default:"triggerdown",parse:Mt},endEvent:{default:"triggerup",parse:Mt},enabled:{default:!0},debug:{default:!1}},init(){this.onStartEvent=this.onStartEvent.bind(this),this.onEndEvent=this.onEndEvent.bind(this),this.isEnabled=!1,this.sides=[],this.activeSides=[],this.capture={object3D:void 0,startPosition:new THREE.Vector3,startQuaternion:new THREE.Quaternion,startScale:new THREE.Vector3,handGap:new THREE.Vector3,startGap:new THREE.Vector3,invPivotMatrix:new THREE.Matrix4,startWorldPosition:new THREE.Vector3,pivotPos:new THREE.Vector3,pivotQuat:new THREE.Quaternion}},update(e){const t=this.data;if(t.hands!==e.hands&&(this.sides.length=0,t.hands))for(let e=0;e<t.hands.length;e++)this.sides.push({handEl:t.hands[e],grabPosition:new THREE.Vector3});this.oneHanded=this.parseConstraints(t.oneHanded),this.twoHanded=this.parseConstraints(t.twoHanded),e.enabled!==t.enabled&&(t.enabled?this.enable():this.disable())},play(){this.data.enabled&&this.enable()},pause(){this.disable()},tick(){1===this.activeSides.length?this.tickOneHanded(this.activeSides[0]):2===this.activeSides.length&&this.tickTwoHanded(this.activeSides)},enable(){if(!this.isEnabled){for(let e of this.sides)this.addListeners(e.handEl);this.isEnabled=!0}},disable(){if(this.isEnabled){this.activeSides.length=0;for(let e of this.sides)this.removeListeners(e.handEl);this.isEnabled=!1}},onStartEvent(e){this.data.debug&&console.log(oe(this),"onStartEvent",e.type,Z(e.target));for(let t of this.sides)e.target===t.handEl&&this.activateSide(t)},onEndEvent(e){this.data.debug&&console.log(oe(this),"onEndEvent",e.type,Z(e.target));for(let t of this.sides)e.target===t.handEl&&this.deactivateSide(t)},addListeners(e){e&&(this.data.startEvent||this.data.endEvent)&&(this.data.debug&&console.log(oe(this),"addListeners",this.data.startEvent,this.data.endEvent,Z(e)),e.addEventListener(this.data.startEvent,this.onStartEvent),e.addEventListener(this.data.endEvent,this.onEndEvent))},removeListeners(e){e&&(this.data.startEvent||this.data.endEvent)&&(this.data.debug&&console.log(oe(this),"removeListeners",this.data.startEvent,this.data.endEvent,Z(e)),e.removeEventListener(this.data.startEvent,this.onStartEvent),e.removeEventListener(this.data.endEvent,this.onEndEvent))},activateSide(e){-1===this.activeSides.indexOf(e)&&(this.activeSides.push(e),this.captureStartPositions())},deactivateSide(e){const t=this.activeSides.indexOf(e);-1!==t&&(this.activeSides.splice(t,1),this.captureStartPositions())},captureStartPositions:function(){const e=new THREE.Matrix4,t=new THREE.Vector3(1,1,1);return function(){const i=this.data,n=i.target?i.target.object3D:this.el.object3D;if(this.capture.object3D=n,n){for(let e of this.activeSides)e.handEl.object3D.getWorldPosition(e.grabPosition);n.updateMatrixWorld(),this.capture.startWorldPosition.copy(i.pivot).applyMatrix4(n.matrixWorld),this.capture.startPosition.copy(n.position),this.capture.startQuaternion.copy(n.quaternion),this.capture.startScale.copy(n.scale);const a=this.activeSides.length;if(a>=2){const i=this.activeSides[0].handEl.object3D,a=this.activeSides[1].handEl.object3D;this.capture.handGap.copy(a.position).sub(i.position),this.calcMatrixFromHands(this.capture.pivotPos,this.capture.pivotQuat,i.position,i.quaternion,a.position,a.quaternion),e.compose(this.capture.pivotPos,this.capture.pivotQuat,t),e.getInverse(e),this.capture.startGap.copy(a.position).applyMatrix4(e).normalize(),this.capture.invPivotMatrix.copy(e).multiply(n.matrix)}else if(1===a){const e=this.activeSides[0].handEl.object3D;this.capture.invPivotMatrix.getInverse(e.matrixWorld).multiply(n.matrixWorld)}}else se(`unable to find Object3D for '${i.target}'`)}}(),tickOneHanded:function(){const e=new THREE.Vector3,t=new THREE.Vector3,i=new THREE.Vector3,n=new THREE.Vector3(1,1,1),a=new THREE.Quaternion,s=new THREE.Matrix4,r=new THREE.Matrix4;return function(o){const l=this.capture.object3D;if(l){const c=o.handEl.object3D;if(c.updateMatrixWorld(),l.parent.updateMatrixWorld(!0),t.copy(o.grabPosition).sub(this.capture.startWorldPosition),c.getWorldPosition(i).sub(this.capture.startWorldPosition),this.oneHanded.uniformScale){const e=i.length()/t.length();n.set(e,e,e),l.scale.copy(n.multiply(this.capture.startScale))}this.oneHanded.scale&&(n.copy(i).divide(t),this.applyMask(n,this.oneHanded.scale,1),l.scale.copy(n.multiply(this.capture.startScale))),this.oneHanded.translate&&(c.getWorldPosition(e).sub(o.grabPosition),this.applyMask(e,this.oneHanded.translate,0),l.position.copy(e.add(this.capture.startPosition))),this.oneHanded.rotate&&(this.applyMask(t,this.oneHanded.rotate,0),this.applyMask(i,this.oneHanded.rotate,0),a.setFromUnitVectors(t.normalize(),i.normalize()),l.quaternion.copy(a.multiply(this.capture.startQuaternion))),this.oneHanded.grab&&(s.getInverse(l.parent.matrixWorld),r.multiplyMatrices(c.matrixWorld,this.capture.invPivotMatrix),r.premultiply(s),r.decompose(l.position,l.quaternion,l.scale))}}}(),tickTwoHanded:function(){const e=new THREE.Vector3,t=new THREE.Vector3,i=new THREE.Vector3,n=new THREE.Vector3,a=new THREE.Vector3,s=new THREE.Vector3,r=new THREE.Vector3(1,1,1),o=new THREE.Vector3,l=new THREE.Quaternion,c=new THREE.Matrix4,d=new THREE.Quaternion,h=new THREE.Matrix4,u=new THREE.Vector3(1,1,1);return function(){const m=this.capture.object3D;if(m){const p=this.activeSides[0].handEl.object3D,f=this.activeSides[1].handEl.object3D;if(e.copy(p.position),t.copy(f.position),i.copy(t).sub(e),this.calcMatrixFromHands(s,d,p.position,p.quaternion,f.position,f.quaternion),c.compose(s,d,u),this.twoHanded.uniformScale){const e=i.length()/this.capture.handGap.length();r.set(e,e,e),m.scale.copy(r.multiply(this.capture.startScale))}this.twoHanded.scale&&(r.copy(i).divide(this.capture.handGap),this.applyMask(r,this.twoHanded.scale,1),m.scale.copy(r.multiply(this.capture.startScale))),this.twoHanded.translate&&(o.copy(s).sub(this.capture.pivotPos),this.applyMask(o,this.twoHanded.translate,0),m.position.copy(o.add(this.capture.startPosition))),this.twoHanded.rotate&&(n.copy(this.capture.handGap),this.applyMask(n,this.twoHanded.rotate,0),this.applyMask(i,this.twoHanded.rotate,0),l.setFromUnitVectors(n.normalize(),i.normalize()),m.quaternion.copy(l.multiply(this.capture.startQuaternion))),this.twoHanded.grab&&(h.getInverse(c),a.copy(t).applyMatrix4(h).normalize(),l.setFromUnitVectors(this.capture.startGap,a),d.multiply(l),c.compose(s,d,u),c.multiply(this.capture.invPivotMatrix),c.decompose(s,d,r),m.position.copy(s),m.quaternion.copy(d))}}}(),calcMatrixFromHands(e,t,i,n,a,s){e.copy(i).add(a).multiplyScalar(.5),t.copy(n).slerp(s,.5)},parseConstraints(e){let t={},i=e.split(",").map(e=>e.trim());for(let e of i)switch(e){case"translate":t.translate={x:!0,y:!0,z:!0};break;case"translate-x":t.translate={...t.translate,x:!0};break;case"translate-y":t.translate={...t.translate,y:!0};break;case"translate-z":t.translate={...t.translate,z:!0};break;case"rotate":t.rotate={x:!0,y:!0,z:!0};break;case"rotate-x":t.rotate={x:!1,y:!0,z:!0};break;case"rotate-y":t.rotate={x:!0,y:!1,z:!0};break;case"rotate-z":t.rotate={x:!0,y:!0,z:!1};break;case"scale":t.scale={x:!0,y:!0,z:!0};break;case"scale-x":t.scale={...t.scale,x:!0};break;case"scale-y":t.scale={...t.scale,y:!0};break;case"scale-z":t.scale={...t.scale,z:!0};break;case"uniformscale":t.uniformScale=!0;break;case"grab":t.grab=!0;break;case"":case"none":break;default:se(this,`unknown constraint: ${e}`)}return t},applyMask(e,t,i){for(let n of["x","y","z"])e[n]=t[n]?e[n]:i}}),function(){var e=AFRAME.utils.debug("components:materialx:error"),t=AFRAME.shaders;function i(e,t){e.dispose(),t.unregisterMaterial(e)}function n(e,t,i,n){var a=!1;if(n.length=0,0===i.length)return!0;if(""===t){(s=e.getObject3D("mesh"))&&s.material&&(n.push(s.material),s.material=i[0],a=!0)}else{var s=e.object3D,r=t.replace(/[\.\{\}\(\)\^\[\]\$]/g,"\\$&").replace(/[\*\?]/g,".$&"),o=new RegExp("^"+r+"$"),l=0;s&&s.traverse(function(e){if(e&&e.material)if(a=!0,Array.isArray(e.material))for(var t=0,s=e.material.length;t<s;t++)o.test(e.material[t].name)&&(n.push(e.material[t]),e.material[t]=i[l],l=(l+1)%i.length);else o.test(e.material.name)&&(n.push(e.material),e.material=i[l],l=(l+1)%i.length)})}return a}AFRAME.registerComponent("materialx",{schema:{alphaTest:{default:0,min:0,max:1},depthTest:{default:!0},depthWrite:{default:!0},flatShading:{default:!1},name:{default:""},npot:{default:!1},offset:{type:"vec2",default:{x:0,y:0}},opacity:{default:1,min:0,max:1},remap:{default:""},repeat:{type:"vec2",default:{x:1,y:1}},shader:{default:"standard",oneOf:Object.keys(AFRAME.shaders),schemaChange:!0},side:{default:"front",oneOf:["front","back","double"]},transparent:{default:!1},vertexColors:{type:"string",default:"none",oneOf:["none","face","vertex"]},visible:{default:!0},blending:{default:"normal",oneOf:["none","normal","additive","subtractive","multiply"]}},multiple:!0,init:function(){this.system=this.el.sceneEl.systems.material,this.material=null,this.oldMaterials=[],this.onObject3DSet=this.onObject3DSet.bind(this),this.el.addEventListener("object3dset",this.onObject3DSet)},update:function(e){var t=this.data;this.shader&&t.shader===e.shader||(n(this.el,e.remap,this.oldMaterials,[]),this.updateShader(t.shader)),this.shader.update(this.data),this.updateMaterial(e)},updateSchema:function(i){var n,a,s,r;"string"==typeof i&&e(`invalid properties, expected format <property>:<value>; '${i}'`),a=i&&i.shader,n=this.oldData&&this.oldData.shader,(s=t[r=a||n]&&t[r].schema)||e("Unknown shader schema "+r),n&&a===n||(this.extendSchema(s),this.updateBehavior())},updateBehavior:function(){var e,t,i=this.el.sceneEl,n=this.schema,a=this;function s(e,i){var n;for(n in t)t[n]=e;a.shader.update(t)}for(e in this.tick=void 0,t={},n)"time"===n[e].type&&(this.tick=s,t[e]=!0);i&&(this.tick?i.addBehavior(this):i.removeBehavior(this))},updateShader:function(e){var i,n=this.data,a=t[e]&&t[e].Shader;if(!a)throw new Error("Unknown shader "+e);(i=this.shader=new a).el=this.el,i.init(n),this.setMaterial(i.material),this.updateSchema(n)},updateMaterial:function(e){var t,i=this.data,n=this.material;for(t in n.alphaTest=i.alphaTest,n.depthTest=!1!==i.depthTest,n.depthWrite=!1!==i.depthWrite,n.name=i.name,n.opacity=i.opacity,n.flatShading=i.flatShading,n.side=function(e){switch(e){case"back":return THREE.BackSide;case"double":return THREE.DoubleSide;default:return THREE.FrontSide}}(i.side),n.transparent=!1!==i.transparent||i.opacity<1,n.vertexColors=function(e){switch(e){case"face":return THREE.FaceColors;case"vertex":return THREE.VertexColors;default:return THREE.NoColors}}(i.vertexColors),n.visible=i.visible,n.blending=function(e){switch(e){case"none":return THREE.NoBlending;case"additive":return THREE.AdditiveBlending;case"subtractive":return THREE.SubtractiveBlending;case"multiply":return THREE.MultiplyBlending;default:return THREE.NormalBlending}}(i.blending),e)break;!t||e.alphaTest===i.alphaTest&&e.side===i.side&&e.vertexColors===i.vertexColors||(n.needsUpdate=!0)},remove:function(){this.el.removeEventListener("object3dset",this.onObject3DSet);var e=this.material;n(this.el,this.data.remap,this.oldMaterials,[]),this.oldMaterials.length=0,i(e,this.system)},setMaterial:function(e){var t=this.el,a=this.system;this.material&&i(this.material,a),this.material=e,a.registerMaterial(e),n(t,this.data.remap,[e],this.oldMaterials)},onObject3DSet(e){"mesh"===e.detail.type&&e.target===this.el&&n(this.el,this.data.remap,[this.material],this.oldMaterials)}})}(),AFRAME.registerComponent("merge-geometry",{dependencies:["material"],schema:{keepColor:{default:!0},keepOriginal:{default:!1}},init(){this.mergeGeometry()},mergeGeometry(){const e=this,t=new THREE.Geometry,i=new THREE.Matrix4,n=this.el.object3D;n.updateMatrixWorld(!0),i.getInverse(n.matrixWorld),n.traverse(function(n){if("Mesh"!==n.type)return;const a=n.geometry.isBufferGeometry?(new THREE.Geometry).fromBufferGeometry(n.geometry):n.geometry;if(e.data.keepColor){const e=Array.isArray(n.material)?n.material[0].color:n.material.color;a.faces.forEach(t=>{3===t.vertexColors.length?(t.vertexColors[0].multiply(e),t.vertexColors[1].multiply(e),t.vertexColors[2].multiply(e)):t.color.multiply(e)})}const s=n.matrixWorld.clone().premultiply(i);t.merge(a,s),e.data.keepOriginal||n.parent.remove(n)});const a=new THREE.Mesh((new THREE.BufferGeometry).fromGeometry(t));if(this.el.setObject3D("mesh",a),e.data.keepColor){this.el.getObject3D("mesh").material.vertexColors=THREE.VertexColors}}});const Ct=2*Math.PI,It=.5*Math.PI,Ot=new THREE.Vector3(0,1,0),Lt=THREE.Math.degToRad;function Dt(e){return{x:Lt(e.x),y:Lt(e.y),z:Lt(e.z)}}function Ft(e){return e.options?Math.max(...e.options):Math.max(...e.range)}function kt(e){return"number"==typeof e}function Pt(e){return"object"==typeof e&&"x"in e&&"y"in e&&"z"in e}function Ht(e){return"object"==typeof e&&"r"in e&&"g"in e&&"b"in e}function jt(e,t){return e.range?e.range.every(t):!!e.options&&e.options.every(t)}function _t(e){if(!e)return;const t=W(e).flatMap(e=>S(e));if(t.every(e=>jt(e,Pt)))return t;se(`unrecognized array of vec3 range options '${e}'`)}function zt(e){if(!e)return;const t=W(e).flatMap(e=>S(e));if(t.every(e=>jt(e,kt)))return t;se(`unrecognized array of float range options '${e}'`)}function Vt(e){return"number"==typeof e?{x:e,y:e,z:e}:e}const Bt={position:_t,velocity:_t,acceleration:_t,radialPosition:zt,radialVelocity:zt,radialAcceleration:zt,angularVelocity:_t,angularAcceleration:_t,orbitalVelocity:zt,orbitalAcceleration:zt,scale:function(e){if(!e)return;const t=W(e).flatMap(e=>S(e));if(t.every(e=>jt(e,Pt)||jt(e,kt)))return t.map(e=>e.range?{range:e.range.map(Vt)}:e.options?{options:e.options.map(Vt)}:void 0);se(`unrecognized array of float or vec3 range options '${e}'`)},color:function(e){if(!e)return;const t=W(e.toLowerCase()).flatMap(e=>S(e));if(t.every(e=>jt(e,Ht)))return t;se(`unrecognized array of color range options '${e}'`)},rotation:_t,opacity:zt};AFRAME.registerComponent("mesh-particles",{schema:{events:{default:""},delay:{default:0},enabled:{default:!0},duration:{default:-1},instancePools:{default:""},spawnRate:{default:"1"},lifeTime:{default:"1"},position:{default:""},velocity:{default:""},acceleration:{default:""},radialType:{default:"circle",oneOf:["circle","sphere","circlexy","circleyz","circlexz"],parse:e=>e.toLowerCase()},radialPosition:{default:""},radialVelocity:{default:""},radialAcceleration:{default:""},angularVelocity:{default:""},angularAcceleration:{default:""},orbitalVelocity:{default:""},orbitalAcceleration:{default:""},scale:{default:""},color:{default:""},rotation:{default:""},opacity:{default:""},source:{type:"string"},destination:{type:"string"},destinationOffset:{type:"vec3"},destinationWeight:{type:"number"},seed:{type:"int",default:-1}},multiple:!0,init(){this.startParticles=this.startParticles.bind(this),this.onEvent=this.onEvent.bind(this),this.isStarted=!1,this.hasListeners=!1,this.spawnID=0,this.spawnCount=0,this.instancePools=[],this.instanceIndices=[],this.particles=[],this.customData={},this.lcg=p(),this.delayClock=ee(),this.eventListener=ie(this.el,this.onEvent)},remove(){this.releaseInstances(),this.eventListener.remove(),this.delayClock.clearAllTimers(),this.source=void 0,this.destination=void 0},play(){this.eventListener.add(),this.delayClock.resume()},pause(){this.eventListener.remove(),this.delayClock.pause()},update(e){const t=this.data;this.lcg.setSeed(t.seed),this.duration=t.duration;for(let i in t)e[i]!==t[i]&&i in Bt&&(this.customData[i]=Bt[i](t[i]));if(t.lifeTime!==e.lifeTime&&(this.lifeTimeRule=S(t.lifeTime),this.maxLifeTime=Ft(this.lifeTimeRule),this.particles=[]),t.source!==e.source&&(this.source=this.el.object3D,t.source)){const e=document.querySelector(t.source);e&&e.object3D?this.source=e.object3D:se(`unable to find object3D on source '${t.source}'`)}if(t.destination!==e.destination&&(this.destination=void 0,t.destination)){const e=document.querySelector(t.destination);e&&e.object3D?this.destination=e.object3D:se(`unable to find object3D on destination '${t.destination}'`)}t.spawnRate===e.spawnRate&&t.lifeTime===e.lifeTime||(this.spawnRateRule=S(t.spawnRate),this.maxParticles=Ft(this.spawnRateRule)*this.maxLifeTime,this.spawnRate=N(this.spawnRateRule,this.lcg.random)),t.instancePools===e.instancePools&&t.spawnRate===e.spawnRate&&t.lifeTime===e.lifeTime||(this.spawnID=0,this.releaseInstances(),this.instancePools=t.instancePools?[].slice.call(document.querySelectorAll(t.instancePools)).map(e=>e.components?e.components["instance-pool"]:void 0).filter(e=>e):this.el.components["instance-pool"]?[this.el.components["instance-pool"]]:[],0===this.instancePools.length?t.instancePools?se(`no 'instance-pool' on the entities: '${t.instancePools}'`):se("no 'instance-pool' component on this element"):(this.instanceIndices=this.instancePools.map(e=>e.reserveBlock(Math.ceil(this.maxParticles/this.instancePools.length))),this.instanceIndices.forEach((e,t)=>{void 0===e&&se(`unable to reserve blocks for instance '${this.instancePools[t].el.id}'`)}))),t.events!==e.events&&(this.eventListener.set(t.events),t.events||(this.startTime=t.delay,this.startParticles()))},tick(e,t){const i=.001*e,n=Math.min(.1,.001*t),a=this.duration<0||i-this.startTime<this.duration;if(this.isStarted&&a&&this.instancePools.length>0&&this.data.enabled)for(this.spawnCount+=this.spawnRate*n,this.spawnCount>1&&(this.spawnRate=N(this.spawnRateRule,this.lcg.random));this.spawnCount>1;)this.spawn(),this.spawnCount--;else this.isStarted&&!a&&this.stopParticles();this.move(n)},onEvent(e){this.delayClock.startTimer(this.delay,this.startParticles)},startParticles(){this.isStarted=!0,this.startTime=this.el.sceneEl.clock.elapsedTime},stopParticles(){this.isStarted=!1},releaseInstances(){this.instancePools.forEach((e,t)=>e.releaseBlock(this.instanceIndices[t])),this.instanceIndices.length=0,this.particles=[],this.spawnID=0,this.spawnCount=0},configureRandomizer(e){this.data.seed>0&&(this.lcg.setSeed(e+1),this.lcg.setSeed(this.data.seed+12783891*this.lcg.random()))},instanceFromID(e){const t=e%this.maxParticles,i=e%this.instancePools.length,n=this.instancePools[i];return void 0===this.instanceIndices[i]?[void 0,void 0,void 0]:[n,this.instanceIndices[i]+Math.floor(t/this.instancePools.length),t]},spawn(){const e=this.data,t=this.customData,i=this.lcg.random;this.configureRandomizer(this.spawnID);const n={age:0};n.col=new THREE.Color,n.col.a=1,n.pos=new THREE.Vector3(0,0,0),n.vel=new THREE.Vector3(0,0,0),n.acc=new THREE.Vector3(0,0,0),n.angularVel=new THREE.Vector3(0,0,0),n.angularAcc=new THREE.Vector3(0,0,0),n.orbitalVel=0,n.orbitalAcc=0,this.source&&(n.sourcePosition=new THREE.Vector3,n.sourceQuaternion=new THREE.Quaternion,n.sourceScale=new THREE.Vector3,this.source.matrixWorld.decompose(n.sourcePosition,n.sourceQuaternion,n.sourceScale)),n.lifeTime=N(this.lifeTimeRule,i),n.radialPhi="circlexz"!==e.radialType?2*Math.acos(2*i()-1):It,n.radialTheta="circleyz"===e.radialType?0:"circle"===e.radialType||"circlexy"===e.radialType?It:i()*Ct,t.position&&(n.positions=t.position.map(e=>N(e,i))),t.rotation&&(n.rotations=t.rotation.map(e=>Dt(N(e,i)))),t.scale&&(n.scales=t.scale.map(e=>N(e,i))),t.color&&(n.colors=t.color.map(e=>N(e,i))),t.opacity&&(n.opacities=t.opacity.map(e=>N(e,i))),t.velocity&&(n.velocities=t.velocity.map(e=>N(e,i))),t.acceleration&&(n.accelerations=t.acceleration.map(e=>N(e,i))),t.radialPosition&&(n.radialPositions=t.radialPosition.map(e=>N(e,i))),t.radialVelocity&&(n.radialVelocities=t.radialVelocity.map(e=>N(e,i))),t.radialAcceleration&&(n.radialAccelerations=t.radialAcceleration.map(e=>N(e,i))),t.angularVelocity&&(n.angularVelocities=t.angularVelocity.map(e=>Dt(N(e,i)))),t.angularAcceleration&&(n.angularAccelerations=t.angularAcceleration.map(e=>Dt(N(e,i)))),t.orbitalVelocity&&(n.orbitalVelocities=t.orbitalVelocity.map(e=>Lt(N(e,i)))),t.orbitalAcceleration&&(n.orbitalAccelerations=t.orbitalAcceleration.map(e=>Lt(N(e,i)))),n.orbitalAxis=new THREE.Vector3;const a=this.spawnID%this.maxParticles;this.particles[a]=n,this.spawnID++},move:function(){const e=new THREE.Vector3(0,0,0),t=new THREE.Euler(0,0,0,"YXZ"),i=new THREE.Quaternion(0,0,0,1),n=new THREE.Vector3(1,1,1),a=new THREE.Color(0,0,0),s=new THREE.Vector3(0,0,0);return function(r){const o=this.data;for(let l=Math.max(0,this.spawnID-this.maxParticles);l<this.spawnID;l++){const[c,d,h]=this.instanceFromID(l);if(void 0===c)continue;const u=this.particles[h],m=u.age/u.lifeTime,p=0===m;let f=!1,g=!1;if(m>1){c.setScaleAt(d,{x:0,y:0,z:0});continue}const v=u.age;if(u.age+=r,u.positions&&(p||u.positions.length>1)&&u.pos.copy(this.lerpVector(u.positions,m)),u.radialPositions&&(p||u.radialPositions.length>1)&&u.pos.setFromSphericalCoords(this.lerpFloat(u.radialPositions,m),u.radialPhi,u.radialTheta),u.accelerations&&(p||u.accelerations.length>1)&&u.acc.copy(this.lerpVector(u.accelerations,m)),u.radialAccelerations&&(p||u.radialAccelerations.length>1)&&u.acc.setFromSphericalCoords(this.lerpFloat(u.radialAccelerations,m),u.radialPhi,u.radialTheta),u.velocities&&(p||u.velocities.length>1)&&u.vel.copy(this.lerpVector(u.velocities,m)),u.radialVelocities&&(p||u.radialVelocities.length>1)&&u.vel.setFromSphericalCoords(this.lerpFloat(u.radialVelocities,m),u.radialPhi,u.radialTheta),u.accelerations||u.radialAccelerations||u.velocities||u.radialVelocities?(e.copy(u.acc).multiplyScalar(.5*v).add(u.vel).multiplyScalar(v).add(u.pos),f=!0):u.positions||u.radialPositions?e.copy(u.pos):e.set(0,0,0),u.orbitalAccelerations&&(p||u.orbitalAccelerations.length>1)&&(u.orbitalAcc=this.lerpFloat(u.orbitalAccelerations,m)),u.orbitalVelocities&&(p||u.orbitalVelocities.length>1)&&(u.orbitalVel=this.lerpFloat(u.orbitalVelocities,m)),u.orbitalAccelerations||u.orbitalVelocities){p&&u.orbitalAxis.copy(s.copy(u.pos).normalize().cross(Ot).normalize());const t=(u.orbitalVel+.5*v*u.orbitalAcc)*v;i.setFromAxisAngle(u.orbitalAxis,t),e.applyQuaternion(i),f=!0}u.angularAccelerations&&(p||u.angularAccelerations.length>1)&&u.angularAcc.copy(this.lerpVector(u.angularAccelerations,m)),u.angularVelocities&&(p||u.angularVelocities.length>1)&&u.angularVel.copy(this.lerpVector(u.angularVelocities,m)),(u.angularAccelerations||u.angularVelocities)&&(s.copy(u.angularAcc).multiplyScalar(.5*v).add(u.angularVel).multiplyScalar(v),t.set(s.x,s.y,s.z,"YXZ"),i.setFromEuler(t),e.applyQuaternion(i),f=!0),(p||f||this.destination)&&(e.add(u.sourcePosition),this.destination&&(s.copy(o.destinationOffset).applyMatrix4(this.destination.matrixWorld),e.copy(be(e,s,o.destinationWeight*m))),c.setPositionAt(d,e.x,e.y,e.z)),u.opacities&&(p||u.opacities.length>1)&&(u.col.a=this.lerpFloat(u.opacities,m),g=!0),u.colors&&(p||u.colors.length>1)&&(a.copy(this.lerpVector(u.colors,m)),u.col.setRGB(a.r,a.g,a.b),g=!0),(p||g)&&c.setColorAt(d,u.col.r,u.col.g,u.col.b,u.col.a),u.rotations&&(p||u.rotations.length>1)&&(u.rotations.length>0?(t.setFromVector3(this.lerpVector(u.rotations,m)),i.setFromEuler(t),i.premultiply(u.sourceQuaternion)):i.copy(u.sourceQuaternion),c.setQuaternionAt(d,i.x,i.y,i.z,i.w)),u.scales&&(p||u.scales.length>1)&&(n.copy(u.sourceScale),u.scales.length>0&&n.multiply(s.copy(this.lerpVector(u.scales,m))),c.setScaleAt(d,n.x,n.y,n.z)),!u.scales&&p&&c.setScaleAt(d,1,1,1)}}}(),lerpFloat(e,t){const[i,n]=Ee(e,t);return ye(e[i],e[i+1],n)},lerpVector(e,t){const[i,n]=Ee(e,t);return be(e[i],e[i+1],n)}});const Ut=function(e=((e,t)=>void 0),t=w){const i=new Map;let n=[];function a(e,t,i){e.length=0;for(let n=0,a=0;n<t.length;n++){const s=t[n];if(s.attribute===i)if(e[a]=n,s.mode===X)a++;else if(s.mode===Y&&s.source!==$)break}return e}return{set:function(s,r,o,l,c=Q){i.has(r)||i.set(r,new Array);const d=i.get(r);0===a(n,d,o).length&&d.push({source:$,mode:c,attribute:o,value:e(r,o)});const h=n.find(e=>d[e].source===s);t===w?d.push({source:s,mode:c,attribute:o,value:l}):void 0===h?d.push({source:s,mode:c,attribute:o,value:l}):d[h].value=l,a(n,d,o),console.assert(n.length>0);const u=n[0];return 1===n.length?d[u].value:n.map(e=>d[e].value)},unset:function(e,t,s){if(i.has(t)){const r=i.get(t);for(let t=r.length-1;t>=0;t--){const i=r[t];if(i.attribute===s&&i.source===e){r.splice(t,1);break}}if((n=a(n,r,s)).length>0){const e=n[0],t=1===n.length?r[e].value:n.map(e=>r[e].value);return 1===n.length&&r[e].source===$&&r.splice(e,1),t}}},APPEND:X,FIRST:Y,LAST:Q}}((e,t)=>J(e,t),w);function Nt(e,t,i){return e.replace(/\$([\.\w]+)/g,(e,n)=>(function(e,t,i){let n=e;0===e.indexOf("event")?i?n=q(x(i,e.slice(6).split("."))):console.log("value of $event but no event received"):n=q(J(t,e.slice(1)));return n})(n,t,i))}AFRAME.registerComponent("modifier",{schema:{startEvents:{default:""},endEvents:{default:""},source:{default:""},sourceScope:{default:"document",oneOf:["parent","self","document"]},target:{default:""},targetScope:{default:"document",oneOf:["parent","self","document","event"]},seed:{type:"int",default:-1},debug:{default:!1}},multiple:!0,init(){this.onStartEvent=this.onStartEvent.bind(this),this.onEndEvent=this.onEndEvent.bind(this),this.setProperties=this.setProperties.bind(this),this.rules={},this.startEventListener=ie(this.el,this.onStartEvent),this.endEventListener=ie(this.el,this.onEndEvent),this.lcg=p()},remove(){this.startEventListener.remove(),this.endEventListener.remove()},updateSchema(e){"object"!=typeof e&&re(this,`invalid properties, expected format <property>:<value>; '${e}'`);const t=AFRAME.components[this.name].schema;let i={};for(let n in e)n in t||(i[n]={default:""});Object.keys(i).length>0&&this.extendSchema(i)},update(e){const t=AFRAME.components[this.name].schema,i=this.data;i.seed!==e.seed&&this.lcg.setSeed(i.seed);for(let e in this.rules)e in i||delete this.rules[e];for(let n in i)n in t||i[n]===e[n]||(this.rules[n]=S(i[n]));i.startEvents===e.startEvents&&i.endEvents===e.endEvents&&i.source===e.source&&i.sourceScope===e.sourceScope||(this.startEventListener.set(i.startEvents,i.source,i.sourceScope),this.endEventListener.set(i.endEvents,i.source,i.sourceScope))},pause(){this.startEventListener.remove(),this.endEventListener.remove()},play(){this.startEventListener.add(),this.endEventListener.add()},setProperties(e){const t=Nt(this.data.target,this.el,e),i=te(this.el,t,this.data.targetScope,e?e.target:void 0);this.data.debug&&console.log(Z(this.el),this.attrName,"setProperties","target=",t);for(let t of i)for(let i in this.rules){const n=q(N(this.rules[i],this.lcg.random)),a=Nt(n,this.el,e);this.data.debug&&console.log(Z(this.el),this.attrName,"setProperties","element=",Z(t),"property=",i,"value=",n,"$event=",e);const s=Ut.set(this,t,i,a);K(t,i,s)}},clearProperties(e){const t=Nt(this.data.target,this.el,e),i=te(this.el,t,this.data.targetScope,e?e.target:void 0);this.data.debug&&console.log(Z(this.el),this.attrName,"clearProperties","target=",t);for(let e of i)for(let t in this.rules){const i=Ut.unset(this,e,t);K(e,t,i)}},onStartEvent(e){this.data.debug&&console.log(Z(this.el),this.attrName,"onStartEvent",e.type,e),this.setProperties(e)},onEndEvent(e){this.data.debug&&console.log(Z(this.el),this.attrName,"onEndEvent",e.type,e),this.clearProperties(e)}});new THREE.DataTexture(new Uint8Array(3).fill(255),1,1,THREE.RGBFormat);AFRAME.registerComponent("picture",{dependencies:["material "],schema:{src:{type:"string"},side:{oneOf:["front","back","double"],default:"double"}},init(){this.geo=void 0,this.mesh=void 0,this.material=void 0,this.onMaterialTextureLoaded=this.onMaterialTextureLoaded.bind(this),this.el.addEventListener("materialtextureloaded",this.onMaterialTextureLoaded)},remove(){this.el.removeEventListener("materialtextureloaded",this.onMaterialTextureLoaded)},update(e){const t=this.data;this.mesh||this.createMesh(),t.src!==e.src&&(this.el.setAttribute("material","src",t.src),this.el.setAttribute("material","side",t.side))},createMesh(){this.geo=new THREE.PlaneBufferGeometry,this.material=new THREE.MeshStandardMaterial({side:THREE.DoubleSide}),this.mesh=new THREE.Mesh(this.geo,this.material),this.el.setObject3D("mesh",this.mesh)},resizeMesh(e,t){const i=Math.max(e,t),n=this.geo.getAttribute("position"),a=.5*e/i,s=.5*t/i;n.setXYZ(0,-a,s,0),n.setXYZ(1,a,s,0),n.setXYZ(2,-a,-s,0),n.setXYZ(3,a,-s,0),n.needsUpdate=!0},onMaterialTextureLoaded(e){const t=e.detail.src;e.target===this.el&&t&&t.height>0&&t.width>0&&this.resizeMesh(t.width,t.height)}}),AFRAME.registerComponent("pixel-color",{schema:{src:{type:"map"},canvas:{type:"selector"},color:{type:"color"},minSlope:{default:0},maxSlope:{default:90},bottomLeft:{type:"vec2",default:{x:0,y:0}},topRight:{type:"vec2",default:{x:1,y:1}},minIntensity:{default:0},maxIntensity:{default:1}},multiple:!0,init(){this.color=new THREE.Color},update(){const e=this.data;let t=!0;e.src instanceof HTMLCanvasElement||e.src instanceof HTMLImageElement||e.src instanceof SVGImageElement||(t=!1,console.error(`unable to derive an image from 'src' - ${e.src}`)),e.canvas instanceof HTMLCanvasElement||(t=!1,console.error(`unable to find output 'canvas' - ${e.canvas}`)),this.color.set(e.color),t&&this.paintCanvas()},paintCanvas(){const e=this.data,t=e.src.width,i=e.src.height;let n;if(e.src instanceof HTMLCanvasElement)n=e.src.getContext("2d");else if(e.src instanceof HTMLImageElement||e.src instanceof SVGImageElement){const a=document.createElement("canvas");a.width=t,a.height=i,(n=a.getContext("2d")).drawImage(e.src,0,0)}const a=n.getImageData(0,0,t,i),s=a.data,r=Float32Array.from({length:s.length/4},(e,t)=>(s[4*t]+s[4*t+1]+s[4*t+2])/765),o=document.createElement("canvas");o.width=t,o.height=i;const l=o.getContext("2d"),c=l.createImageData(a),d=c.data,h={r:255*this.color.r,g:255*this.color.g,b:255*this.color.b},u=Math.tan(THREE.Math.degToRad(Math.max(0,e.minSlope))),m=Math.tan(THREE.Math.degToRad(Math.max(0,e.maxSlope))),p={x:e.bottomLeft.x*t,y:e.bottomLeft.y*i},f={x:e.topRight.x*t,y:e.topRight.y*i};for(let n=0;n<t;n++)for(let a=0;a<i;a++){const s=a*t+n,o=4*s,l=r[s];let c=n>=p.x&&n<=f.x&&a>=p.y&&a<=f.y;if(c=c&&l>=e.minIntensity&&l<=e.maxIntensity){const e=(0===n?l-r[s+1]:r[s-1]-l)*t,o=(0===a?l-r[s+t]:r[s-t]-l)*i,d=Math.max(Math.abs(e),Math.abs(o));c=d>=u&&d<=m}c?(d[o]=h.r,d[o+1]=h.g,d[o+2]=h.b,d[o+3]=255):d[o+3]=0}l.putImageData(c,0,0),e.canvas.getContext("2d").drawImage(o,0,0,e.canvas.width,e.canvas.height),ze(this.el.sceneEl.object3D,e.canvas)}}),AFRAME.registerSystem("procedural-texture",{init(){this.renderer=void 0,this.proceduralTextureComponents=[]},registerComponent(e){this.proceduralTextureComponents.push(e),this.renderer||this.createRenderer()},unregisterComponent(e){const t=this.proceduralTextureComponents.indexOf(e);-1!==t&&this.proceduralTextureComponents.slice(t,1)},updateProceduralTexturesUsingThisCanvas(e,t){for(let i of this.proceduralTextureComponents)t!==i&&Object.keys(i.uniforms).some(t=>{const n=i.uniforms[t];return"texture"===n.type&&(Array.isArray(n.value)?n.value.any(t=>t.image===e):n.value.image===e)})&&i.update(i.data)},createRenderer(){this.renderer=new THREE.WebGLRenderer({alpha:!0,premultipliedAlpha:!1}),this.renderer.setPixelRatio(window.devicePixelRatio),this.renderer.autoClear=!0,this.renderer.setClearColor(new THREE.Color("purple"),1)}}),AFRAME.registerComponent("procedural-texture",{dependencies:["geometry"],schema:{shader:{type:"string"},canvas:{type:"selector"}},multiple:!0,init(){this.canvas=void 0,this.system.registerComponent(this)},remove(){this.system.unregisterComponent(this)},updateSchema(e){var t=!1;"object"!=typeof e&&console.error(`invalid properties, expected format <property>:<value>; '${e}'`),this.data&&this.data.shader===e.shader||(this.shaderProgram="",this.uniforms={},e.shader&&ne(e.shader,"main(",e=>{this.shaderProgram=e,this.uniforms=this.parseShaderUniforms(this.shaderProgram),t&&this.updateProceduralTexture()}));let i=this.uniformsToSchema(this.uniforms);e.canvas||(i.width={type:"int",value:256},i.height={type:"int",value:256}),Object.keys(i).length>0&&this.extendSchema(i),t=!0},update(e){const t=this.data;if(t.canvas!==e.canvas&&(this.canvas=t.canvas&&t.canvas instanceof HTMLCanvasElement?t.canvas:void 0),!t.canvas&&!this.canvas){this.canvas=document.createElement("canvas"),this.canvas.width=t.width||256,this.canvas.height=t.height||256;const e=this.el.getObject3D("mesh");e&&e.material&&(e.material.map=new THREE.CanvasTexture(this.canvas))}this.canvas&&this.shaderProgram&&this.updateProceduralTexture(),this.usesComponentTime()&&this.el.sceneEl.addBehavior(this)},updateProceduralTexture(){this.scene||this.setupScene(this.canvas,this.shaderProgram),this.updateUniforms(this.uniforms,this.data),this.renderScene(),ze(this.el.sceneEl.object3D,this.canvas),this.system.updateProceduralTexturesUsingThisCanvas(this.canvas),this.canvas.dispatchEvent(new CustomEvent("loaded",{bubbles:!1}))},usesComponentTime(){return"time"in this.uniforms&&!("time"in this.attrValue)},tick(e){this.usesComponentTime()?(this.uniforms.time.value=.001*e,this.renderScene()):this.el.sceneEl.removeBehavior(this)},setupScene(e,t){this.scene=new THREE.Scene,this.camera=new THREE.Camera,this.camera.position.z=1,this.uniforms=this.parseShaderUniforms(t);const i=t.replace(/#include\s*<procedural-ext>/,qt);var n=new THREE.RawShaderMaterial({uniforms:this.uniforms,vertexShader:Gt,fragmentShader:i});const a=new THREE.Mesh(new THREE.PlaneBufferGeometry(2,2),n);this.scene.add(a),this.ctx=e.getContext("2d")},renderScene(){const e=this.ctx.canvas,t=e.width,i=e.height,n=this.system.renderer;n.setSize(t,i),n.render(this.scene,this.camera),this.ctx.clearRect(0,0,t,i),this.ctx.drawImage(this.system.renderer.domElement,0,0)},parseShaderUniforms(e){const t=/uniform (vec2|vec3|vec4|float|int|uint|bool|sampler2D) ([a-zA-Z0-9_]+)(\[(\d+)\])?;/;let i={};return e.split("\n").forEach(e=>{const n=t.exec(e);if(n){const e=n[1],t=n[2],a=void 0!==n[4]?parseInt(n[4],10):0;if(t){const n=i[t]||this.allocateUniform(e,a);i[t]=n}}}),i},uniformsToSchema(e){let t=[];for(let i in e){const n=e[i];switch(n.type){case"texture":t[i]={type:"string"};break;case"float32array":case"int32array":t[i]={type:"string"};break;default:t[i]={type:n.count>1?"string":n.type}}}return t},updateUniforms:function(){let e=new Array(4);const t=e=>Number(e),i=e=>!isNaN(e);function n(n,a,s,r){switch(n){case"texture":const c=r.sceneEl.systems.material,d=document.querySelector(a),h=d||a;c.loadTexture(h,{src:h},e=>{s(e)});break;case"number":s(parseFloat(a));break;case"boolean":s(!!a);break;case"float32array":case"int32array":let u=a.split(" ").map(t).filter(i);if(0==u.length){let t=E(a);t&&(e.fill(1),l=t,(o=e)[0]=l.r,o[1]=l.g,o[2]=l.b,void 0!==l.a&&(o[3]=l.a),u=o)}u.length>0&&s(u)}var o,l}return function(e,t){for(let i in e){const a=t[i],s=e[i];if(void 0===a)se(`no attribute for uniform: ${i}`);else{const e=("string"==typeof a?W(a):[a.toString()]).map(e=>e.trim());if(s.arrayCount>0)for(let t=0;t<e.length;t++){const i=e[t];switch(s.type){case"texture":n(s.type,i,e=>s.value[t]=e,this.el);break;case"number":case"boolean":n(s.type,i,e=>s.value[t]=e,this.el);break;case"float32array":case"in32array":n(s.type,i,e=>s.value.set(e.slice(0,s.size),t*s.size))}}else switch(s.type){case"texture":case"number":case"boolean":n(s.type,e[0],e=>s.value=e,this.el);break;case"float32array":case"in32array":n(s.type,e[0],e=>s.value.set(e.slice(0,s.size)))}}}}}(),allocateUniform(e,t){const i=Math.max(1,t);switch(e){case"sampler2D":return{type:"texture",value:t>0?new Array(t).fill(void 0):void 0,arrayCount:t};case"float":case"int":return{type:"number",value:t>0?new Array(t).fill(0):0,arrayCount:t};case"bool":return{type:"boolean",value:t>0&&new Array(t).fill(!1),arrayCount:t};case"ivec2":case"bvec2":case"vec2":return{type:"float32array",value:new Float32Array(2*i),size:2,arrayCount:t};case"vec3":return{type:"float32array",value:new Float32Array(3*i),size:3,arrayCount:t};case"vec4":return{type:"float32array",value:new Float32Array(4*i),size:4,arrayCount:t};case"ivec3":case"bvec3":return{type:"int32array",value:new Int32Array(3*i),size:3,arrayCount:t};case"ivec4":case"bvec4":return{type:"int32array",value:new Int32Array(4*i),size:4,arrayCount:t};default:se(`unknown uniform type ${e}`)}}});const Gt="\nprecision highp float;\n\nattribute vec3 position;\nattribute vec2 uv;\n\nvarying vec2 vUv;\nvoid main()\n{\n  vUv = uv;\n  gl_Position = vec4( position, 1.0 );\n}",qt="\nprecision highp float;\nprecision highp int;\n\n// FLOAT -> FLOAT\n// could use levels low, high, mid, black, white (mid maps to (black + white)/2)\nfloat remap(float v, float amin, float amax, float bmin, float bmax)\n{\n  return (v - amin)*(bmax - bmin)/(amax - amin) + bmin;\n}\n\nfloat roundF(const float number)\n{\n  return sign(number)*floor(abs(number)+0.5);\n}\n\nfloat quantize(const float v, const float quanta) {\n  return floor(v/quanta)*quanta;\n}\n\n// VEC2 -> VEC2\nvec2 uvBrick(const vec2 uv, const float numberOfBricksWidth, const float numberOfBricksHeight)\n{\n  float yi=uv.y*numberOfBricksHeight;\n  float nyi=roundF(yi);\n  float xi=uv.x*numberOfBricksWidth;\n  if (mod(floor(yi),2.0) == 0.0)\n  {\n    xi=xi-0.5;\n  }\n  float nxi=roundF(xi);\n\n  return vec2((xi-floor(xi))*numberOfBricksHeight,(yi-floor(yi))*numberOfBricksWidth);\n}\n\nvec2 uvTransform(const vec2 uv, const vec2 center, const vec2 scale, const float rad, const vec2 translate) \n{\n  float c = cos(-rad);\n  float s = sin(-rad);\n  float x = (uv.x - translate.x - center.x);\n  float y = (uv.y - translate.y - center.y);\n  float x2 = (x*c + y*s)/scale.x + center.x;\n  float y2 = (-x*s + y*c)/scale.y + center.y;\n  return vec2(x2, y2);\n}\n\nvec2 uvCrop(const vec2 uv, const vec2 uvMin, const vec2 uvMax) \n{\n  vec2 scale = 1./(uvMax - uvMin);\n  return uvTransform(uv, vec2(0.), scale, 0., -uvMin*scale);\n}\n\n\n// SAMPLER2D -> VEC4\nfloat normpdf(const float x, const float sigma)\n{\n  return .39894*exp(-.5*x*x/(sigma*sigma))/sigma;\n}\n\nvec4 blur13(const sampler2D image, const vec2 uv, const vec2 resolution, const float sigma)\n{\n  const int kernelWidth = 13;\n  const int kSize = kernelWidth/2 - 1;\n  float kernel[kernelWidth];\n\n  float Z = 0.;\n\n  for (int j = 0; j <= kSize; j++)\n  {\n    kernel[kSize + j] = kernel[kSize - j] = normpdf(float(j), sigma);\n  }\n  for (int j = 0; j < kernelWidth; j++)\n  {\n    Z += kernel[j];\n  }\n\n  vec4 color = vec4(0.);\n  for (int i = -kSize; i <= kSize; i++)\n  {\n    for (int j = -kSize; j <= kSize; j++)\n    {\n      color += kernel[kSize + j]*kernel[kSize + i]*texture2D( image, uv + vec2(float(i), float(j))/resolution );\n    }\n  }\n\n  return color/(Z*Z);\n}\n\nvec4 terrase13(const sampler2D image, const vec2 uv, const vec2 resolution)\n{\n  const int kernelWidth = 13; // this must be const for webgl1\n  const int kSize = kernelWidth/2 - 1;\n\n  vec4 color = vec4(0.);\n  for (int i = -kSize; i <= kSize; i++)\n  {\n    for (int j = -kSize; j <= kSize; j++)\n    {\n      color = max( color, texture2D( image, uv + vec2(float(i), float(j))/resolution ) );\n    }\n  }\n\n  return color;\n}\n\nvec4 terrase5(const sampler2D image, const vec2 uv, const vec2 resolution)\n{\n  const int kernelWidth = 5; // this must be const for webgl1\n  const int kSize = kernelWidth/2 - 1;\n\n  vec4 color = vec4(0.);\n  for (int i = -kSize; i <= kSize; i++)\n  {\n    for (int j = -kSize; j <= kSize; j++)\n    {\n      color = max( color, texture2D( image, uv + vec2(float(i), float(j))/resolution ) );\n    }\n  }\n\n  return color;\n}\n\nvec4 terrase27(const sampler2D image, const vec2 uv, const vec2 resolution)\n{\n  const int kernelWidth = 27; // this must be const for webgl1\n  const int kSize = kernelWidth/2 - 1;\n\n  vec4 color = vec4(0.);\n  for (int i = -kSize; i <= kSize; i++)\n  {\n    for (int j = -kSize; j <= kSize; j++)\n    {\n      color = max( color, texture2D( image, uv + vec2(float(i), float(j))/resolution ) );\n    }\n  }\n\n  return color;\n}\n\n// VEC2 -> FLOAT\nfloat rand(const vec2 n)\n{\n  return fract(cos(dot(n,vec2(12.9898,4.1414)))*43758.5453);\n}\n\nfloat noise(const vec2 n)\n{\n  const vec2 d=vec2(0.0,1.0);\n  vec2 b=floor(n), f=smoothstep(vec2(0.0), vec2(1.0), fract(n));\n  return mix( mix( rand(b), rand(b+d.yx), f.x ), mix( rand(b+d.xy), rand(b+d.yy), f.x ), f.y );\n}\n\nfloat fbm(vec2 n) {\n  float total=0.0,amplitude=1.0;\n\n  for (int i=0; i<4; i++)\n  {\n    total+=noise(n)*amplitude;\n    n+=n;\n    amplitude*=0.5;\n  }\n\n  return total;\n}\n\nfloat turbulence(const vec2 P)\n{\n  float val=0.0;\n  float freq=1.0;\n\n  for (int i=0; i<4; i++)\n  {\n    val+=abs(noise(P*freq)/freq);\n    freq*=2.07;\n  }\n\n  return val;\n}\n\nfloat brick(const vec2 uv, const float numberOfBricksWidth, const float numberOfBricksHeight, const float jointWidthPercentage, const float jointHeightPercentage)\n{\n  float yi=uv.y*numberOfBricksHeight;\n  float nyi=roundF(yi);\n  float xi=uv.x*numberOfBricksWidth;\n  if (mod(floor(yi),2.0) == 0.0) { xi = xi - 0.5; } // offset every second brick\n  float nxi=roundF(xi);\n  xi = abs(xi - nxi);\n  yi = abs(yi - nyi);\n\n  return 1. - clamp( min(yi/jointHeightPercentage, xi/jointWidthPercentage) + 0.2, 0., 1. );\n}\n\nfloat marble(const vec2 uv, float amplitude, float k)\n{\n  k = 6.28*uv.x/k;\n  k += amplitude*turbulence(uv.xy);\n  k = sin(k);\n  k = .5*(k + 1.);\n  k = sqrt( sqrt( sqrt(k) ) ); \n  return .2 + .75*k;\n}\n\nfloat checkerboard(const vec2 uv, const float numCheckers)\n{\n  float cx = floor(numCheckers * uv.x);\n  float cy = floor(numCheckers * uv.y);\n  return sign( mod(cx + cy, 2.) );\n}\n\nfloat gaussian(const vec2 uv)\n{\n  vec2 xy = (mod(uv, vec2(1.,1.)) - .5)*2.;\n  float exponent = dot(xy,xy)/0.31831;\n  return exp(-exponent);\n}\n\n// from glsl-voronoi-noise\nconst mat2 myt = mat2(.12121212, .13131313, -.13131313, .12121212);\nconst vec2 mys = vec2(1e4, 1e6);\n\nvec2 rhash(vec2 uv) {\n  uv *= myt;\n  uv *= mys;\n  return fract(fract(uv / mys) * uv);\n}\n\nvec3 hash(const vec3 p) {\n  return fract(sin(vec3(dot(p, vec3(1.0, 57.0, 113.0)),\n    dot(p, vec3(57.0, 113.0, 1.0)),\n    dot(p, vec3(113.0, 1.0, 57.0)))) *\n  43758.5453);\n}\n\nfloat voronoi2d(const in vec2 point) {\n  vec2 p = floor(point);\n  vec2 f = fract(point);\n  float res = 0.0;\n  for (int j = -1; j <= 1; j++) {\n    for (int i = -1; i <= 1; i++) {\n      vec2 b = vec2(i, j);\n      vec2 r = vec2(b) - f + rhash(p + b);\n      res += 1. / pow(dot(r, r), 8.);\n    }\n  }\n  return pow(1. / res, 0.0625);\n}\n\n// from glsl-worley\n// Permutation polynomial: (34x^2 + x) mod 289\nvec3 permute(const vec3 x) {\n  return mod((34.0 * x + 1.0) * x, 289.0);\n}\n\nvec3 dist(const vec3 x, const vec3 y) {\n  return (x * x + y * y);\n}\n\nvec2 worley(const vec2 P, const float jitter) {\n  float K= 0.142857142857; // 1/7\n  float Ko= 0.428571428571 ;// 3/7\n  vec2 Pi = mod(floor(P), 289.0);\n  vec2 Pf = fract(P);\n  vec3 oi = vec3(-1.0, 0.0, 1.0);\n  vec3 of = vec3(-0.5, 0.5, 1.5);\n  vec3 px = permute(Pi.x + oi);\n  vec3 p = permute(px.x + Pi.y + oi); // p11, p12, p13\n  vec3 ox = fract(p*K) - Ko;\n  vec3 oy = mod(floor(p*K),7.0)*K - Ko;\n  vec3 dx = Pf.x + 0.5 + jitter*ox;\n  vec3 dy = Pf.y - of + jitter*oy;\n  vec3 d1 = dist(dx,dy); // squared\n  p = permute(px.y + Pi.y + oi); // p21, p22, p23\n  ox = fract(p*K) - Ko;\n  oy = mod(floor(p*K),7.0)*K - Ko;\n  dx = Pf.x - 0.5 + jitter*ox;\n  dy = Pf.y - of + jitter*oy;\n  vec3 d2 = dist(dx,dy); // squared\n  p = permute(px.z + Pi.y + oi); // p31, p32, p33\n  ox = fract(p*K) - Ko;\n  oy = mod(floor(p*K),7.0)*K - Ko;\n  dx = Pf.x - 1.5 + jitter*ox;\n  dy = Pf.y - of + jitter*oy;\n  vec3 d3 = dist(dx,dy); // squared\n\n  // Sort out the two smallest distances (F1, F2)\n  vec3 d1a = min(d1, d2);\n  d2 = max(d1, d2); // Swap to keep candidates for F2\n  d2 = min(d2, d3); // neither F1 nor F2 are now in d3\n  d1 = min(d1a, d2); // F1 is now in d1\n  d2 = max(d1a, d2); // Swap to keep candidates for F2\n  d1.xy = (d1.x < d1.y) ? d1.xy : d1.yx; // Swap if smaller\n  d1.xz = (d1.x < d1.z) ? d1.xz : d1.zx; // F1 is in d1.x\n  d1.yz = min(d1.yz, d2.yz); // F2 is now not in d2.yz\n  d1.y = min(d1.y, d1.z); // nor in  d1.z\n  d1.y = min(d1.y, d2.x); // F2 is in d1.y, we're done.\n  return sqrt(d1.xy);\n}\n";AFRAME.registerComponent("prefab",{schema:{template:{default:""},debug:{default:!1}},init(){this.templateContent=void 0,this.hasPrefab=!1},remove(){this.destroyPrefab()},updateSchema(e){"object"!=typeof e&&console.error(`invalid properties, expected format <property>:<value>; '${e}'`);const t=AFRAME.components[this.name].schema;let i={};for(let n in e)n in t||(i[n]={type:"string"});Object.keys(i).length>0&&this.extendSchema(i)},update(e){const t=this.data;e.template!==t.template&&ne(t.template,"",e=>{this.templateContent=e,this.destroyPrefab(),this.createPrefab()})},createPrefab(){if(!this.hasPrefab){const e=this.processTemplate(this.templateContent);this.el.innerHTML=e,this.hasPrefab=!0,this.data.debug&&console.log(e)}},destroyPrefab(){if(this.hasPrefab){for(;this.el.lastChild;)this.el.removeChild(this.el.lastChild);this.hasPrefab=!1}},processTemplate(e){const t=Object.keys(this.data).concat("return `"+e+"`");return new Function(...t)(...Object.values(this.data))}}),AFRAME.registerComponent("rumble",{schema:{events:{default:""},delay:{default:0},duration:{default:.1},force:{default:1},controllers:{default:""},enabled:{default:!0}},multiple:!0,init(){this.delayClock=ee(),this.eventListener=ie(this.el,this.onEvent.bind(this)),this.pulses=[]},remove(){this.eventListener.remove(),this.stopAllActuators()},play(){this.eventListener.add()},pause(){this.eventListener.remove(),this.stopAllActuators()},update(e){const t=this.data;t.events!==e.events&&this.eventListener.set(t.events),t.controllers!==e.controllers&&(this.stopAllActuators(),this.actuators=[]),t.enabled!==e.enabled&&(t.enabled||this.stopAllActuators())},onEvent(e){const t=this.data;if(!t.enabled)return;const i=this.getActuators(e);if(0===i.length)return;const n=this;var a;this.delayClock.startTimer(t.delay,()=>(a=n.pulses,a=[],void i.map(e=>{a.push(e),e.pulse(t.force,1e3*t.duration).then(()=>{a.splice(a.indexOf(e),1)},t=>{a.splice(a.indexOf(e),1),console.error(t)})})))},stopAllActuators(){this.delayClock.clearAllTimers();for(let e of this.pulses)e.pulse(0,0);this.pulses.length=0},getActuators(e){if(this.actuators.length>0)return this.actuators;const t=this.data,i=t.controllers?document.querySelectorAll(t.controllers):[this.el];let n=[];if(0===i.length)se("no controller elements found");else{for(let e of i)if(e.components["tracked-controls"]&&e.components["tracked-controls"].controller){const t=e.components["tracked-controls"].controller;t.hapticActuators.length>0&&n.push(...t.hapticActuators)}0===n.length&&se("no tracked-controls found")}return this.actuators=n,n}});var Wt=["attribute vec3 position;","attribute vec2 uv;","uniform mat4 projectionMatrix;","uniform mat4 modelViewMatrix;","varying vec2 vUv;","void main()  {","  vUv = vec2( 1.- uv.x, uv.y );","  gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );","}"].join("\n"),$t=["precision mediump float;","uniform samplerCube map;","varying vec2 vUv;","#define M_PI 3.141592653589793238462643383279","void main() {","  vec2 uv = vUv;","  float longitude = uv.x * 2. * M_PI + .5 * M_PI;","  float latitude = uv.y * M_PI;","  vec3 dir = vec3(","    - sin( longitude ) * sin( latitude ),","    cos( latitude ),","    - cos( longitude ) * sin( latitude )","  );","  normalize( dir );","  gl_FragColor = vec4( textureCube( map, dir ).rgb, 1.0 );","}"].join("\n"),Qt=["varying vec2 vUv;","void main() {","  vUv = uv;","  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);","}"].join("\n"),Yt=["#include <packing>","varying vec2 vUv;","uniform sampler2D tDepth;","uniform float cameraNear;","uniform float cameraFar;","uniform float maxDepth;","float readDepth( sampler2D depthSampler, vec2 coord ) {","  float fragCoordZ = texture2D( depthSampler, coord ).x;","  float z_n = 2.0 * fragCoordZ - 1.0;","  float z_e = 2.0 * cameraNear * cameraFar / (cameraFar + cameraNear - z_n * (cameraFar - cameraNear));","  return clamp(z_e/maxDepth, 0., 1.);","}","void main() {","  //gl_FragColor.rgb = vec3(vUv.x, vUv.y, 0.0);","  //gl_FragColor.rgb = texture2D( tDepth, vUv ).rgb;","  float depth = readDepth( tDepth, vUv );","  gl_FragColor.rgb = 1.0 - vec3( depth );","  gl_FragColor.a = 1.0;","}"].join("\n");AFRAME.registerComponent("screenshotx",{schema:{width:{default:4096},height:{default:2048},camera:{type:"selector"},maxDepth:{default:10}},init:function(){this.setup=this.setup.bind(this),this.onKeyDown=this.onKeyDown.bind(this);const e=this.el;e.renderer?this.setup():e.addEventListener("render-target-loaded",this.setup)},setup(){var e=this.el.renderer.getContext();if(!e)return;this.cubeMapSize=e.getParameter(e.MAX_CUBE_MAP_TEXTURE_SIZE),this.orthographicCamera=new THREE.OrthographicCamera(-1,1,1,-1,0,1),this.screenshot={},this.screenshot.canvas=document.createElement("canvas"),this.screenshot.ctx=this.screenshot.canvas.getContext("2d"),this.equirectangular={},this.equirectangular.material=new THREE.RawShaderMaterial({uniforms:{map:{type:"t",value:null}},vertexShader:Wt,fragmentShader:$t,side:THREE.DoubleSide});const t=new THREE.Mesh(new THREE.PlaneBufferGeometry(2,2),this.equirectangular.material);this.equirectangular.scene=new THREE.Scene,this.equirectangular.scene.add(t),this.depth={},this.depth.canvas=document.createElement("canvas"),this.depth.ctx=this.depth.canvas.getContext("2d"),this.depth.material=new THREE.ShaderMaterial({vertexShader:Qt,fragmentShader:Yt,uniforms:{cameraNear:{value:0},cameraFar:{value:0},maxDepth:{value:0},tDepth:{type:"t",value:null}}});const i=new THREE.Mesh(new THREE.PlaneBufferGeometry(2,2),this.depth.material);this.depth.scene=new THREE.Scene,this.depth.scene.add(i)},createRenderTarget:function(e,t){const i=new THREE.WebGLRenderTarget(e,t,{minFilter:THREE.LinearFilter,magFilter:THREE.LinearFilter,wrapS:THREE.ClampToEdgeWrapping,wrapT:THREE.ClampToEdgeWrapping,format:THREE.RGBAFormat,type:THREE.UnsignedByteType});return i.stencilBuffer=!1,i.depthBuffer=!0,i},play:function(){window.addEventListener("keydown",this.onKeyDown)},pause:function(){window.removeEventListener("keydown",this.onKeyDown)},onKeyDown:function(e){const t=83===e.keyCode&&e.ctrlKey&&e.altKey;if(this.data&&t){const t=`screenshot${document.title?"+"+document.title.toLowerCase():""}-${Date.now()}`;this.capture(e.shiftKey?"equirectangular":"perspective",t)}},capture(e,t){const i=this.el.renderer,n=i.vr.enabled;i.vr.enabled=!1;const a=this.data.camera&&this.data.camera.components.camera.camera||this.el.camera,s={width:this.data.width,height:this.data.height};return"perspective"===e?this.capturePerspective(a,s):this.captureEquirectangular(a,s),t&&(this.saveCapture(this.screenshot.canvas,t+".png"),"perspective"===e&&this.saveCapture(this.depth.canvas,t+"_depth.png")),i.vr.enabled=n,this.screenshot.canvas},capturePerspective(e,t){const i=this.el.renderer,n=this.createRenderTarget(t.width,t.height);n.depthTexture=new THREE.DepthTexture,n.depthTexture.type=THREE.UnsignedShortType,i.clear(),i.setRenderTarget(n),i.render(this.el.object3D,e),this.screenshot.canvas.width=t.width,this.screenshot.canvas.height=t.height,this.copyRenderTargetToCanvas(i,n,this.screenshot.ctx,t,!0);const a=this.depth.material.uniforms;a.tDepth.value=n.depthTexture,a.cameraNear.value=e.near,a.cameraFar.value=e.far,a.maxDepth.value=this.data.maxDepth;const s=this.createRenderTarget(t.width,t.height);i.setRenderTarget(s),i.render(this.depth.scene,this.orthographicCamera),this.depth.canvas.width=t.width,this.depth.canvas.height=t.height,this.copyRenderTargetToCanvas(i,s,this.depth.ctx,t,!0),i.setRenderTarget(null)},captureEquirectangular(e,t){const i=this.el,n=i.renderer;var a=new THREE.CubeCamera(e.near,e.far,Math.min(this.cubeMapSize,2048));e.getWorldPosition(a.position),e.getWorldQuaternion(a.quaternion),a.update(i.renderer,i.object3D);const s=this.createRenderTarget(t.width,t.height);this.equirectangular.material.uniforms.map.value=a.renderTarget.texture,n.clear(),n.setRenderTarget(s),n.render(this.equirectangular.scene,this.orthographicCamera),this.screenshot.canvas.width=t.width,this.screenshot.canvas.height=t.height,this.copyRenderTargetToCanvas(n,s,this.screenshot.ctx,t,!1),n.setRenderTarget(null)},flipPixelsVertically:function(e,t,i){for(var n=e.slice(0),a=0;a<t;++a)for(var s=0;s<i;++s)n[4*a+s*t*4]=e[4*a+(i-s)*t*4],n[4*a+1+s*t*4]=e[4*a+1+(i-s)*t*4],n[4*a+2+s*t*4]=e[4*a+2+(i-s)*t*4],n[4*a+3+s*t*4]=e[4*a+3+(i-s)*t*4];return n},saveCapture:function(e,t){e.toBlob(function(e){var i=document.createElement("a"),n=URL.createObjectURL(e);i.href=n,i.setAttribute("download",t),i.innerHTML="downloading...",i.style.display="none",document.body.appendChild(i),setTimeout(function(){i.click(),document.body.removeChild(i)},1)},"image/png")},copyRenderTargetToCanvas(e,t,i,n,a){let s=new Uint8Array(4*n.width*n.height);e.readRenderTargetPixels(t,0,0,n.width,n.height,s),a&&(s=this.flipPixelsVertically(s,n.width,n.height));const r=new ImageData(new Uint8ClampedArray(s),n.width,n.height);i.putImageData(r,0,0)}});var Xt=new function(){var e,t,i,n,a,s,r,o,l,c,d,h;this._params=new function(){this.setSettings=function(e){for(var t=0;t<24;t++)this[String.fromCharCode(97+t)]=e[t]||0;this.c<.01&&(this.c=.01);var i=this.b+this.c+this.e;if(i<.18){var n=.18/i;this.b*=n,this.c*=n,this.e*=n}}},this.reset=function(){var e=this._params;n=100/(e.f*e.f+.001),a=100/(e.g*e.g+.001),s=1-e.h*e.h*e.h*.01,r=-e.i*e.i*e.i*1e-6,e.a||(d=.5-e.n/2,h=5e-5*-e.o),o=1+e.l*e.l*(e.l>0?-.9:10),l=0,c=1==e.m?0:(1-e.m)*(1-e.m)*2e4+32},this.totalReset=function(){this.reset();var n=this._params;return e=n.b*n.b*1e5,t=n.c*n.c*1e5,i=n.e*n.e*1e5+12,3*((e+t+i)/3|0)},this.synthWave=function(u,m){var p=this._params,f=1!=p.s||p.v,g=p.v*p.v*.1,v=1+3e-4*p.w,y=p.s*p.s*p.s*.1,b=1+1e-4*p.t,E=1!=p.s,x=p.x*p.x,T=p.g,w=p.q||p.r,A=p.r*p.r*p.r*.2,R=p.q*p.q*(p.q<0?-1020:1020),S=p.p?32+((1-p.p)*(1-p.p)*2e4|0):0,M=p.d,C=p.j/2,I=p.k*p.k*.01,O=p.a,L=e,D=1/e,F=1/t,k=1/i,P=5/(1+p.u*p.u*20)*(.01+y);P>.8&&(P=.8),P=1-P;for(var H,j,_,z,V,B,U=!1,N=0,G=0,q=0,W=0,$=0,Q=0,Y=0,X=0,Z=0,K=0,J=new Array(1024),ee=new Array(32),te=J.length;te--;)J[te]=0;for(te=ee.length;te--;)ee[te]=2*Math.random()-1;for(te=0;te<m;te++){if(U)return te;if(S&&++Z>=S&&(Z=0,this.reset()),c&&++l>=c&&(c=0,n*=o),(n*=s+=r)>a&&(n=a,T>0&&(U=!0)),j=n,C>0&&(K+=I,j*=1+Math.sin(K)*C),(j|=0)<8&&(j=8),O||((d+=h)<0?d=0:d>.5&&(d=.5)),++G>L)switch(G=0,++N){case 1:L=t;break;case 2:L=i}switch(N){case 0:q=G*D;break;case 1:q=1+2*(1-G*F)*M;break;case 2:q=1-G*k;break;case 3:q=0,U=!0}w&&((_=0|(R+=A))<0?_=-_:_>1023&&(_=1023)),f&&v&&((g*=v)<1e-5?g=1e-5:g>.1&&(g=.1)),B=0;for(var ie=8;ie--;){if(++Y>=j&&(Y%=j,3==O))for(var ne=ee.length;ne--;)ee[ne]=2*Math.random()-1;switch(O){case 0:V=Y/j<d?.5:-.5;break;case 1:V=1-Y/j*2;break;case 2:V=.225*(((V=1.27323954*(z=6.28318531*((z=Y/j)>.5?z-1:z))+.405284735*z*z*(z<0?1:-1))<0?-1:1)*V*V-V)+V;break;case 3:V=ee[Math.abs(32*Y/j|0)]}f&&(H=Q,(y*=b)<0?y=0:y>.1&&(y=.1),E?($+=(V-Q)*y,$*=P):(Q=V,$=0),W+=(Q+=$)-H,V=W*=1-g),w&&(J[X%1024]=V,V+=J[(X-_+1024)%1024],X++),B+=V}B*=.125*q*x,u[te]=B>=1?32767:B<=-1?-32768:32767*B|0}return m}};const Zt=["square","saw","sine","noise"],Kt=Object.fromEntries(Object.entries({blip:"1,0.0763,0.2818,0.016,0.0863,0.5084,,0.1299,0.0055,-0.9082,0.129,-0.0591,-0.2874,0.394,0.0001,0.9773,0.0273,-0.2397,0.9997,0.0216,,0.049,0.0001,0.5",blip2:"2,,0.1774,0.3425,0.2543,0.5001,,,-0.1253,,-0.6326,0.0511,0.6321,0.5733,0.2467,,0.347,0.0153,0.8671,-0.025,-0.7166,0.0822,,0.5",blip3:"1,,0.01,0.466,0.2176,0.2082,,-0.0277,0.1473,,0.0722,0.7231,-0.5943,0.1948,-0.0661,,0.1636,0.2965,0.0806,-0.001,0.8212,0.1233,-0.0013,0.5",blip4:"1,,0.1965,,0.1281,0.2741,,,,,,,,,,,,,1,,,0.1,,0.5",bounce:"2,0.0007,0.0948,0.0201,0.1347,0.1747,,0.0545,0.0153,-0.0796,-0.4931,0.8874,-0.3721,0.1246,0.8612,0.6185,-0.1477,-0.6924,0.4851,0.3104,0.1193,0.2017,0.0358,0.5",chime:"0,0.1383,0.651,0.467,0.3914,0.5016,,,0.0655,,0.064,-0.7934,,0.4441,0.0266,0.3182,-0.1779,0.2923,0.3721,-0.0176,,0.6679,0.6276,0.5",coin:"0,,0.0471,0.4724,0.3068,0.7881,,,,,,0.5963,0.5726,,,,,,1,,,,,0.5",explosion:"3,,0.3436,0.6166,0.4478,0.0417,,0.2933,,,,,,,,0.5993,-0.1521,-0.0133,1,,,,,0.5",hit:"3,0.0072,0.1912,0.4453,0.6026,0.5006,,0.5214,-0.0019,0.2952,,-0.4769,,,-0.4262,-0.8242,-0.0544,-0.1995,0.8669,-0.7538,0.4002,0.32,-0.0006,0.5",jump:"0,,0.3617,,0.1015,0.4239,,0.2121,,,,,,0.1629,,,,,0.6555,,,,,0.5",laser:"1,,0.2965,0.2824,0.0465,0.6897,0.3877,-0.2884,,,,,,0.8732,-0.4466,,,,1,,,0.0907,,1",laser2:"3,0.0059,0.5443,0.2928,0.6031,0.5,,,-0.0187,,,0.9508,,0.6631,-0.5569,0.7418,0.0444,-0.7924,0.6592,-0.1598,-0.133,0.0128,,0.5",laser3:"3,0.0496,0.01,0.0659,0.918,0.5014,,0.5792,-0.0029,-0.0049,0.8602,0.118,,,-0.0042,0.1187,-0.0236,0.6263,0.752,-0.6478,-0.8254,0.0664,-0.1286,0.5",powerup:"0,,0.1917,,0.4356,0.3114,,0.0918,,,,,,0.4176,,,,,1,,,,,1",pulse:"0,0.3134,0.7096,0.0081,0.4655,0.2789,,-0.102,0.0261,0.1236,0.8212,0.4089,,,-0.116,,0.1212,0.0429,0.978,-0.3121,,,-0.1077,0.5",pulse2:",0.1637,0.6944,0.8905,0.741,0.5745,,-0.0833,0.7298,0.2642,0.3181,0.1227,0.5693,0.1215,0.1114,0.5623,0.5974,0.8682,0.793,-0.2755,0.0143,0.7865,0.2557,0.5",pulse3:"1,0.2058,0.0697,0.0369,0.9649,0.4779,,,-0.0495,0.661,,-0.4738,0.5435,0.7119,-0.0316,0.2556,-0.9952,0.4666,0.1608,-0.038,0.4537,0.097,,0.5",pulse4:"0,0.0008,0.01,0.1728,0.4637,0.5029,,0.2054,,0.6654,0.0841,0.7765,0.7312,0.8236,-0.3597,0.7258,0.0674,-0.0745,0.1646,0.0361,0.1764,,-0.2647,0.5",thump:"3,0.145,0.2908,0.597,0.542,0.001,,0.0014,0.0367,0.1754,0.8581,0.3987,,0.1379,-0.759,,-0.3583,0.0593,0.185,-0.9675,0.7929,0.0065,-0.2162,0.5"}).map(e=>[e[0],ei(e[1])]));function Jt(e,t,i){return e<t?t:e>i?i:e}function ei(e){return e.split(",").map(e=>Number(e))}function ti(){return Math.random()}AFRAME.registerComponent("sfxr",{schema:{_play:{default:!1},_random:{default:!1},as3fxr:{default:""},preset:{oneOf:Object.keys(Kt),default:""},events:{default:""},delay:{default:0},waveType:{oneOf:Zt,default:"square",parse:function(e){return e.toLowerCase()}},attackTime:{default:0,min:0,max:1},sustainTime:{default:.18,min:.18,max:1},sustainPunch:{default:0,min:0,max:1},decayTime:{default:0,min:0,max:1},startFrequency:{default:0,min:0,max:1},minFrequency:{default:0,min:0,max:1},slide:{default:0,min:-1,max:1},deltaSlide:{default:0,min:-1,max:1},vibratoDepth:{default:0,min:0,max:1},vibratoSpeed:{default:0,min:0,max:1},changeAmount:{default:0,min:-1,max:1},changeSpeed:{default:0,min:0,max:1},squareDuty:{default:0,min:0,max:1},dutySweep:{default:0,min:-1,max:1},repeatSpeed:{default:0,min:0,max:1},phaserOffset:{default:0,min:-1,max:1},phaserSweep:{default:0,min:-1,max:1},lpFilterCutoff:{default:0,min:0,max:1},lpFilterCutoffSweep:{default:0,min:-1,max:1},lpFilterResonance:{default:0,min:0,max:1},hpFilterCutoff:{default:0,min:0,max:1},hpFilterCutoffSweep:{default:0,min:-1,max:1},masterVolume:{default:0,min:0,max:1},enabled:{default:!0},playOnChange:{default:!1}},multiple:!0,init(){this.onEvent=this.onEvent.bind(this),this.playSound=this.playSound.bind(this),this.player=new Audio,this.delayClock=ee(),this.eventListener=ie(this.el,this.onEvent)},remove(){this.eventListener.remove(),this.delayClock.clearAllTimeouts(),this.player.stop()},pause(){this.eventListener.remove(),this.delayClock.pause()},play(){this.eventListener.add(),this.delayClock.resume()},update(e){const t=this.data;if(void 0!==e._play&&t._play!==e._play)this.playSound();else if(void 0!==e._random&&t._random!==e._random){const t=[Math.trunc(ti()*Zt.length),ti(),ti(),ti(),ti(),ti(),0,2*ti()-1,2*ti()-1,ti(),ti(),2*ti()-1,ti(),ti(),2*ti()-1,ti(),ti(),2*ti()-1,ti(),2*ti()-1,ti(),ti(),2*ti()-1,.5];this.sendToPlayer(t),this.setData(t),this.setASFXData(t),this.data.preset="",void 0!==e.preset&&this.player.play()}else if(e.preset!==t.preset&&t.preset){const i=Kt[t.preset]||Kt[0];this.sendToPlayer(i),this.setData(i),this.setASFXData(i),void 0!==e.preset&&this.player.play()}else if(t.as3fxr!==e.as3fxr&&t.as3fxr){const e=ei(t.as3fxr);this.sendToPlayer(e),this.setData(e)}else this.sendToPlayer([Zt.indexOf(t.waveType),t.attackTime,t.sustainTime,t.sustainPunch,t.decayTime,t.startFrequency,t.minFrequency,t.slide,t.deltaSlide,t.vibratoDepth,t.vibratoSpeed,t.changeAmount,t.changeSpeed,t.squareDuty,t.dutySweep,t.repeatSpeed,t.phaserOffset,t.phaserSweep,t.lpFilterCutoff,t.lpFilterCutoffSweep,t.lpFilterResonance,t.hpFilterCutoff,t.hpFilterCutoffSweep,t.masterVolume]),t.playOnChange&&this.player.play();t.events!==e.events&&(t.events?this.eventListener.set(t.events,"","self"):this.delayClock.startTimer(this.data.delay,this.playSound))},setData(e){const t=this.data;t.waveType=Zt[e[0]],t.attackTime=e[1],t.sustainTime=e[2],t.sustainPunch=e[3],t.decayTime=e[4],t.startFrequency=e[5],t.minFrequency=e[6],t.slide=e[7],t.deltaSlide=e[8],t.vibratoDepth=e[9],t.vibratoSpeed=e[10],t.changeAmount=e[11],t.changeSpeed=e[12],t.squareDuty=e[13],t.dutySweep=e[14],t.repeatSpeed=e[15],t.phaserOffset=e[16],t.phaserSweep=e[17],t.lpFilterCutoff=e[18],t.lpFilterCutoffSweep=e[19],t.lpFilterResonance=e[20],t.hpFilterCutoff=e[21],t.hpFilterCutoffSweep=e[22],t.masterVolume=e[23]},setASFXData(e){this.data.as3fxr=e.map(e=>0!=e?e.toFixed(4).replace(/0+$/,""):"").join(",")},sendToPlayer(e){this.player.src=function(e){Xt._params.setSettings(e);var t=Xt.totalReset(),i=new Uint8Array(4*((t+1)/2|0)+44),n=2*Xt.synthWave(new Uint16Array(i.buffer,44),t),a=new Uint32Array(i.buffer,0,44);a[0]=1179011410,a[1]=n+36,a[2]=1163280727,a[3]=544501094,a[4]=16,a[5]=65537,a[6]=44100,a[7]=88200,a[8]=1048578,a[9]=1635017060,a[10]=n,n+=44;for(var s=0,r="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",o="data:audio/wav;base64,";s<n;s+=3){var l=i[s]<<16|i[s+1]<<8|i[s+2];o+=r[l>>18]+r[l>>12&63]+r[l>>6&63]+r[63&l]}return o}([Jt(e[0],0,Zt.length-1),Jt(e[1],0,1),Jt(e[2],0,1),Jt(e[3],0,1),Jt(e[4],0,1),Jt(e[5],0,1),Jt(e[6],0,1),Jt(e[7],-1,1),Jt(e[8],-1,1),Jt(e[9],0,1),Jt(e[10],0,1),Jt(e[11],-1,1),Jt(e[12],0,1),Jt(e[13],0,1),Jt(e[14],-1,1),Jt(e[15],0,1),Jt(e[16],-1,1),Jt(e[17],-1,1),Jt(e[18],0,1),Jt(e[19],-1,1),Jt(e[20],0,1),Jt(e[21],0,1),Jt(e[22],-1,1),Jt(e[23],0,1)])},onEvent(e){this.delayClock.startTimer(this.data.delay,this.playSound)},playSound(){this.data.enabled&&(this.player.currentTime=0,this.player.play())}});const ii=THREE.Math.degToRad,ni=new THREE.Vector3(0,0,0),ai={geometrytriangle:Xe,geometryedge:Ze,geometryvertex:function(e,t){let i=3*Math.floor(Math.random()*e.length/3);t.fromArray(e,i)}},si=["sequence","randomsequence","random"];function ri(e){return e.toLowerCase()}AFRAME.registerComponent("simple-emitter",{schema:{enabled:{default:!0},count:{default:100},particles:{default:"particles"},textureFrame:{type:"vec2",default:{x:0,y:0}},lifeTime:{default:"1"},loopTime:{default:"0"},colors:{default:""},rotations:{default:""},scales:{default:""},opacities:{default:""},frames:{default:""},frameStyle:{default:"sequence",oneOf:si,parse:ri},velocity:{default:"0 0 0"},acceleration:{default:"0 0 0"},radialVelocity:{default:"0"},radialAcceleration:{default:"0"},angularVelocity:{default:"0 0 0"},angularAcceleration:{default:"0 0 0"},orbitalVelocity:{default:"0"},orbitalAcceleration:{default:"0"},spawnShape:{default:"point",oneOf:["point","geometrytriangle","geometryedge","geometryvertex","circle","sphere","box","insidecircle","insidesphere","insidebox"],parse:ri},spawnGeometry:{type:"selector"}},multiple:!0,init(){this.particleSystem=this.el.sceneEl.systems["simple-particles"].getParticles(this.data.particles),this.startIndex=void 0,this.endIndex=void 0,this.maxLifeTime=void 0,this.spawnCount=0,this.particles=[],this.enabled=!0,this.spawnOffsets=void 0},remove(){this.startIndex&&this.particleSystem.releaseParticles(this.startIndex)},update(e){const t=this.data;if("string"==typeof t)return void se(this,`attributes are incorrectly formatted '${t}'`);this.lifeTime=_(t.lifeTime),this.loopTime=_(t.loopTime),this.rotations=z(t.rotations,ii),this.scales=z(t.scales),this.opacities=z(t.opacities),this.colors=j(t.colors),this.frames=z(t.frames),this.frameStyle=si.indexOf(t.frameStyle)?si.indexOf(t.frameStyle):0,this.velocity=V(t.velocity),this.acceleration=V(t.acceleration),this.radialVelocity=_(t.radialVelocity),this.radialAcceleration=_(t.radialAcceleration),this.angularVelocity=V(t.angularVelocity),this.angularAcceleration=V(t.angularAcceleration),this.orbitalVelocity=_(t.orbitalVelocity),this.orbitalAcceleration=_(t.orbitalAcceleration),ai[t.spawnShape]&&t.spawnGeometry!==e.spawnGeometry?(this.spawnGeometryFunction=ai[t.spawnShape],this.spawnOffsets=this.calcSpawnOffsetsFromGeometry(t.spawnGeometry||this.el)):(this.spawnGeometryFunction=void 0,this.spawnOffsets=void 0),(t.textureFrame.x>64||t.textureFrame.y>64||t.textureFrame.x<0||t.textureFrame.y<0)&&re(this,`textureFrame (${t.textureFrame.x},${t.textureFrame.y}) is expected in the range (0,64) x (0,64)`),t.textureFrame.x===~~t.textureFrame.x&&t.textureFrame.y===~~t.textureFrame.y||re(this,"textureFrame must be an integer value");const i=this.particleSystem;i?(this.maxLifeTime=B(this.lifeTime),this.startIndex&&(i.releaseParticles(this.startIndex),this.startIndex=void 0,this.endIndex=void 0),this.startIndex=i.allocateParticles(t.count),void 0!==this.startIndex&&(this.endIndex=this.startIndex+t.count),this.enabled=this.data.enabled,this.createParticles(0)):this.enabled=!1},createParticles(e){const t=this.data,i=Math.max(N(this.loopTime),B(this.lifeTime)),n=i/t.count;this.el.object3D.updateMatrixWorld();for(let t=this.startIndex;t<this.endIndex;t++)this.spawn(t,e+t*n,i);this.particleSystem.needsUpdate()},spawn:function(){const e=new THREE.Vector3;return function(t,i,n){const a=this.data,s=G(this.scales),r=G(this.rotations),o=G(this.colors),l=G(this.opacities),c=G(this.frames),d=N(this.lifeTime),h=N(this.velocity),u=N(this.acceleration),m=N(this.radialVelocity),p=N(this.radialAcceleration),f=N(this.angularVelocity),g=N(this.angularAcceleration),v=N(this.orbitalVelocity),y=N(this.orbitalAcceleration);this.spawnGeometryFunction&&this.spawnOffsets?this.spawnGeometryFunction(this.spawnOffsets,e):e.copy(ni);const b=this.particleSystem;b.setMatrixAt(t,this.el.object3D.matrixWorld),b.setPositionAt(t,e.x,e.y,e.z),b.setScalesAt(t,s),b.setColorsAt(t,o),b.setRotationsAt(t,r),b.setOpacitiesAt(t,l);const E=c.length>0?c[0]:0,x=c.length>1?c[1]:E;b.setFrameAt(t,this.frameStyle,E,x,a.textureFrame.x,a.textureFrame.y),b.setTimingsAt(t,i,d,n),b.setVelocityAt(t,h.x,h.y,h.z,m),b.setAccelerationAt(t,u.x,u.y,u.z,p),b.setAngularVelocityAt(t,f.x,f.y,f.z,v),b.setAngularAccelerationAt(t,g.x,g.y,g.z,y)}}(),calcSpawnOffsetsFromGeometry(e){if(!e||!e.object3D)return;let t=[];const i=new THREE.Vector3,n=new THREE.Matrix4,a=new THREE.Matrix4;return e.object3D.updateMatrixWorld(),n.getInverse(e.object3D.matrixWorld),e.object3D.traverse(e=>{if(!e.geometry||!e.geometry.getAttribute)return;const s=e.geometry.getAttribute("position");if(s&&3===s.itemSize)for(let r=0;r<s.count;r++)a.copy(e.matrixWorld).multiply(n),i.fromBufferAttribute(s,r).applyMatrix4(a),t.push(i.x,i.y,i.z)}),Float32Array.from(t)}});const oi=new THREE.DataTexture(new Uint8Array(3).fill(255),1,1,THREE.RGBFormat);oi.needsUpdate=!0;const li={none:THREE.NoBlending,normal:THREE.NormalBlending,additive:THREE.AdditiveBlending,subtractive:THREE.SubtractiveBlending,multiply:THREE.MultiplyBlending};AFRAME.registerSystem("simple-particles",{schema:{enabled:{default:!0}},init(){this.simpleParticles={}},registerParticles(e,t){this.simpleParticles[e]?re(`name '${e}' already in use`):this.simpleParticles[e]=t},unregisterParticles(e,t){this.simpleParticles[e]!==t?re(`could not find particles '${e}'`):this.simpleParticles[e]=void 0},getParticles(e){return this.simpleParticles[e]}}),AFRAME.registerComponent("simple-particles",{schema:{name:{default:"particles"},count:{default:1e3},texture:{type:"map"},textureFrame:{type:"vec2",default:{x:1,y:1}},particleType:{default:"particle",oneOf:["particle","ribbon"]},particleSize:{default:10},transparent:{default:!1},alphaTest:{default:0},depthWrite:{default:!0},depthTest:{default:!0},blending:{default:"normal",oneOf:["none","normal","additive","subtractive","multiply"],parse:function(e){return e.toLowerCase()}},fog:{default:!0},usePerspective:{default:!0},useLinearMotion:{default:!0},useOrbitalMotion:{default:!0},useAngularMotion:{default:!0},useRadialMotion:{default:!0},useFramesOrRotation:{default:!0}},multiple:!0,init(){this.mesh=void 0,this.material=void 0,this.geometry=void 0,this.system.registerParticles(this.data.name,this),this.blocks=function(e){const t=[{index:0,size:e}],i=[];function n(e){let i=!1;for(let n=0;!i&&n<t.length;n++){const a=t[n];if(a.index==e.index+e.size)a.index=e.index,a.size+=e.size,i=!0;else if(a.index+a.size===e.index){a.size+=e.size;const s=t[n+1];s&&s.index===a.index+a.size&&(a.size+=s.size,t.splice(n+1,1)),i=!0}else a.index>e.index&&(t.splice(n,0,e),i=!0)}i||t.push(e)}return{allocate:function(e){for(let n=t.length-1;n>=0;n--){const a=t[n],s=a.size-e;if(s>=0){let r;return s>0?(r={index:a.index,size:e},a.index+=e,a.size=s):(r=a,t.splice(n,1)),i.push(r),r.index}}},release:function(e){for(let t=0;t<i.length;t++){const a=i[t];if(a.index===e){const e=a.size;return i.splice(t,1),n(a),e}}return 0},maxUsed:function(){return i.reduce((e,t)=>Math.max(e,t.index+t.size),0)}}}(this.data.count),this.createMesh(this.data.count)},remove(){this.system.unregisterParticles(this.data.name,this)},update(e){const t=this.data;t.texture!==e.texture&&this.loadTexture(t.texture),(t.textureFrame.x>64||t.textureFrame.y>64||t.textureFrame.x<1||t.textureFrame.y<1)&&re(this,`textureFrame (${t.textureFrame.x},${t.textureFrame.y}) is expected in the range (1,64) x (1,64)`),t.textureFrame.x===~~t.textureFrame.x&&t.textureFrame.y===~~t.textureFrame.y||re(this,"textureFrame must be an integer value"),this.updateMaterial(this.material)},tick(e,t){this.material&&(this.material.uniforms.t.value=e/1e3)},createMesh(e){this.geometry=new THREE.BufferGeometry,this.updateGeometry(this.geometry,e),this.material=new THREE.RawShaderMaterial({uniforms:{map:{type:"t",value:oi},textureFrame:{value:new THREE.Vector2(1,1)},particleSize:{value:10},usePerspective:{value:1},t:{value:0},fogDensity:{value:25e-5},fogNear:{value:1},fogFar:{value:2e3},fogColor:{value:new THREE.Color(16777215)}},fragmentShader:di,vertexShader:ci,defines:{}}),this.mesh=new THREE.Points(this.geometry,this.material),this.mesh.frustumCulled=!1,this.el.sceneEl.object3D.add(this.mesh)},updateGeometry(e,t){e.addAttribute("row1",new THREE.Float32BufferAttribute(new Float32Array(4*t),4)),e.addAttribute("row2",new THREE.Float32BufferAttribute(new Float32Array(4*t),4)),e.addAttribute("row3",new THREE.Float32BufferAttribute(new Float32Array(4*t),4)),e.addAttribute("position",new THREE.Float32BufferAttribute(new Float32Array(3*t),3)),e.addAttribute("scales",new THREE.Float32BufferAttribute(new Float32Array(3*t),3)),e.addAttribute("rotations",new THREE.Float32BufferAttribute(new Float32Array(3*t),3)),e.addAttribute("colors",new THREE.Float32BufferAttribute(new Float32Array(3*t),3)),e.addAttribute("opacities",new THREE.Float32BufferAttribute(new Float32Array(3*t).fill(1),3)),e.addAttribute("frame",new THREE.Float32BufferAttribute(new Float32Array(2*t),2)),e.addAttribute("timings",new THREE.Float32BufferAttribute(new Float32Array(4*t),4)),e.addAttribute("velocity",new THREE.Float32BufferAttribute(new Float32Array(4*t),4)),e.addAttribute("acceleration",new THREE.Float32BufferAttribute(new Float32Array(4*t),4)),e.addAttribute("angularvelocity",new THREE.Float32BufferAttribute(new Float32Array(4*t),4)),e.addAttribute("angularacceleration",new THREE.Float32BufferAttribute(new Float32Array(4*t),4));const i=new THREE.Matrix4;for(let e=0;e<t;e++)this.setMatrixAt(e,i)},updateMaterial(e){const t=this.data;e.uniforms.particleSize.value=t.particleSize,e.uniforms.textureFrame.value.x=t.textureFrame.x,e.uniforms.textureFrame.value.y=t.textureFrame.y,e.uniforms.usePerspective.value=t.usePerspective?1:0,e.transparent=t.transparent,e.alphaTest=t.alphaTest,e.blending=li[t.blending],e.fog=t.fog,e.depthWrite=t.depthWrite,e.depthTest=t.depthTest;const i={};t.useAngularMotion&&(i.USE_ANGULAR_MOTION=!0),t.useRadialMotion&&(i.USE_RADIAL_MOTION=!0),t.useOrbitalMotion&&(i.USE_ORBITAL_MOTION=!0),t.useLinearMotion&&(i.USE_LINEAR_MOTION=!0),t.useFramesOrRotation&&(i.USE_FRAMES_OR_ROTATION=!0),t.fog&&(i.USE_FOG=!0),e.defines=i,e.needsUpdate=!0},loadTexture(e){if(e){this.el.sceneEl.systems.material.loadTexture(e,{src:e},e=>{this.material.uniforms.map.value=e})}else this.material.uniforms.map.value=oi},setMatrixAt(e,t){const i=t.elements,n=this.geometry.getAttribute("row1"),a=this.geometry.getAttribute("row2"),s=this.geometry.getAttribute("row3");n.setXYZW(e,i[0],i[4],i[8],i[12]),a.setXYZW(e,i[1],i[5],i[9],i[13]),s.setXYZW(e,i[2],i[6],i[10],i[14])},setPositionAt(e,t,i,n){const a=this.geometry.getAttribute("position");Array.isArray(t)?(n=t[2],i=t[1],t=t[0]):"object"==typeof t&&(n=t.z,i=t.y,t=t.x),a.setXYZ(e,t,i,n)},setColorsAt(e,t){function i(e,t,i){return~~(255*e)/256+~~(255*t)/65536+~~(255*i)/16777216}const n=this.geometry.getAttribute("colors"),a=t[0],s=t[1],r=t[2];let o,l,c;switch(t.length){case 0:o=l=c=i(1,1,1);break;case 1:o=i(a.r,a.r,a.r),l=i(a.g,a.g,a.g),c=i(a.b,a.b,a.b);break;case 2:o=i(a.r,.5*(a.r+s.r),s.r),l=i(a.g,.5*(a.g+s.g),s.g),c=i(a.b,.5*(a.b+s.b),s.b);break;default:o=i(a.r,s.r,r.r),l=i(a.g,s.g,r.g),c=i(a.b,s.b,r.b)}n.setXYZ(e,o,l,c)},setOpacitiesAt(e,t){const i=this.geometry.getAttribute("opacities");this.setKeyframesAt(i,e,t,1)},setTimingsAt(e,t,i,n,a=Math.random()){this.geometry.getAttribute("timings").setXYZW(e,t,i,n,a)},setFrameAt(e,t,i,n,a=0,s=0){const r=~~(a=a||this.data.textureFrame.x)+.015625*~~(s=s||this.data.textureFrame.y)+3814697265625e-18*~~i,o=t+3814697265625e-18*~~n;this.geometry.getAttribute("frame").setXY(e,r,o)},setScalesAt(e,t){const i=this.geometry.getAttribute("scales");this.setKeyframesAt(i,e,t,1)},setRotationsAt(e,t){const i=this.geometry.getAttribute("rotations");this.setKeyframesAt(i,e,t,0)},setVelocityAt(e,t,i,n,a=0){this.geometry.getAttribute("velocity").setXYZW(e,t,i,n,a)},setAccelerationAt(e,t,i,n,a=0){this.geometry.getAttribute("acceleration").setXYZW(e,t,i,n,a)},setAngularVelocityAt(e,t,i,n,a=0){this.geometry.getAttribute("angularvelocity").setXYZW(e,t,i,n,a)},setAngularAccelerationAt(e,t,i,n,a=0){this.geometry.getAttribute("angularacceleration").setXYZW(e,t,i,n,a)},setKeyframesAt(e,t,i,n){const a=i[0],s=i[1],r=i[2];switch(i.length){case 0:e.setXYZ(t,n,n,n);break;case 1:e.setXYZ(t,a,a,a);break;case 2:e.setXYZ(t,a,.5*(a+s),s);break;default:e.setXYZ(t,a,s,r)}},needsUpdate(){this.geometry.getAttribute("row1").needsUpdate=!0,this.geometry.getAttribute("row2").needsUpdate=!0,this.geometry.getAttribute("row3").needsUpdate=!0,this.geometry.getAttribute("position").needsUpdate=!0,this.geometry.getAttribute("scales").needsUpdate=!0,this.geometry.getAttribute("colors").needsUpdate=!0,this.geometry.getAttribute("opacities").needsUpdate=!0,this.geometry.getAttribute("rotations").needsUpdate=!0,this.geometry.getAttribute("timings").needsUpdate=!0,this.geometry.getAttribute("frame").needsUpdate=!0,this.geometry.getAttribute("velocity").needsUpdate=!0,this.geometry.getAttribute("acceleration").needsUpdate=!0},multipleNeedsUpdate(e){for(let t of e)this.needsUpdate(t)},allocateParticles(e){return this.blocks.allocate(e)},releaseParticles(e){const t=this.blocks.release(e);if(t>0){const i=this.geometry.getAttribute("scales");for(let n=e;n<e+t;n++)i.setXYZ(n,0,0,0)}return t}});const ci="\nprecision highp float;\nprecision highp int;\n\nattribute vec4 row1;\nattribute vec4 row2;\nattribute vec4 row3;\nattribute vec3 position;\nattribute vec3 scales;\nattribute vec3 rotations;\nattribute vec3 colors;\nattribute vec3 opacities;\nattribute vec4 timings;\nattribute vec2 frame;\nattribute vec4 velocity;\nattribute vec4 acceleration;\nattribute vec4 angularvelocity;\nattribute vec4 angularacceleration;\n\nuniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\nuniform vec2 textureFrame;\nuniform float particleSize;\nuniform float usePerspective;\nuniform float t;\n\nvarying mat3 vUvTransform;\nvarying vec4 vParticleColor;\nvarying vec2 vUv;\nvarying float vFogDepth;\n\nfloat pseudoRandom( const float seed )\n{\n  return mod( 1664525.*seed + 1013904223., 4294967296. )/4294967296.;\n}\n\nvec3 unpackFrame( float pack )\n{\n  float y = fract( pack ) * 64.;\n  return floor( vec3( pack, y, fract( y ) * 4096. ) );\n}\n\nvec3 unpackRGB( float pack )\n{\n  vec3 enc = fract( pack * vec3( 1., 256., 65536. ) );\n  enc -= enc.yzz * vec3( 1./256., 1./256., 0. );\n  return enc;\n}\n\nfloat interpolate( const vec3 keys, const float r )\n{\n  float k = r*2.;\n  return k < 1. ? mix( keys.x, keys.y, k ) : mix( keys.y, keys.z, k - 1. );\n}\n\n// assumes euler order is YXZ\nvec4 eulerToQuaternion( const vec3 euler )\n{\n  // from https://github.com/mrdoob/three.js/blob/master/src/math/Quaternion.js\n\n  vec3 c = cos( euler * .5 );\n  vec3 s = sin( euler * .5 );\n\n  return vec4(\n    s.x * c.y * c.z + c.x * s.y * s.z,\n    c.x * s.y * c.z - s.x * c.y * s.z,\n    c.x * c.y * s.z - s.x * s.y * c.z,\n    c.x * c.y * c.z + s.x * s.y * s.z\n  );\n}\n\n// from http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm\nvec4 axisAngleToQuaternion( const vec3 axis, const float angle ) \n{\n  return vec4( axis * sin( angle*.5 ), cos( angle*.5 ) );\n}\n\nvec3 applyQuaternion( const vec3 v, const vec4 q )\n{\n  return v + 2. * cross( q.xyz, cross( q.xyz, v ) + q.w * v );\n}\n\nvoid main()\n{\n  float spawnTime = timings.x;\n  float lifeTime = timings.y;\n  float loopTime = timings.z;\n  float seed = timings.w;\n  float age = mod( t - spawnTime, loopTime );\n  float timeRatio = age / lifeTime;\n\n  float scale = interpolate( scales, timeRatio );\n  float rotation = interpolate( rotations, timeRatio );\n  float opacity = interpolate( opacities, timeRatio );\n  vec3 color = vec3(\n    interpolate( unpackRGB( colors.x ), timeRatio ),\n    interpolate( unpackRGB( colors.y ), timeRatio ),\n    interpolate( unpackRGB( colors.z ), timeRatio )\n  );\n\n  mat4 particleMatrix = mat4(\n    vec4( row1.x, row2.x, row3.x, 0. ),\n    vec4( row1.y, row2.y, row3.y, 0. ),\n    vec4( row1.z, row2.z, row3.z, 0. ),\n    vec4( row1.w, row2.w, row3.w, 1. )\n  );\n\n  float distance = length( position );\n  vec3 direction = distance == 0. ? position : position / distance;\n\n#if defined(USE_RADIAL_MOTION)\n  distance += ( .5 * acceleration.w * age + velocity.w ) * age;\n#endif\n\n#if defined(USE_ANGULAR_MOTION)\n  if ( length( angularacceleration.xyz ) > 0. || length( angularvelocity.xyz ) > 0. )\n  {\n    vec3 angularMotion = ( .5 * angularacceleration.xyz * age + angularvelocity.xyz ) * age;\n    direction = applyQuaternion( direction, eulerToQuaternion( angularMotion ) );\n  }\n#endif\n\n#if defined(USE_ORBITAL_MOTION)\n  if ( angularacceleration.w != 0. || angularvelocity.w != 0. ) \n  {\n    float orbitalMotion = ( .5 * angularacceleration.w * age + angularvelocity.w ) * age;\n    vec3 axis;\n    axis.x = pseudoRandom(spawnTime + loopTime);\n    axis.y = pseudoRandom(axis.x);\n    axis.z = pseudoRandom(axis.y);\n    normalize(axis);\n    direction = applyQuaternion( direction, axisAngleToQuaternion( axis, orbitalMotion ) );\n  }\n#endif\n\n  vec3 motion = direction * distance;\n  \n#if defined(USE_LINEAR_MOTION)\n  motion += ( .5 * acceleration.xyz * age + velocity.xyz ) * age;\n#endif\n\n  vec4 mvPosition = modelViewMatrix * particleMatrix * vec4( motion, 1. );\n\n  vParticleColor = vec4( color, opacity );\n  vUv = vec2( 0. );\n  vFogDepth = -mvPosition.z;\n\n  vUvTransform = mat3( 1. );\n\n#if defined(USE_FRAMES_OR_ROTATION)\n\n  vec3 frameInfoA = unpackFrame( frame.x );\n  vec3 frameInfoB = unpackFrame( frame.y );\n\n  float frameWidth = frameInfoA.x;\n  float frameHeight = frameInfoA.y;\n  float startFrame = frameInfoA.z;\n  float endFrame = frameInfoB.z;\n  float frameStyle = frameInfoB.x;\n  float invFrameWidth = 1./frameWidth;\n  float invFrameHeight = 1./frameHeight;\n  float numFrames = endFrame - startFrame + 1.;\n  float currentFrame = floor( mix( startFrame, endFrame + .99999, timeRatio ) );\n\n  currentFrame = frameStyle == 0. ? currentFrame \n    : frameStyle == 1. ? ( floor( pseudoRandom( currentFrame * 6311. + seed ) * numFrames ) + startFrame  )\n    : ( floor( seed * numFrames ) + startFrame );\n\n  float tx = mod( currentFrame, frameWidth ) * invFrameWidth;\n  float ty = 1. - floor( currentFrame * invFrameWidth ) * invFrameHeight;\n  float sx = invFrameWidth;\n  float sy = invFrameHeight;\n  float cx = .5 * sx;\n  float cy = -.5 * sy;\n  float c = cos( rotation );\n  float s = sin( rotation );\n\n  mat3 uvrot = mat3( vec3( c, -s, 0. ), vec3( s, c, 0. ), vec3( 0., 0., 1.) );\n  mat3 uvtrans = mat3( vec3( 1., 0., 0. ), vec3( 0., 1., 0. ), vec3( tx + cx, ty + cy, 1. ) );\n  mat3 uvscale = mat3( vec3( sx, 0., 0. ), vec3( 0., sy, 0. ), vec3( 0., 0., 1.) );\n  mat3 uvcenter = mat3( vec3( 1., 0., 0. ), vec3( 0., 1., 0. ), vec3( -cx / sx, cy / sy, 1. ) );  \n\n  vUvTransform = uvtrans * uvscale * uvrot * uvcenter;\n\n#endif // USE_FRAMES_OR_ROTATION\n\n#if defined(USE_RIBBON)\n#else\n  gl_PointSize = scale * particleSize * mix( 1., 1. / - mvPosition.z, usePerspective );\n#endif // USE_RIBBON\n\n  gl_Position = projectionMatrix * mvPosition;\n\n  if (scale <= 0. || timeRatio < 0. || timeRatio > 1. )\n  {\n    gl_Position.w = -2.; // don't draw\n  }\n}",di="\nprecision highp float;\nprecision highp int;\n\nuniform sampler2D map;\nuniform vec3 fogColor;\nuniform float fogNear;\nuniform float fogFar;\n\nvarying mat3 vUvTransform;\nvarying vec4 vParticleColor;\nvarying vec2 vUv;\nvarying float vFogDepth;\n\nvoid main()\n{\n\n#if defined(USE_RIBBON)\n  vec2 uv = ( vUvTransform * vec3( vUv, 1. ) ).xy;\n#else\n  vec2 uv = ( vUvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1. ) ).xy;\n#endif // USE_RIBBON\n\n  vec4 diffuseColor = vParticleColor;\n\n  vec4 mapTexel = texture2D( map, uv );\n  // diffuseColor *= mapTexelToLinear( mapTexel );\n  diffuseColor *= mapTexel;\n\n#if defined(ALPHATEST)\n  if ( diffuseColor.a < ALPHATEST ) {\n    discard;\n  }\n#endif // ALPHATEST\n\n  gl_FragColor = diffuseColor;\n\n#if defined(USE_FOG)\n  float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );\n\n  gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif // USE_FOG\n}",hi=THREE.Math.degToRad,ui={acceleration:"USE_PARTICLE_ACCELERATION",angularAcceleration:"USE_PARTICLE_ANGULAR_ACCELERATION",angularVelocity:"USE_PARTICLE_ANGULAR_VELOCITY",color:"USE_PARTICLE_COLOR",textureFrame:"USE_PARTICLE_FRAMES",textureCount:"USE_PARTICLE_FRAMES",textureLoop:"USE_PARTICLE_FRAMES",position:"USE_PARTICLE_OFFSET",opacity:"USE_PARTICLE_OPACITY",radialAcceleration:"USE_PARTICLE_RADIAL_ACCELERATION",radialPosition:"USE_PARTICLE_RADIAL_OFFSET",radialVelocity:"USE_PARTICLE_RADIAL_VELOCITY",scale:"USE_PARTICLE_SCALE",velocity:"USE_PARTICLE_VELOCITY",orbitalVelocity:"USE_PARTICLE_ORBITAL",orbitalAcceleration:"USE_PARTICLE_ORBITAL",drag:"USE_PARTICLE_DRAG",destinationWeight:"USE_PARTICLE_DESTINATION",screenDepthOffset:"USE_PARTICLE_SCREEN_DEPTH_OFFSET",source:"USE_PARTICLE_SOURCE",model:"USE_PARTICLE_SOURCE"},mi=["overtime","interval"],pi=["newest","oldest","any"],fi=["x","y","z"],gi=e=>e.reduce((e,t)=>Array.isArray(t)?e.concat(gi(t)):e.concat(t),[]),vi=(e,t)=>{let i=e.split("->").map(e=>e.trim().split(" ").map(e=>{const t=Number(e);return isNaN(t)?void 0:t}));return 1===i.length&&(i[1]=i[0]),i.length=2,gi(i.map(e=>t.map((t,i)=>void 0===e[i]?t:e[i])))},yi=(e,t)=>gi(e.split(",").map(e=>vi(e,t)));function bi(e){return e.toLowerCase()}let Ei=new THREE.DataTexture(new Uint8Array(3).fill(255),1,1,THREE.RGBFormat);Ei.needsUpdate=!0;const xi={none:THREE.NoBlending,normal:THREE.NormalBlending,additive:THREE.AdditiveBlending,subtractive:THREE.SubtractiveBlending,multiply:THREE.MultiplyBlending},Ti={double:THREE.DoubleSide,front:THREE.FrontSide,back:THREE.BackSide};AFRAME.registerComponent("sprite-particles",{schema:{texture:{type:"map"},delay:{default:0},duration:{default:-1},spawnType:{default:"continuous",oneOf:["continuous","burst"],parse:bi},spawnRate:{default:10},source:{type:"selector"},textureFrame:{type:"vec2",default:{x:1,y:1}},textureCount:{type:"int",default:0},textureLoop:{default:1},randomizeFrames:{default:!1},trailInterval:{default:0},trailLifeTime:{default:"0"},trailType:{default:"particle",oneOf:["particle","ribbon","ribbon3d"]},ribbonWidth:{default:1},ribbonShape:{default:"flat",oneOf:["flat","taperin","taperout","taper"],parse:bi},ribbonUVType:{default:"overtime",oneOf:mi,parse:bi},emitterColor:{type:"color"},lifeTime:{default:"1"},position:{default:"0 0 0"},velocity:{default:"0 0 0"},acceleration:{default:"0 0 0"},radialType:{default:"circle",oneOf:["circle","sphere","circlexy","circlexz"],parse:bi},radialPosition:{default:"0"},radialVelocity:{default:"0"},radialAcceleration:{default:"0"},angularVelocity:{default:"0 0 0"},angularAcceleration:{default:"0 0 0"},orbitalVelocity:{default:"0"},orbitalAcceleration:{default:"0"},scale:{default:"1"},color:{default:"white",parse:bi},rotation:{default:"0"},opacity:{default:"1"},velocityScale:{default:0},velocityScaleMinMax:{type:"vec2",default:{x:0,y:3}},drag:{default:0},destination:{type:"selector"},destinationOffset:{default:"0 0 0"},destinationWeight:{default:"0"},events:{default:""},enabled:{default:!0},emitterTime:{default:0},model:{type:"selector"},modelFill:{default:"triangle",oneOf:["triangle","edge","vertex"],parse:bi},direction:{default:"forward",oneOf:["forward","backward"],parse:bi},particleOrder:{default:"any",oneOf:pi},ribbonUVMultiplier:{default:1},materialSide:{default:"front",oneOf:["double","front","back"],parse:bi},screenDepthOffset:{default:0},alphaTest:{default:0},fog:{default:!0},depthWrite:{default:!1},depthTest:{default:!0},blending:{default:"normal",oneOf:["none","normal","additive","subtractive","multiply"],parse:bi},transparent:{default:!0},particleSize:{default:100},usePerspective:{default:!0},seed:{type:"number",default:-1},overTimeSlots:{type:"int",default:5},frustumCulled:{default:!0},editorObject:{default:!0}},multiple:!0,help:"https://github.com/harlyq/aframe-sprite-particles-component",init(){this.handleObject3DSet=this.handleObject3DSet.bind(this),this.count=0,this.trailCount=0,this.overTimeArrayLength=0,this.emitterTime=0,this.delayTime=0,this.lifeTime=[1,1],this.trailLifeTime=[0,0],this.paused=!1,this.textureFrames=new Float32Array(4),this.offset=new Float32Array(8).fill(0),this.velocity=new Float32Array(8).fill(0),this.acceleration=new Float32Array(8).fill(0),this.angularVelocity=new Float32Array(8).fill(0),this.angularAcceleration=new Float32Array(8).fill(0),this.orbital=new Float32Array(4).fill(0),this.colorOverTime,this.rotationScaleOverTime,this.params=new Float32Array(20).fill(0),this.velocityScale=new Float32Array(3).fill(0),this.emitterColor=new THREE.Vector3,this.destination=new Float32Array(8).fill(0),this.destinationOffset,this.destinationWeight,this.nextID=0,this.nextTime=0,this.startDisabled=!this.data.enabled||!!this.data.events,this.manageIDs=!1,this.params[1]=-1,this.eventListener=ie(this.el,this.onEvent.bind(this)),this.delayClock=ee()},remove(){this.mesh&&this.el.removeObject3D(this.mesh.name),this.data.model&&this.data.model.removeEventListener("object3dset",this.handleObject3DSet),this.eventListener.remove(),this.delayClock.clearAllTimers()},update(e){const t=this.data;let i=t.particleSize!==e.particleSize,n=!1;if(t.overTimeSlots===e.overTimeSlots||this.isPlaying||(this.overTimeArrayLength=2*this.data.overTimeSlots+1,this.colorOverTime=new Float32Array(4*this.overTimeArrayLength).fill(0),this.rotationScaleOverTime=new Float32Array(2*this.overTimeArrayLength).fill(0),n=!0),this.params[8]=t.particleSize,this.params[9]=t.usePerspective?1:0,this.params[10]="forward"===t.direction?0:1,this.params[11]=THREE.Math.clamp(t.drag,0,1),this.params[15]=1e-5*t.screenDepthOffset,this.params[16]=t.ribbonWidth,this.params[17]=t.ribbonUVMultiplier,this.textureFrames[0]=t.textureFrame.x,this.textureFrames[1]=t.textureFrame.y,this.textureFrames[2]=t.textureCount>0?t.textureCount:t.textureFrame.x*t.textureFrame.y,this.textureFrames[3]=t.textureLoop,this.velocityScale[0]=t.velocityScale,this.velocityScale[1]=t.velocityScaleMinMax.x,this.velocityScale[2]=t.velocityScaleMinMax.y,this.material&&(this.material.alphaTest=t.alphaTest,this.material.depthTest=t.depthTest,this.material.depthWrite=t.depthWrite,this.material.blending=xi[t.blending],this.material.fog=t.fog),t.seed!==e.seed&&(this.seed=t.seed,this.params[6]=t.seed>=0?t.seed:Math.random()),t.ribbonUVType!==e.ribbonUVType&&(this.params[18]=-1===mi.indexOf(t.ribbonUVType)?0:mi.indexOf(t.ribbonUVType)),t.radialType!==e.radialType&&(this.params[2]=["sphere","circlexy","circle"].includes(t.radialType)?1:0,this.params[19]=["sphere","circlexz"].includes(t.radialType)?1:0),this.mesh&&t.frustumCulled!==e.frustumCulled&&(this.mesh.frustumCulled=t.frustumCulled),t.emitterColor!==e.emitterColor){const e=new THREE.Color(t.emitterColor);this.emitterColor.set(e.r,e.g,e.b)}if(t.position===e.position&&t.radialPosition===e.radialPosition||(this.updateVec4XYZRange(t.position,"offset"),this.updateVec4WRange(t.radialPosition,[0],"offset"),i=!0),t.velocity===e.velocity&&t.radialVelocity===e.radialVelocity||(this.updateVec4XYZRange(t.velocity,"velocity"),this.updateVec4WRange(t.radialVelocity,[0],"velocity"),i=!0),t.acceleration===e.acceleration&&t.radialAcceleration===e.radialAcceleration||(this.updateVec4XYZRange(t.acceleration,"acceleration"),this.updateVec4WRange(t.radialAcceleration,[0],"acceleration"),i=!0),(t.rotation!==e.rotation||t.scale!==e.scale||n)&&(this.updateRotationScaleOverTime(),i=!0),(t.color!==e.color||t.opacity!==e.opacity||n)&&this.updateColorOverTime(),t.lifeTime!==e.lifeTime&&(this.lifeTime=this.updateVec4WRange(t.lifeTime,[1],"angularVelocity")),t.angularVelocity!==e.angularVelocity&&this.updateAngularVec4XYZRange(t.angularVelocity,"angularVelocity"),t.trailLifeTime!==e.trailLifeTime&&(this.trailLifeTime=vi(t.trailLifeTime,[0]).map((e,t)=>e>0?e:this.lifeTime[t]),this.angularAcceleration[3]=this.trailLifeTime[0],this.angularAcceleration[7]=this.trailLifeTime[1]),t.angularAcceleration!==e.angularAcceleration&&this.updateAngularVec4XYZRange(t.angularAcceleration,"angularAcceleration"),t.orbitalVelocity!==e.orbitalVelocity&&this.updateAngularVec2PartRange(t.orbitalVelocity,[0],"orbital",0),t.orbitalAcceleration!==e.orbitalAcceleration&&this.updateAngularVec2PartRange(t.orbitalAcceleration,[0],"orbital",1),t.destinationOffset!==e.destinationOffset&&(this.destinationOffset=this.updateVec4XYZRange(t.destinationOffset,"destination")),t.destinationWeight!==e.destinationWeight&&(this.destinationWeight=this.updateVec4WRange(t.destinationWeight,[0],"destination")),t.duration===e.duration&&t.delay===e.delay&&t.emitterTime===e.emitterTime||(this.params[3]=t.duration,this.emitterTime=t.emitterTime,this.delayTime=t.delay),t.spawnType!==e.spawnType||t.spawnRate!==e.spawnRate||t.lifeTime!==e.lifeTime||t.trailInterval!==e.trailInterval){const e=this.lifeTime[1],i=t.trailInterval>0?this.trailLifeTime[1]:0,n=e+i,a=Math.max(1,Math.ceil(n*t.spawnRate));this.trailCount=1+(t.trailInterval>0?Math.ceil(Math.min(i,e)/t.trailInterval):0),this.isRibbon()?(this.trailCount++,this.count=a*this.trailCount*2):this.count=a*this.trailCount,this.params[4]="burst"===t.spawnType?0:1,this.params[5]=t.spawnRate,this.params[7]=this.count,this.params[13]=a,this.params[12]=t.trailInterval,this.params[14]=this.trailCount,this.updateAttributes()}t.enabled&&this.startDisabled&&!t.events&&(this.startDisabled=!1),t.model!==e.model&&t.model&&"getObject3D"in t.model&&(e.model&&e.model.removeEventListener("object3dset",this.handleObject3DSet),this.updateModelMesh(t.model.getObject3D("mesh")),t.model&&t.model.addEventListener("object3dset",this.handleObject3DSet)),this.mesh?this.updateDefines():this.createMesh(),t.materialSide!==e.materialSide&&(this.material.side=Ti[t.materialSide]),i&&this.updateBounds(),this.paused&&t.editorObject!==e.editorObject&&this.enableEditorObject(t.editorObject),this.manageIDs=this.manageIDs||!t.enabled||!!t.events||t.source||void 0!==this.el.getDOMAttribute(this.attrName).enabled||t.model||t.delay>0,t.texture!==e.texture&&this.loadTexture(t.texture),t.events!==e.events&&this.eventListener.set(t.events)},tick(e,t){const i=this.data;if(this.startDisabled)return;t>100&&(t=100);const n=t/1e3;i.enabled&&(this.delayTime-=n),this.delayTime>=0||i.model&&!this.modelVertices||(this.emitterTime+=n,this.params[0]=this.emitterTime,this.geometry&&this.manageIDs?this.spawnParticles(this.emitterTime):this.params[1]=-1,i.destination&&i.destination.object3D&&(this.destinationWeight[0]>0||this.destinationWeight[1]>0)&&this.updateDestinationEntity())},pause(){this.paused=!0,this.enableEditorObject(this.data.editorObject),this.eventListener.remove(),this.delayClock.pause()},play(){this.paused=!1,this.enableEditorObject(!1),this.eventListener.add(),this.delayClock.resume()},onEvent(){const e=this,t=this.data;this.delayClock.startTimer(t.delay,()=>{e.emitterTime=t.emitterTime,e.nextTime=0,e.nextID=0,e.delayTime=0,e.startDisabled=!1})},handleObject3DSet(e){e.target===this.data.model&&"mesh"===e.detail.type&&this.updateModelMesh(this.data.model.getObject3D("mesh"))},loadTexture(e){if(e){this.el.sceneEl.systems.material.loadTexture(e,{src:e},e=>{this.isRibbon()&&(e.wrapS=THREE.RepeatWrapping),this.material.uniforms.map.value=e})}else this.material.uniforms.map.value=Ei},isRibbon(){return this.data.trailInterval>0&&"particle"!==this.data.trailType},createMesh(){const e=this.data;this.geometry=new THREE.BufferGeometry,this.updateAttributes(),this.material=new THREE.ShaderMaterial({uniforms:{map:{type:"t",value:Ei},textureFrames:{value:this.textureFrames},params:{value:this.params},offset:{value:this.offset},velocity:{value:this.velocity},acceleration:{value:this.acceleration},angularVelocity:{value:this.angularVelocity},angularAcceleration:{value:this.angularAcceleration},orbital:{value:this.orbital},colorOverTime:{value:this.colorOverTime},rotationScaleOverTime:{value:this.rotationScaleOverTime},velocityScale:{value:this.velocityScale},emitterColor:{value:this.emitterColor},destination:{value:this.destination},fogDensity:{value:25e-5},fogNear:{value:1},fogFar:{value:2e3},fogColor:{value:new THREE.Color(16777215)}},fragmentShader:Ci,vertexShader:Mi,transparent:e.transparent,alphaTest:e.alphaTest,blending:xi[e.blending],fog:e.fog,depthWrite:e.depthWrite,depthTest:e.depthTest,defines:{}}),this.updateDefines(),this.isRibbon()?(this.mesh=new THREE.Mesh(this.geometry,[this.material]),this.mesh.drawMode=THREE.TriangleStripDrawMode):this.mesh=new THREE.Points(this.geometry,this.material),this.mesh.frustumCulled=e.frustumCulled,this.mesh.name=this.attrName,this.material.name=this.mesh.name,this.el.setObject3D(this.mesh.name,this.mesh)},updateColorOverTime(){let e=(e=>gi(e.split(",").map(e=>{let t=e.split("->");return 1===t.length&&(t[1]=t[0]),t.length=2,t.map(e=>new THREE.Color(e.trim()))})))(this.data.color),t=yi(this.data.opacity,[1]);const i=this.data.overTimeSlots;e.length>2*i&&(e.length=2*i),t.length>2*i&&(t.length=2*i),this.colorOverTime.fill(0),this.colorOverTime[0]=e.length/2,this.colorOverTime[1]=t.length/2;let n=e.length;for(let t=0,i=4;t<n;t++,i+=4){let n=e[t];this.colorOverTime[i]=n.r,this.colorOverTime[i+1]=n.g,this.colorOverTime[i+2]=n.b}n=t.length;for(let e=0,i=4;e<n;e++,i+=4){let n=t[e];this.colorOverTime[i+3]=n}},updateRotationScaleOverTime(){const e=this.data.overTimeSlots;let t=yi(this.data.rotation,[0]),i=yi(this.data.scale,[1]);t.length>2*e&&(t.length=2*e),i.length>2*e&&(i.length=2*e),this.rotationScaleOverTime.fill(0),this.rotationScaleOverTime[0]=t.length/2,this.rotationScaleOverTime[1]=i.length/2;let n=t.length;for(let e=0,i=2;e<n;e++,i+=2)this.rotationScaleOverTime[i]=hi(t[e]);n=i.length;for(let e=0,t=2;e<n;e++,t+=2)this.rotationScaleOverTime[t+1]=i[e]},updateVec4XYZRange(e,t){const i=vi(e,[0,0,0]);for(let e=0,n=0;e<i.length;)this[t][n++]=i[e++],this[t][n++]=i[e++],this[t][n++]=i[e++],n++;return i},updateAngularVec4XYZRange(e,t){const i=vi(e,[0,0,0]);for(let e=0,n=0;e<i.length;)this[t][n++]=hi(i[e++]),this[t][n++]=hi(i[e++]),this[t][n++]=hi(i[e++]),n++},updateAngularVec2PartRange(e,t,i,n){const a=vi(e,t);this[i][n]=hi(a[0]),this[i][n+2]=hi(a[1])},updateVec4WRange(e,t,i){let n=vi(e,t);return this[i][3]=n[0],this[i][7]=n[1],n},updateBounds(){const e=this.data;let t=Math.max(this.lifeTime[0],this.lifeTime[1]);let i=[new Array(4),new Array(4)];e.drag>0&&(t*=1-.5*e.drag);for(let e=0;e<2;e++){const n=0===e?Math.min:Math.max;for(let a=0;a<4;a++){const s=n(this.offset[a],this.offset[a+4]),r=n(this.velocity[a],this.velocity[a+4]),o=n(this.acceleration[a],this.acceleration[a+4]);i[e][a]=s+(r+.5*o*t)*t,i[e][a]=n(i[e][a],s);const l=-r/o;l>0&&l<t&&(i[e][a]=n(i[e][a],s-.5*r*r/o))}}this.modelBounds&&(i[0][0]+=this.modelBounds.min.x,i[0][1]+=this.modelBounds.min.y,i[0][2]+=this.modelBounds.min.z,i[1][0]+=this.modelBounds.max.x,i[1][1]+=this.modelBounds.max.y,i[1][2]+=this.modelBounds.max.z);const n=this.el.getDOMAttribute(this.attrName),a=this.rotationScaleOverTime.reduce((e,t,i)=>1&i?Math.max(e,t):e,0),s=Math.max(Math.abs(i[0][3]),Math.abs(i[1][3]))+45e-5*e.particleSize*a,r="sphere"===e.radialType||n.angularVelocity||n.angularAcceleration||n.orbitalVelocity||n.orbitalAcceleration;i[0][0]-=s,i[0][1]-=s,i[0][2]-=r?s:0,i[1][0]+=s,i[1][1]+=s,i[1][2]+=r?s:0,i[0].length=3,i[0].length=3;const o=Math.max(...i[0].map(Math.abs),...i[1].map(Math.abs));this.geometry.boundingSphere||(this.geometry.boundingSphere=new THREE.Sphere),this.geometry.boundingSphere.radius=o,this.geometry.boundingBox||(this.geometry.boundingBox=new THREE.Box3),this.geometry.boundingBox.min.set(...i[0]),this.geometry.boundingBox.max.set(...i[1]);const l=this.el.getObject3D("mesh");l&&l.isParticlesEditorObject&&this.enableEditorObject(!0)},updateDestinationEntity:function(){let e=new THREE.Vector3,t=new THREE.Vector3;return function(){this.data.destination.object3D.getWorldPosition(e),this.el.object3D.getWorldPosition(t),e.sub(t);for(let t=0,i=fi.length;t<i;t++)this.destination[t]=e[fi[t]]+this.destinationOffset[t],this.destination[t+4]=e[fi[t]]+this.destinationOffset[t+3]}}(),enableEditorObject(e){const t=this.el.getObject3D("mesh");if(!e||t&&!t.isParticlesEditorObject)!e&&t&&t.isParticlesEditorObject&&this.el.removeObject3D("mesh");else{const e=.25,t=new THREE.Vector3(e,e,e).max(this.geometry.boundingBox.max),i=new THREE.Vector3(-e,-e,-e).min(this.geometry.boundingBox.min);let n=new THREE.Box3(i,t),a=new THREE.Box3Helper(n,8421376);a.isParticlesEditorObject=!0,a.visible=!1,this.el.setObject3D("mesh",a)}},updateAttributes(){if(this.geometry){const e=this.count;let t=new Float32Array(e);if(this.startDisabled||this.data.delay>0||this.data.model)t.fill(-1);else for(let i=0;i<e;i++)t[i]=i;if(this.geometry.addAttribute("vertexID",new THREE.Float32BufferAttribute(t,1)),this.geometry.addAttribute("position",new THREE.Float32BufferAttribute(new Float32Array(3*e).fill(0),3)),this.data.source&&this.geometry.addAttribute("quaternion",new THREE.Float32BufferAttribute(new Float32Array(4*e).fill(0),4)),this.isRibbon()){this.geometry.clearGroups();const t=2*this.trailCount;for(let i=0;i<e;i+=t)this.geometry.addGroup(i,t,0)}}},updateDefines(){const e=this.data,t=Object.keys(this.el.getDOMAttribute(this.attrName)),i=t.map(e=>ui[e]).filter(e=>e);let n={PARAMS_LENGTH:5,OVER_TIME_ARRAY_LENGTH:this.overTimeArrayLength,RANDOM_REPEAT_COUNT:131072,USE_MAP:!0};for(let e of i)n[e]=!0;e.velocityScale>0&&(n.USE_PARTICLE_VELOCITY_SCALE=!0),e.trailInterval>0&&(this.isRibbon()?"ribbon"===e.trailType?n.USE_RIBBON_TRAILS=!0:n.USE_RIBBON_3D_TRAILS=!0:n.USE_PARTICLE_TRAILS=!0),e.randomizeFrames&&(n.USE_PARTICLE_RANDOMIZE_FRAMES=!0),t.includes("rotation")&&(this.isRibbon()?n.USE_RIBBON_ROTATION=!0:n.USE_PARTICLE_ROTATION=!0);let a="1.";if("taperout"===e.ribbonShape?a="1. - p":"taperin"===e.ribbonShape?a="p":"taper"===e.ribbonShape?a="2. * ( p < .5 ? p : 1. - p )":"="===e.ribbonShape[0]&&(a=e.ribbonShape.slice(1)),n.RIBBON_SHAPE_FUNCTION=a,e.source?n.PARTICLE_ORDER=2:n.PARTICLE_ORDER=pi.indexOf(e.particleOrder),n.PARTICLE_TRAIL_ORDER=pi.indexOf(e.particleOrder),Object.keys(n).filter(e=>this.material.defines[e]!==n[e]).length>0)if(this.isPlaying){const e=t.filter(e=>{const t=ui[e];return t&&!this.material.defines[t]});console.error(`cannot add attributes (${e.join(",")}) at run-time`)}else this.material.defines=n,this.material.needsUpdate=!0},updateModelMesh(e){if(!e)return;this.modelBounds=new THREE.Box3,this.modelVertices;let t=0,i=0,n=0;const a=e=>{if(!e.geometry)return;let a=e.geometry.getAttribute("position");a&&3!==a.itemSize||(0==n?i+=a.array.length:(this.modelVertices.set(a.array,t),t+=a.array.length))};n=0,e.traverse(a),i>0&&(n=1,this.modelVertices=new Float32Array(i),e.traverse(a),wi(this.modelVertices,e.el.object3D.scale),this.modelBounds.setFromArray(this.modelVertices),this.updateBounds())},spawnParticles:function(){let e=new THREE.Vector3,t=new THREE.Quaternion,i=new THREE.Vector3,n=new THREE.Vector3,a=new THREE.Matrix4;return function(s){const r=this.data,o=this.count,l=this.data.spawnRate,c="burst"===r.spawnType,d=c?0:1/l,h=r.source&&null!=r.source.object3D,u=this.modelVertices&&this.modelVertices.length,m=this.isRibbon(),p=u||h;let f=this.geometry.getAttribute("vertexID"),g=this.geometry.getAttribute("position"),v=this.geometry.getAttribute("quaternion");h&&(this.el.object3D.updateMatrixWorld(),r.source.object3D.updateMatrixWorld(),a.getInverse(this.el.object3D.matrixWorld),a.multiply(r.source.object3D.matrixWorld),a.decompose(e,t,i),this.geometry.boundingSphere.center.copy(e));let y=this.nextID%o,b=0,E=y,x=this.nextID,T=Ai;switch(r.modelFill){case"edge":T=Ri;break;case"vertex":T=Si}for(;this.nextTime<s&&b<this.count;){u&&T(this.modelVertices,n);for(let i=0,a=m?2:1;i<a;i++)for(let i=0;i<this.trailCount;i++)x=this.nextID,u&&g.setXYZ(E,n.x,n.y,n.z),h&&(g.setXYZ(E,e.x,e.y,e.z),v.setXYZW(E,t.x,t.y,t.z,t.w)),f.setX(E,r.enabled?x:-1),E=(E+1)%o,b++,p?this.nextID++:this.nextID=E;this.nextTime+=d}if(b>0){const e=this.trailCount*(m?2:1);this.params[1]=Math.floor(x/e),c&&(this.nextTime+=this.lifeTime[1],r.trailInterval>0&&(this.nextTime+=this.trailLifeTime[1])),E<y&&(y=0,b=this.count),(h||u)&&(g.updateRange.offset=y,g.updateRange.count=b,g.needsUpdate=!0),h&&(v.updateRange.offset=y,v.updateRange.count=b,v.needsUpdate=!0),f.updateRange.offset=y,f.updateRange.count=b,f.needsUpdate=!0,this.nextID=this.nextID%131072}}}()});const wi=(e,t)=>{if(1!==t.x&&1!==t.y&&1!==t.z)for(let i=0,n=e.length;i<n;i+=3)e[i]*=t.x,e[i+1]*=t.y,e[i+2]*=t.z},Ai=function(){let e=new THREE.Vector3,t=new THREE.Vector3;return function(i,n){let a,s,r=9*Math.floor(Math.random()*i.length/9);e.fromArray(i,r),t.fromArray(i,r+3),n.fromArray(i,r+6);do{a=Math.random(),s=Math.random()}while(a+s>1);t.sub(e).multiplyScalar(a),n.sub(e).multiplyScalar(s).add(t).add(e)}}(),Ri=function(){let e=new THREE.Vector3,t=new THREE.Vector3,i=new THREE.Vector3;return function(n,a){let s=9*Math.floor(Math.random()*n.length/9);e.fromArray(n,s),t.fromArray(n,s+3),i.fromArray(n,s+6);let r=Math.random();r>2/3?a.copy(e).sub(i).multiplyScalar(3*r-2).add(i):r>1/3?a.copy(i).sub(t).multiplyScalar(3*r-1).add(t):a.copy(t).sub(e).multiplyScalar(3*r).add(e)}}();function Si(e,t){let i=3*Math.floor(Math.random()*e.length/3);t.fromArray(e,i)}const Mi="\n#include <common>\n// #include <color_pars_vertex>\n#include <fog_pars_vertex>\n// #include <morphtarget_pars_vertex>\n// #include <logdepthbuf_pars_vertex>\n// #include <clipping_planes_pars_vertex>\n\nattribute float vertexID;\n\n#if defined(USE_PARTICLE_SOURCE)\nattribute vec4 quaternion;\n#endif\n\nuniform vec4 params[PARAMS_LENGTH];\nuniform vec4 offset[2];\nuniform vec4 velocity[2];\nuniform vec4 acceleration[2];\nuniform vec4 angularVelocity[2];\nuniform vec4 angularAcceleration[2];\nuniform vec2 orbital[2];\nuniform vec4 colorOverTime[OVER_TIME_ARRAY_LENGTH];\nuniform vec2 rotationScaleOverTime[OVER_TIME_ARRAY_LENGTH];\nuniform vec4 textureFrames;\nuniform vec3 velocityScale;\nuniform vec4 destination[2];\n\nvarying vec4 vParticleColor;\nvarying vec2 vCosSinRotation;\nvarying vec2 vUv;\nvarying float vOverTimeRatio;\nvarying float vFrame;\n\nfloat VERTS_PER_RIBBON = 2.;\n\n// alternative random algorithm, used for the initial seed.  Provides a better\n// result than using rand()\nfloat pseudoRandom( const float seed )\n{\n  return mod( 1664525.*seed + 1013904223., 4294967296. )/4294967296.; // we don't have enough precision in 32-bit float, but results look ok\n}\n\n// each call to random will produce a different result by varying randI\nfloat randI = 0.;\nfloat random( const float seed )\n{\n  randI += 0.001;\n  return rand( vec2( seed, randI ));\n}\n\nvec3 randVec3Range( const vec3 range0, const vec3 range1, const float seed )\n{\n  vec3 lerps = vec3( random( seed ), random( seed ), random( seed ) );\n  return mix( range0, range1, lerps );\n}\n\nvec2 randVec2Range( const vec2 range0, const vec2 range1, const float seed )\n{\n  vec2 lerps = vec2( random( seed ), random( seed ) );\n  return mix( range0, range1, lerps );\n}\n\nfloat randFloatRange( const float range0, const float range1, const float seed )\n{\n  float lerps = random( seed );\n  return mix( range0, range1, lerps );\n}\n\n// theta.x is the angle in XY, theta.y is the angle in XZ\nvec3 radialToVec3( const float r, const vec2 theta )\n{\n  vec2 cosTheta = cos(theta);\n  vec2 sinTheta = sin(theta);\n  float rc = r * cosTheta.x;\n  float x = rc * cosTheta.y;\n  float y = r * sinTheta.x;\n  float z = rc * sinTheta.y;\n  return vec3( x, y, z );\n}\n\n// array lengths are stored in the first slot, followed by actual values from slot 1 onwards\n// colors are packed min,max,min,max,min,max,...\n// color is packed in xyz and opacity in w, and they may have different length arrays\n\nvec4 calcColorOverTime( const float r, const float seed )\n{\n  vec3 color = vec3(1.);\n  float opacity = 1.;\n\n#if defined(USE_PARTICLE_COLOR)\n  int colorN = int( colorOverTime[0].x );\n  if ( colorN == 1 )\n  {\n    color = randVec3Range( colorOverTime[1].xyz, colorOverTime[2].xyz, seed );\n  }\n  else if ( colorN > 1 )\n  {\n    float ck = r * ( float( colorN ) - 1. );\n    float ci = floor( ck );\n    int i = int( ci )*2 + 1;\n    vec3 sColor = randVec3Range( colorOverTime[i].xyz, colorOverTime[i + 1].xyz, seed );\n    vec3 eColor = randVec3Range( colorOverTime[i + 2].xyz, colorOverTime[i + 3].xyz, seed );\n    color = mix( sColor, eColor, ck - ci );\n  }\n#endif\n\n#if defined(USE_PARTICLE_OPACITY)\n  int opacityN = int( colorOverTime[0].y );\n  if ( opacityN == 1 )\n  {\n    opacity = randFloatRange( colorOverTime[1].w, colorOverTime[2].w, seed );\n  }\n  else if ( opacityN > 1 )\n  {\n    float ok = r * ( float( opacityN ) - 1. );\n    float oi = floor( ok );\n    int j = int( oi )*2 + 1;\n    float sOpacity = randFloatRange( colorOverTime[j].w, colorOverTime[j + 1].w, seed );\n    float eOpacity = randFloatRange( colorOverTime[j + 2].w, colorOverTime[j + 3].w, seed );\n    opacity = mix( sOpacity, eOpacity, ok - oi );\n  }\n#endif\n\n  return vec4( color, opacity );\n}\n\n// as per calcColorOverTime but euler rotation is packed in xyz and scale in w\n\nvec2 calcRotationScaleOverTime( const float r, const float seed )\n{\n  float rotation = 0.;\n  float scale = 1.;\n\n#if defined(USE_PARTICLE_ROTATION) || defined(USE_RIBBON_ROTATION)\n  int rotationN = int( rotationScaleOverTime[0].x );\n  if ( rotationN == 1 )\n  {\n    rotation = randFloatRange( rotationScaleOverTime[1].x, rotationScaleOverTime[2].x, seed );\n  }\n  else if ( rotationN > 1 )\n  {\n    float rk = r * ( float( rotationN ) - 1. );\n    float ri = floor( rk );\n    int i = int( ri )*2 + 1; // *2 because each range is 2 vectors, and +1 because the first vector is for the length info\n    float sRotation = randFloatRange( rotationScaleOverTime[i].x, rotationScaleOverTime[i + 1].x, seed );\n    float eRotation = randFloatRange( rotationScaleOverTime[i + 2].x, rotationScaleOverTime[i + 3].x, seed );\n    rotation = mix( sRotation, eRotation, rk - ri );\n  }\n#endif\n\n#if defined(USE_PARTICLE_SCALE)\n  int scaleN = int( rotationScaleOverTime[0].y );\n  if ( scaleN == 1 )\n  {\n    scale = randFloatRange( rotationScaleOverTime[1].y, rotationScaleOverTime[2].y, seed );\n  }\n  else if ( scaleN > 1 )\n  {\n    float sk = r * ( float( scaleN ) - 1. );\n    float si = floor( sk );\n    int j = int( si )*2 + 1; // *2 because each range is 2 vectors, and +1 because the first vector is for the length info\n    float sScale = randFloatRange( rotationScaleOverTime[j].y, rotationScaleOverTime[j + 1].y, seed );\n    float eScale = randFloatRange( rotationScaleOverTime[j + 2].y, rotationScaleOverTime[j + 3].y, seed );\n    scale = mix( sScale, eScale, sk - si );\n  }\n#endif\n\n  return vec2( rotation, scale );\n}\n\n// assumes euler order is YXZ (standard convention for AFrame)\nvec4 eulerToQuaternion( const vec3 euler )\n{\n  // from https://github.com/mrdoob/three.js/blob/master/src/math/Quaternion.js\n\n  vec3 c = cos( euler * .5 );\n  vec3 s = sin( euler * .5 );\n\n  return vec4(\n    s.x * c.y * c.z + c.x * s.y * s.z,\n    c.x * s.y * c.z - s.x * c.y * s.z,\n    c.x * c.y * s.z - s.x * s.y * c.z,\n    c.x * c.y * c.z + s.x * s.y * s.z\n  );\n}\n\n// from http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm\nvec4 axisAngleToQuaternion( const vec3 axis, const float angle ) \n{\n  return vec4( axis * sin( angle*.5 ), cos( angle*.5 ) );\n}\n\nvec3 applyQuaternion( const vec3 v, const vec4 q )\n{\n  return v + 2. * cross( q.xyz, cross( q.xyz, v ) + q.w * v );\n}\n\nvec3 displacement( const vec3 v, const vec3 a, const float t )\n{\n  return (v + 0.5 * a * t) * t;\n}\n\nfloat displacement1D( const float v, const float a, const float t )\n{\n  return (v + 0.5 * a * t) * t;\n}\n\nfloat ribbonShape( const float p )\n{\n  return RIBBON_SHAPE_FUNCTION;\n}\n\nvec3 particleMotion( const vec3 p, const vec3 v, const vec3 a, const vec3 av, const vec3 aa, const vec3 axis, const float ov, const float oa, const vec3 dest, const float weight, const float t )\n{\n  vec3 pos = p + displacement(v, a, t);\n\n#if defined(USE_PARTICLE_ANGULAR_VELOCITY) || defined(USE_PARTICLE_ANGULAR_ACCELERATION)\n  pos = applyQuaternion( pos, eulerToQuaternion( displacement(av, aa, t) ) );\n#endif\n\n#if defined(USE_PARTICLE_ORBITAL)\n  pos = applyQuaternion( pos, axisAngleToQuaternion( axis, displacement1D(ov, oa, t) ) );\n#endif\n\n#if defined(USE_PARTICLE_SOURCE)\n  pos = applyQuaternion( pos, quaternion );\n#endif\n\npos += position;\n\n#if defined(USE_PARTICLE_DESTINATION)\n  pos = mix( pos, dest, weight );\n#endif\n\n  return pos;\n}\n\nvec2 toScreen( const vec4 clipSpacePos )\n{\n  return clipSpacePos.xy / clipSpacePos.w;\n}\n\nvoid main() {\n\n  float time = params[0].x;\n  float cpuID = params[0].y;\n  float radialTypeX = params[0].z;\n  float radialTypeY = params[4].w;\n  float duration = params[0].w;\n  float spawnType = params[1].x;\n  float spawnRate = params[1].y;\n  float baseSeed = params[1].z;\n  float vertexCount = params[1].w;\n  float direction = params[2].z; // 0 is forward, 1 is backward  \n  float trailInterval = params[3].x;\n  float particleCount = params[3].y;\n  float trailCount = params[3].z;\n  float maxParticleLifeTime = angularVelocity[1].w; // lifeTime packed into w component of angularVelocity\n  float maxTrailLifeTime = angularAcceleration[1].w; // trailLifeTime packed into angularAcceleration.w\n  float particleLoopTime = particleCount / spawnRate;\n  float motionAge = -1.; // used to determine the age for particle movement\n\n#if defined(USE_PARTICLE_TRAILS) || defined(USE_RIBBON_TRAILS) || defined(USE_RIBBON_3D_TRAILS)\n  float maxAge = maxParticleLifeTime + maxTrailLifeTime;\n#else\n  float maxAge = maxParticleLifeTime;\n#endif\n\n  // the CPU manages IDs if it sets the position or disables particles, otherwise cpuID is -1\n  float particleID0 = cpuID > -EPSILON ? cpuID : floor( mod( time, particleLoopTime ) * spawnRate ); // this will lose precision eventually\n\n  vOverTimeRatio = -1.; // the vOverTimeRatio will be used for the lerps on over-time attributes\n\n  // particles are either emitted in a burst (spawnType == 0) or spread evenly\n  // throughout 0->particleLoopTime (spawnType == 1).  We calculate the ID of the last spawned particle particleID0 \n  // for this frame, any vertex IDs after particleID0 are assumed to belong to the previous loop\n\n  // vertex 0 = trail0 of particle0, vertex 1 = trail1 of particle0, ..., vertex k = trail0 of particle1, ...\n#if defined(USE_RIBBON_TRAILS) || defined(USE_RIBBON_3D_TRAILS)\n  float rawParticleID = floor( vertexID / VERTS_PER_RIBBON / trailCount );\n#else\n  float rawParticleID = floor( vertexID / trailCount );\n#endif\n\n  float particleLoop = floor( time / particleLoopTime );\n\n#if defined(USE_PARTICLE_SOURCE)\n  // find particleID relative to the last loop\n  float particleID = rawParticleID - floor( particleID0 / particleCount ) * particleCount;\n#else // defined(USE_PARTICLE_SOURCE)\n\n#if PARTICLE_ORDER == 0\n  float particleID = particleID0 - (particleCount - 1. - rawParticleID); // newest last\n#elif PARTICLE_ORDER == 1\n  float particleID = particleID0 - rawParticleID; // oldest last\n#else\n  float particleID = rawParticleID > particleID0 ? rawParticleID - particleCount : rawParticleID; // cyclic (any)\n#endif\n\n#endif // defined(USE_PARTICLE_SOURCE)\n\n  // for burst mode we use the rawParticleID, because the concept of particleID0 is irrelevant\n  particleID = mix( rawParticleID, particleID, spawnType ); \n\n  float particleStartTime = particleLoop * particleLoopTime + particleID / spawnRate * spawnType;\n\n  // we use the id as a seed for the randomizer, but because the IDs are fixed in \n  // the range 0->particleCount we calculate a virtual ID by taking into account\n  // the number of loops that have occurred (note, particles from the previous \n  // loop will have a negative particleID). We use the modoulo of the RANDOM_REPEAT_COUNT \n  // to ensure that the virtualID doesn't exceed the floating point precision\n\n  float virtualID = mod( particleID + particleLoop * particleCount, float( RANDOM_REPEAT_COUNT ) );\n  float seed = pseudoRandom( virtualID*baseSeed*110. );\n\n  float particleLifeTime = randFloatRange( angularVelocity[0].w, angularVelocity[1].w, seed );\n\n  float particleAge = time - particleStartTime;\n  particleAge = particleAge + direction * ( particleLoopTime - 2. * particleAge );\n\n  // don't show particles that would be emitted after the duration\n  if ( duration > 0. && time - particleAge >= duration ) \n  {\n    particleAge = -1.;\n  } \n\n  // always calculate the trailLifeTime, even if we don't use it, so the particles\n  // with the same seed give consistent results\n  float trailLifeTime = randFloatRange( angularAcceleration[0].w, angularAcceleration[1].w, seed );\n\n#if defined(USE_PARTICLE_TRAILS)\n\n  // +1 beceause we show both the lead particle and the first trail at the start\n  // we cap the particleAge to ensure it never goes past the particleLifeTime\n  float cappedParticleAge = min( particleLifeTime - trailInterval, particleAge );\n  float trailID0 = floor( cappedParticleAge / trailInterval ) + 1.;\n  float rawTrailID = mod( vertexID, trailCount );\n\n#if PARTICLE_TRAIL_ORDER == 0\n  float trailID = trailID0 - ( trailCount - 1. - rawTrailID ); // newest last\n#elif PARTICLE_TRAIL_ORDER == 1\n  float trailID = trailID0 - rawTrailID; // oldest last\n#else\n  float trailID = floor( trailID0 / trailCount ) * trailCount;\n  trailID += rawTrailID > mod( trailID0, trailCount ) ? rawTrailID - trailCount : rawTrailID; // cyclic (any order)\n#endif\n\n  float trailStartAge = trailID * trailInterval;\n  \n  if (particleAge > -EPSILON && trailStartAge > -EPSILON && trailStartAge < particleLifeTime + EPSILON)\n  {\n    if (particleAge < trailStartAge)\n    {\n      motionAge = particleAge;\n      vOverTimeRatio = 0.;\n    }\n    else if (particleAge < trailStartAge + trailLifeTime)\n    {\n      motionAge = trailStartAge;\n      vOverTimeRatio = (particleAge - trailStartAge)/trailLifeTime;\n    }\n  }\n\n#elif defined(USE_RIBBON_TRAILS) || defined(USE_RIBBON_3D_TRAILS)\n\n  // +1 to the trailID0 because the ribbon needs two elements to start\n  // we cap the particleAge to ensure it never goes past the particleLifeTime\n  float cappedParticleAge = min( particleLifeTime - trailInterval, particleAge );\n  float trailID0 = floor( cappedParticleAge / trailInterval ) + 1.;\n  float rawTrailID = floor( mod( vertexID / VERTS_PER_RIBBON, trailCount ) );\n  float trailID = max( 0., trailID0 - ( trailCount - 1. - rawTrailID ) ); // newest last\n\n  float trailStartAge = trailID * trailInterval;\n\n  if (particleAge > -EPSILON && trailStartAge > -EPSILON && trailStartAge < particleLifeTime + EPSILON)\n  {\n    // motionAge will typically be the trailStartAge, but the lead particle will be the \n    // cappedParticleAge, and the last particle will be the particleAge - trailLifeTime\n\n    motionAge = min( cappedParticleAge, max( particleAge - trailLifeTime, trailStartAge ) );\n    vOverTimeRatio = ( particleAge - motionAge ) / trailLifeTime;\n  }\n  else\n  {\n    motionAge = particleLifeTime;\n    vOverTimeRatio = 1.0;\n  }\n\n#else // defined(USE_PARTICLE_TRAILS) || defined(USE_RIBBON_TRAILS) || defined(USE_RIBBON_3D_TRAILS)\n\n  motionAge = particleAge;\n  vOverTimeRatio = particleAge/particleLifeTime;\n\n#endif // defined(USE_PARTICLE_TRAILS) || defined(USE_RIBBON_TRAILS) || defined(USE_RIBBON_3D_TRAILS)\n\n  // these checks were around large blocks of code above, but this caused instability\n  // in some of the particle systems, so instead we do all of the work, then cancel \n  // it out here\n  if ( particleStartTime < 0. || vertexID < 0. )\n  {\n    vOverTimeRatio = -1.;\n  }\n\n#if defined(USE_PARTICLE_DRAG)\n  // simulate drag by blending the motionAge to (1-.5*drag)*particleLifeTime\n  float drag = params[2].w;\n  motionAge = mix( .5*drag*vOverTimeRatio, 1. - .5*drag, vOverTimeRatio ) * particleLifeTime;\n#endif\n\n  vec3 p = vec3(0.); // position\n  vec3 v = vec3(0.); // velocity\n  vec3 a = vec3(0.); // acceleration\n  vec3 av = vec3(0.); // angular velocity\n  vec3 aa = vec3(0.); // angular acceleration\n  vec3 axis = vec3( 1., 0., 0. ); // axis of orbital motion\n  float ov = 0.; // orbital velocity\n  float oa = 0.; // orbital acceleration\n  vec3 dest = vec3(0.); // destination position\n  float destWeight = 0.; // destination weighting\n\n#if defined(USE_PARTICLE_OFFSET)\n  p = randVec3Range( offset[0].xyz, offset[1].xyz, seed );\n#endif\n\n#if defined(USE_PARTICLE_VELOCITY)\n  v = randVec3Range( velocity[0].xyz, velocity[1].xyz, seed );\n#endif\n\n#if defined(USE_PARTICLE_ACCELERATION)\n  a = randVec3Range( acceleration[0].xyz, acceleration[1].xyz, seed );\n#endif\n\n#if defined(USE_PARTICLE_RADIAL_OFFSET) || defined(USE_PARTICLE_RADIAL_VELOCITY) || defined(USE_PARTICLE_RADIAL_ACCELERATION)\n  vec2 ANGLE_RANGE[2];\n  vec2 radialDir = vec2( radialTypeX, radialTypeY );\n  ANGLE_RANGE[0] = vec2( 0., 0. ) * radialDir;\n  ANGLE_RANGE[1] = vec2( 2.*PI, 2.*PI ) * radialDir;\n\n  vec2 theta = randVec2Range( ANGLE_RANGE[0], ANGLE_RANGE[1], seed );\n#endif\n\n#if defined(USE_PARTICLE_RADIAL_OFFSET)\n  float pr = randFloatRange( offset[0].w, offset[1].w, seed );\n  vec3 p2 = radialToVec3( pr, theta );\n  p += p2;\n#endif\n\n#if defined(USE_PARTICLE_RADIAL_VELOCITY)\n  float vr = randFloatRange( velocity[0].w, velocity[1].w, seed );\n  vec3 v2 = radialToVec3( vr, theta );\n  v += v2;\n#endif\n\n#if defined(USE_PARTICLE_RADIAL_ACCELERATION)\n  float ar = randFloatRange( acceleration[0].w, acceleration[1].w, seed );\n  vec3 a2 = radialToVec3( ar, theta );\n  a += a2;\n#endif\n\n#if defined(USE_PARTICLE_ANGULAR_VELOCITY)\n  av = randVec3Range( angularVelocity[0].xyz, angularVelocity[1].xyz, seed );\n#endif\n\n#if defined(USE_PARTICLE_ANGULAR_ACCELERATION)\n  aa = randVec3Range( angularAcceleration[0].xyz, angularAcceleration[1].xyz, seed );\n#endif\n\n#if defined(USE_PARTICLE_ORBITAL)\n  if ( length(p) > EPSILON ) {\n    ov = randFloatRange( orbital[0].x, orbital[1].x, seed );\n    float oa = randFloatRange( orbital[0].y, orbital[1].y, seed );\n    float angle = displacement1D(ov, oa, motionAge);\n\n    vec3 randomOribit = vec3( random( seed ), random( seed ), random( seed ) ); // should never equal p or 0,0,0\n    axis = normalize( cross( normalize( p ), normalize( randomOribit ) ) );\n  }\n#endif\n\n#if defined(USE_PARTICLE_DESTINATION)\n  destWeight = randFloatRange( destination[0].w, destination[1].w, seed );\n  dest = randVec3Range( destination[0].xyz, destination[1].xyz, seed );\n#endif\n\n  vec3 transformed = particleMotion( p, v, a, av, aa, axis, ov, oa, dest, motionAge/particleLifeTime*destWeight, motionAge );\n\n  vec2 rotScale = calcRotationScaleOverTime( vOverTimeRatio, seed );\n  float particleScale = rotScale.y;\n  float c = cos( rotScale.x );\n  float s = sin( rotScale.x );\n\n  vParticleColor = calcColorOverTime( vOverTimeRatio, seed ); // rgba format\n\n#if defined(USE_PARTICLE_VELOCITY_SCALE)\n  // We repeat all of the displacement calculations at motionAge + a small amount (velocityScaleDelta).\n  // We convert the current position and the future position in screen space and determine\n  // the screen space velocity. VelocityScaleDelta is reasonably small to give better\n  // results for the angular and orbital displacement, and when drag is applied the effective\n  // velocity will tend to 0 as the vOverTimeRatio increases\n\n  float velocityScaleDelta = .02;\n\n#if defined(USE_PARTICLE_DRAG)\n  float futureT = motionAge + velocityScaleDelta*mix(1., 1. - drag, vOverTimeRatio);\n#else\n  float futureT = motionAge + velocityScaleDelta;\n#endif\n\n  vec4 pos2D = projectionMatrix * modelViewMatrix * vec4( transformed, 1. );\n\n  // use min(1) to ensure the particle stops at the destination position\n  vec3 transformedFuture = particleMotion( p, v, a, av, aa, axis, ov, oa, dest, min( 1., futureT/particleLifeTime )*destWeight, futureT );\n\n  vec4 pos2DFuture = projectionMatrix * modelViewMatrix * vec4( transformedFuture, 1. );\n\n  vec2 screen = pos2DFuture.xy / pos2DFuture.z - pos2D.xy / pos2D.z; // TODO divide by 0?\n  screen /= velocityScaleDelta; // gives screen units per second\n\n  float lenScreen = length( screen );\n  vec2 sinCos = vec2(screen.x, screen.y)/max( EPSILON, lenScreen); // 0 degrees is y == 1, x == 0\n  float c2 = c*sinCos.y + s*sinCos.x; // cos(a-b)\n  float s2 = s*sinCos.y - c*sinCos.x; // sin(a-b)\n\n  // replace rotation with our new rotation\n  c = c2;\n  s = s2;\n\n  // rescale the particle length by the z depth, because perspective will be applied later\n  float screenScale = clamp( lenScreen * pos2D.z * velocityScale.x, velocityScale.y, velocityScale.z );\n\n  particleScale *= screenScale;\n\n#endif // defined(USE_PARTICLE_VELOCITY_SCALE)\n\n  vCosSinRotation = vec2( c, s );\n\n  // #include <color_vertex>\n  // #include <begin_vertex> replaced by code above\n  // #include <morphtarget_vertex>\n  // #include <project_vertex> replaced below\n\n#if defined(USE_RIBBON_3D_TRAILS)\n  float ribbonID = mod( vertexID, VERTS_PER_RIBBON );\n  \n  {\n    float nextT = motionAge + trailInterval;\n    float ribbonWidth = params[4].x * ribbonShape( vOverTimeRatio );\n\n    vec3 nextPosition = particleMotion( p, v, a, av, aa, axis, ov, oa, dest, min( 1., nextT/particleLifeTime )*destWeight, nextT );\n    vec3 dir = nextPosition - transformed;\n    float dirLen = length( dir );\n\n    vec3 normal = dir;\n    vec3 up = vec3( 0., c, -s ); // rotation in YZ\n    if ( dirLen > EPSILON && abs( dot( dir, up ) ) < dirLen * 0.99 ) {\n      normal = normalize( cross( up, dir ) );\n    }\n\n    transformed += ribbonWidth * normal * ( 0.5 - ribbonID );  // +normal for ribbonID 0, -normal for ribbonID 1\n  }\n#endif\n\n  vec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );\n  gl_Position = projectionMatrix * mvPosition;\n\n  float usePerspective = params[2].y;\n\n#if defined(USE_RIBBON_TRAILS)\n  float ribbonID = mod( vertexID, VERTS_PER_RIBBON );\n  \n  {\n    mat4 m = projectionMatrix * modelViewMatrix;\n    vec2 curr = toScreen( gl_Position );\n\n    float nextT = motionAge + trailInterval;\n    vec3 nextPosition = particleMotion( p, v, a, av, aa, axis, ov, oa, dest, min( 1., nextT/particleLifeTime )*destWeight, nextT );\n    vec2 next2D = toScreen( m * vec4( nextPosition, 1. ) ) - curr;\n\n    vec2 dir = normalize( next2D );\n    vec2 normal = vec2( -dir.y, dir.x );\n\n    float ribbonWidth = params[4].x * ribbonShape( vOverTimeRatio );\n    float halfWidth = .5 * ribbonWidth * mix( 1., 1. / - mvPosition.z, usePerspective );\n  \n    gl_Position.xy += halfWidth * normal * ( 1. - ribbonID * 2. ); // +normal for ribbonID 0, -normal for ribbonID 1\n  }\n#endif\n\n#if defined(USE_PARTICLE_SCREEN_DEPTH_OFFSET)\n  float screenDepthOffset = params[3].w;\n\n#if defined(USE_PARTICLE_TRAILS) || defined(USE_RIBBON_TRAILS) || defined(USE_RIBBON_3D_TRAILS)\n  // multiply trailCount by 2 because trailID ranges from [-trailCount, trailCount]\n  gl_Position.z -= (particleID*trailCount*2. + trailID - trailID0)*gl_Position.w*screenDepthOffset/vertexCount;\n#else\n  gl_Position.z -= particleID*gl_Position.w*screenDepthOffset/vertexCount;\n#endif\n\n#endif // defined(USE_PARTICLE_SCREEN_DEPTH_OFFSET)\n\n// vFrame is an int, but we must pass it as a float, so add .5 now and floor() in the\n// fragment shader to ensure there is no rounding error\n#if defined(USE_PARTICLE_RANDOMIZE_FRAMES)\n  vFrame = floor ( random( seed ) * textureFrames.z ) + .5;\n#else\n  float textureCount = textureFrames.z;\n  float textureLoop = textureFrames.w;\n\n  vFrame = floor( mod( vOverTimeRatio * textureCount * textureLoop, textureCount ) ) + .5;\n#endif\n\n#if !defined(USE_RIBBON_TRAILS) && !defined(USE_RIBBON_3D_TRAILS)\n  float particleSize = params[2].x;\n\n  gl_PointSize = particleSize * particleScale * mix( 1., 1. / - mvPosition.z, usePerspective );\n#endif\n\n  // #include <logdepthbuf_vertex>\n  // #include <clipping_planes_vertex>\n  // #include <worldpos_vertex>\n  #include <fog_vertex>\n\n#if defined(USE_RIBBON_TRAILS) || defined(USE_RIBBON_3D_TRAILS)\n  float ribbonUVMultiplier = params[4].y;\n  float ribbonUVType = params[4].z;\n\n  vUv = vec2( mix( 1. - vOverTimeRatio, motionAge/trailInterval, ribbonUVType ) * ribbonUVMultiplier, 1. - ribbonID );\n#endif\n}",Ci="\n#include <common>\n#include <packing>\n// #include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n// #include <logdepthbuf_pars_fragment>\n// #include <clipping_planes_pars_fragment>\n\nuniform vec4 textureFrames;\nuniform vec3 emitterColor;\n\nvarying vec4 vParticleColor;\nvarying vec2 vCosSinRotation;\nvarying vec2 vUv;\nvarying float vOverTimeRatio;\nvarying float vFrame;\n\nvoid main() {\n  if ( vOverTimeRatio < 0. || vOverTimeRatio > 1. ) {\n    discard;\n  }\n\n  #include <clipping_planes_fragment>\n\n  vec3 outgoingLight = vec3( 0. );\n  vec4 diffuseColor = vec4( emitterColor, 1. );\n  mat3 uvTransform = mat3( 1. );\n\n#if defined(USE_PARTICLE_ROTATION) || defined(USE_PARTICLE_FRAMES) || defined(USE_PARTICLE_VELOCITY_SCALE)\n  {\n    vec2 invTextureFrame = 1. / textureFrames.xy;\n    float textureCount = textureFrames.z;\n    float textureLoop = textureFrames.w;\n\n    float frame = floor(vFrame);\n    float c = vCosSinRotation.x;\n    float s = vCosSinRotation.y;\n    float tx = mod( frame, textureFrames.x ) * invTextureFrame.x;\n    float ty = (textureFrames.y - 1. - floor( frame * invTextureFrame.x )) * invTextureFrame.y; // assumes textures are flipped on y\n    float sx = invTextureFrame.x;\n    float sy = invTextureFrame.y;\n    float cx = tx + invTextureFrame.x * .5;\n    float cy = ty + invTextureFrame.y * .5;\n  \n    uvTransform[0][0] = sx * c;\n    uvTransform[0][1] = -sx * s;\n    uvTransform[1][0] = sy * s;\n    uvTransform[1][1] = sy * c;\n    uvTransform[2][0] = c * tx + s * ty - ( c * cx + s * cy ) + cx;\n    uvTransform[2][1] = -s * tx + c * ty - ( -s * cx + c * cy ) + cy;\n  }\n#endif // defined(USE_PARTICLE_ROTATION) || defined(USE_PARTICLE_FRAMES) || defined(USE_PARTICLE_VELOCITY_SCALE)\n\n  // #include <logdepthbuf_fragment>\n  // #include <map_particle_fragment>\n  // #include <color_fragment>\n\n#ifdef USE_MAP\n\n#if defined(USE_RIBBON_TRAILS) || defined(USE_RIBBON_3D_TRAILS)\n  vec2 uv = ( uvTransform * vec3( vUv, 1. ) ).xy;\n#else\n  vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1. ) ).xy;\n#endif\n\n  vec4 mapTexel = texture2D( map, uv );\n  diffuseColor *= mapTexelToLinear( mapTexel );\n#endif // USE_MAP\n\n  #include <alphatest_fragment>\n\n  diffuseColor *= vParticleColor;\n  outgoingLight = diffuseColor.rgb;\n\n  gl_FragColor = diffuseColor;\n\n  // #include <premultiplied_alpha_fragment>\n  // #include <tonemapping_fragment>\n  // #include <encodings_fragment>\n  #include <fog_fragment>\n}";AFRAME.registerComponent("store",{schema:{type:{default:"temporary",oneOf:["temporary","local","session"],parse:function(e){return"string"==typeof e?e.toLowerCase():e}}},multiple:!0,updateSchema(e){"object"!=typeof e&&console.error(`invalid properties, expected format <property>:<value>; '${e}'`);const t=AFRAME.components[this.name].schema;let i={};for(let n in e)n in t||(i[n]={type:"string"});Object.keys(i).length>0&&this.extendSchema(i)},init(){this.binds=[],this.firstTime=!0,this.loadStorage(),this.el.emit("store-loaded",{store:this,name:this.attrName})},update(e){const t=this.data;for(let i of this.binds){const n=i.key;t[n]!==e[n]&&K(i.target,i.prop,t[n])}this.firstTime||this.saveStorage(),this.firstTime=!1},loadStorage(){const e=AFRAME.components[this.name].schema,t=this.data;if("temporary"!==t.type)for(let i in this.data)if(!(i in e)){let e=null;"local"===t.type?e=localStorage.getItem(i):"session"===t.type&&(e=sessionStorage.getItem(i)),null!==e&&(t[i]=e)}},saveStorage(){const e=AFRAME.components[this.name].schema,t=this.data;if("temporary"!==t.type)for(let i in this.data)i in e||("local"===t.type?localStorage.setItem(i,t[i]):"session"===t.type&&sessionStorage.setItem(i,t[i]))},bind(e,t,i){this.binds.find(e=>e.target===t&&e.prop===i)&&se(`bind '${t}.${i}' already exists`),this.binds.push({key:e,target:t,prop:i})},unbind(e,t,i){const n=this.binds.findIndex(n=>n.target===t&&n.prop===i&&n.key===e);n>=0?this.binds.splice(n,1):se(`unable to find bind '${t}.${i}' for store key '${e}'`)}}),AFRAME.registerComponent("store-bind",{schema:{store:{type:"selector"},from:{default:""},to:{default:""}},multiple:!0,init(){this.onStoreLoaded=this.onStoreLoaded.bind(this)},remove(){const e=this.data;this.removeListeners(e.store),this.unbind(e.store,e.from,e.to)},update(e){const t=this.data;this.unbind(e.store,e.from,e.to),this.bind(t.store,t.from,t.to),e.store!==t.store&&(this.removeListeners(e.store),this.addListeners(t.store))},addListeners(e){e&&e.addEventListener("store-loaded",this.onStoreLoaded)},removeListeners(e){e&&e.removeEventListener("store-loaded",this.onStoreLoaded)},onStoreLoaded(e){const t=this.data;this.bind(t.store,t.from,t.to)},bind(e,t,i){if(e&&t&&i){const[n,a]=t.split("."),s=e.components[n];s&&"bind"in s&&s.bind(a,this.el,i)}},unbind(e,t,i){if(e&&t&&i){const[n,a]=t.split("."),s=e.components[n];s&&"unbind"in s&&s.unbind(a,this.el,i)}}});function Ii(e,t){for(let i=0;i<t.length;i++)e.includes(t[i])||e.push(t[i]);return e}AFRAME.registerComponent("svg-ui",{schema:{template:{default:""},clickSelectors:{default:""},hoverSelectors:{default:""},touchSelectors:{default:""},touchDistance:{default:.07},resolution:{type:"vec2",default:{x:512,y:512}},touchDeadZone:{default:.5},bubbles:{default:!1},debug:{default:!1},enabled:{default:!0},useHoverClass:{default:!1},interactIfOccluded:{default:!1}},updateSchema(e){"object"!=typeof e&&re(this,`invalid properties, expected format <property>:<value>; '${e}'`);const t=AFRAME.components[this.name].schema;let i={};for(let n in e)n in t||(i[n]={type:"string"});Object.keys(i).length>0&&this.extendSchema(i)},init(){this.hasUIListeners=!1,this.raycasters=[],this.hoverEls=[],this.touchEls=new Map,this.hasPendingUpdateSVGTexture=!1,this.onObject3DSet=this.onObject3DSet.bind(this),this.onRaycasterIntersected=this.onRaycasterIntersected.bind(this),this.onRaycasterIntersectedCleared=this.onRaycasterIntersectedCleared.bind(this),this.onClick=this.onClick.bind(this),this.el.addEventListener("object3dset",this.onObject3DSet),this.createSVGTexture()},remove(){this.el.removeEventListener("object3dset",this.onObject3DSet),this.proxyEl&&this.proxyEl.parent&&this.proxyEl.parent.removeChild(this.proxyEl)},play(){this.addUIListeners()},pause(){this.removeUIListeners()},update(e){const t=this.data;e.template!==t.template?ne(t.template,"<svg",e=>{this.templateContent=e,(e=>"string"==typeof e&&/\<svg/.test(e))(e)||se(this,`template '${t.template}' doesn't look like SVG: ${e}`),this.createSVGFunction(e),this.requestUpdateSVGTexture()}):this.templateContent&&(Object.keys(e)!==Object.keys(t)&&this.createSVGFunction(this.templateContent),this.requestUpdateSVGTexture()),this.addUIListeners()},tick(){this.hasPendingUpdateSVGTexture&&this.updateSVGTexture(),this.data.enabled&&this.raycasters&&this.proxySVGEl&&this.updateHoverAndTouch()},setTemplate(e){this.templateContent=e,this.requestUpdateSVGTexture()},isSelectable(){const e=this.data;return e.clickSelectors||e.hoverSelectors||e.touchSelectors},addUIListeners(){!this.hasUIListeners&&this.isSelectable()&&(this.el.addEventListener("raycaster-intersected",this.onRaycasterIntersected),this.el.addEventListener("raycaster-intersected-cleared",this.onRaycasterIntersectedCleared),this.el.addEventListener("click",this.onClick),this.hasUIListeners=!1)},removeUIListeners(){this.hasUIListeners&&(this.el.removeEventListener("raycaster-intersected",this.onRaycasterIntersected),this.el.removeEventListener("raycaster-intersected-cleared",this.onRaycasterIntersectedCleared),this.el.removeEventListener("click",this.onClick),this.hasUIListeners=!1)},createSVGTexture(){const e=this.data;this.imageEl=document.createElement("img"),this.imageEl.width=e.resolution.x,this.imageEl.height=e.resolution.y,this.imageEl.isReady=!0;const t=this.texture=new THREE.Texture(this.imageEl);this.imageEl.onload=(()=>{t.needsUpdate=!0}),this.imageEl.onerror=(()=>{re(this,"invalid svg",this.lastContent),t.image.isReady=!0}),t.onUpdate=(()=>{t.image.isReady=!0}),this.requestUpdateSVGTexture(),this.showSVGTextureOnMesh()},requestUpdateSVGTexture(){this.hasPendingUpdateSVGTexture=!0},updateSVGTexture(){if(this.templateContent){let e=this.processTemplate(this.templateContent);if(this.data.debug&&console.log(e),this.isSelectable()&&(this.proxyEl||(this.proxyEl=document.createElement("div"),this.proxyEl.style.position="absolute",this.proxyEl.style.top="0",this.proxyEl.style.left="0",this.proxyEl.style.zIndex="-999",this.el.appendChild(this.proxyEl)),this.proxyEl.innerHTML=e,this.proxySVGEl=this.proxyEl.children[0],this.proxySVGEl.setAttribute("width",256),this.proxySVGEl.setAttribute("height",256),this.data.useHoverClass)){for(let e of this.hoverEls)if(e.id){const t=this.proxyEl.querySelector("#"+e.id);t&&t.classList.add("hover")}else se(this,`an element (${Z(e)}) matching the hoverSelectors (${this.data.hoverSelectors}), does not have an id`);e=this.proxyEl.innerHTML}this.pendingContent=e,this.updatePendingContent()}this.hasPendingUpdateSVGTexture=!1},updatePendingContent(){this.imageEl.isReady&&this.pendingContent&&(this.imageEl.src="data:image/svg+xml;utf8,"+this.pendingContent,this.imageEl.isReady=!1,this.lastContent=this.pendingContent,this.pendingContent=void 0)},showSVGTextureOnMesh(){const e=this.el.getObject3D("mesh");if(e&&!Array.isArray(e.material)){e.material.map=this.texture;const t=e.material.color;t&&(t.r<.95||t.g<.95||t.b<.95)&&se(this,"svg-ui material color is not white, it may be difficult to see the ui")}},createSVGFunction(e){const t=Object.keys(this.data).concat("return `"+e+"`");this.svgTextFunction=new Function(...t)},processTemplate(e){if(this.svgTextFunction){return this.svgTextFunction(...Object.values(this.data)).replace(/%/g,"%25").replace(/#/g,"%23")}},calcViewXYFomUV:function(){let e=new THREE.Vector2;return function(t){e.copy(t),this.texture.transformUv(e);const i=this.proxySVGEl.viewBox.animVal;return{x:i.width*e.x+i.x,y:i.height*e.y+i.y}}}(),calcElementsFromUV:function(){let e=new THREE.Vector2;return function(t,i,n){e.copy(t),this.texture.transformUv(e);const a=256*e.x,s=256*e.y;let r=document.elementsFromPoint(a,s).filter(e=>(function(e,t){let i=e;for(;i&&t!==i;)i=i.parentNode;return!!i})(e,this.proxySVGEl));return n&&console.log("hitElements",a,s,r),i&&(r=r.map(e=>(function(e,t){let i=e;for(;i&&"matches"in i&&!i.matches(t);)i=i.parentNode;return i&&"matches"in i?i:void 0})(e,i)).filter(e=>e),n&&console.log("selectedElements",r)),r}}(),updateHoverAndTouch(){let e=[];const t=this.data.interactIfOccluded,i=this.el;function n(e){const n=e.components.raycaster.intersections;return t?n.find(e=>e.object.el===i):n.length>0?n[0].object.el===e?n[1]:n[0]:void 0}for(let t of this.raycasters){const i=n(t);if(i.object.el===this.el){let n=[],a=!1;const s=this.touchEls.get(t);i&&(i.svg=this.calcViewXYFomUV(i.uv),s.lastMove&&(a=Math.hypot(s.lastMove.x-i.svg.x,s.lastMove.y-i.svg.y)>this.data.touchDeadZone),Ii(e,this.calcElementsFromUV(i.uv,this.data.hoverSelectors,!1)),i.distance<this.data.touchDistance&&(n=this.calcElementsFromUV(i.uv,this.data.touchSelectors,this.data.debug)));const r=n.map(e=>e.id);for(let e of s.elements)n.find(t=>t.id===e.id)||this.sendEvent("svg-ui-touchend",{uiTarget:e,intersection:i,touches:r},t);for(let e of n)s.elements.find(t=>t.id===e.id)?a&&this.sendEvent("svg-ui-touchmove",{uiTarget:e,intersection:i,touches:r},t):this.sendEvent("svg-ui-touchstart",{uiTarget:e,intersection:i,touches:r},t);!a&&s.lastMove||(s.lastMove=i.svg),s.elements=n}}const a=e.map(e=>e.id);let s=!1;for(let t of this.hoverEls)e.find(e=>e.id===t.id)||(this.sendEvent("svg-ui-hoverend",{uiTarget:t,hovers:a}),s=!0);for(let t of e)this.hoverEls.find(e=>e.id===t.id)||(this.sendEvent("svg-ui-hoverstart",{uiTarget:t,hovers:a}),s=!0);this.data.useHoverClass&&s&&this.requestUpdateSVGTexture(),this.hoverEls=e},sendEvent(e,t,i){this.data.debug&&console.log("emit",e,t,i),this.el.emit(e,t,this.data.bubbles),i&&i.emit(e,t,this.data.bubbles)},onObject3DSet(e){this.showSVGTextureOnMesh()},onRaycasterIntersected(e){this.data.debug&&console.log("onRaycasterIntersected",this.el.id);const t=e.detail.el;this.touchEls.set(t,{elements:[]}),this.raycasters.push(t)},onRaycasterIntersectedCleared(e){this.data.debug&&console.log("onRaycasterIntersectedCleared",this.el.id);const t=e.detail.el;this.raycasters.splice(this.raycasters.indexOf(t),1),this.touchEls.delete(t)},onClick(e){const t=this.data;if(t.debug&&console.log("click",this.el.id),e.detail.intersection&&t.enabled){let i=this.calcElementsFromUV(e.detail.intersection.uv,t.clickSelectors,t.debug);const n={...e.detail.intersection,svg:this.calcViewXYFomUV(e.detail.intersection.uv)};i&&i.length>0&&this.sendEvent("svg-ui-click",{uiTarget:i[0],intersection:n})}}}),AFRAME.registerComponent("texture-updater",{schema:{maps:{default:"map"},meshName:{default:"mesh"}},update(){this.maps=this.data.maps.split(",").map(e=>e.trim())},tick(){const e=this.el.getObject3D(this.data.meshName);if(e&&e.material)for(let t of this.maps)if(Array.isArray(e.material))for(let i of e.material)i[t]&&"object"==typeof i[t]&&(i[t].needsUpdate=!0);else e.material[t]&&"object"==typeof e.material[t]&&(e.material[t].needsUpdate=!0)}}),AFRAME.registerComponent("timer-emit",{schema:{src:{type:"selector"},target:{default:""},targetScope:{default:"document",oneOf:["document","self","parent"]},stopOnPause:{default:!0}},multiple:!0,init(){this.sendEvents=this.sendEvents.bind(this),this.mediaEl=void 0,this.restartMedia=!1,this.clockStartTime=Date.now(),this.targets=[]},remove(){this.removeListeners()},updateSchema(e){"object"!=typeof e&&console.error(`invalid properties, expected format <property>:<value>; '${e}'`);const t=AFRAME.components["timer-emit"].schema;let i={};for(let n in e)n in t||(i[n]={type:"string"});Object.keys(i).length>0&&this.extendSchema(i)},pause(){const e=this.data;this.removeListeners(),e.stopOnPause&&(this.pauseTime=Date.now(),clearTimeout(this.sendEventsTimer),this.sendEventsTimer=void 0,this.mediaEl&&!this.mediaEl.paused&&(this.mediaEl.pause(),this.restartMedia=!0))},play(){this.pauseTime&&(this.clockStartTime+=Date.now()-this.pauseTime,delete this.pauseTime),this.mediaEl&&(this.addListeners(),this.restartMedia&&(this.mediaEl.play(),this.restartMedia=!1)),this.sendEvents()},update(e){const t=this.data,i=AFRAME.components["timer-emit"].schema;e.src!==t.src&&(this.removeListeners(),this.mediaEl=t.src instanceof HTMLMediaElement?t.src:void 0),e.target!==t.target&&(this.targets=this.querySelectorAll(t.targetScope,t.target)),this.events=[];for(let e in t)if(!(e in i)){let i=t[e].split(",").map(e=>Number(e));for(let t of i)isNaN(t)||this.events.push([t,e])}this.events.sort((e,t)=>e[0]-t[0]),this.lastSendEventsTime=-1},querySelectorAll(e,t){if(""==t)return[this.el];switch(e){case"self":return this.el.querySelectorAll(t)||[this.el];case"parent":return this.el.parentNode.querySelectorAll(t)||[this.el];case"document":default:return document.querySelectorAll(t)||[this.el]}},addListeners(){this.mediaEl&&this.mediaEl.addEventListener("play",this.sendEvents)},removeListeners(){this.mediaEl&&this.mediaEl.removeEventListener("play",this.sendEvents)},sendEvents(){if(this.mediaEl&&this.mediaEl.paused)return;let e,t=this.mediaEl?this.mediaEl.currentTime:(Date.now()-this.clockStartTime)/1e3,i=[];for(let n of this.events)if(!(n[0]<=this.lastSendEventsTime)){if(!(n[0]<=t)){e=n[0];break}i.push(n[1])}if(i.length>0){const e=this.el;for(let t of this.targets){const n={source:e,target:t};for(let e of i)t.emit(e,n)}}this.lastSendEventsTime=t,e&&(this.sendEventsTimer=setTimeout(this.sendEvents,1e3*(e-t)))}});THREE.Math.radToDeg;const Oi=THREE.Math.degToRad;function Li(e){return e.toLowerCase()}AFRAME.registerComponent("tool",{dependencies:["position","rotation","scale"],schema:{debug:{default:!1},handPosition:{type:"vec3"},handRotation:{type:"vec3"},handScale:{type:"vec3",default:{x:1,y:1,z:1}},maxHands:{default:1},usage:{default:"stayondrop",oneOf:["respawnOnDrop","stayOnDrop"],parse:e=>"string"==typeof e?e.toLowerCase():e}},init(){this.hands=[],this.onGrabStart=this.onGrabStart.bind(this),this.onGrabEnd=this.onGrabEnd.bind(this),this.offsetMatrix=new THREE.Matrix4,this.objectMatrixOnEquip=new THREE.Matrix4,this.originalScale=new THREE.Vector3,this.invRotationMatrix=new THREE.Matrix4,this.el.sceneEl.systems["grab-system"].registerTarget(this.el)},play(){this.el.addEventListener("grabstart",this.onGrabStart),this.el.addEventListener("grabend",this.onGrabEnd)},pause(){this.el.removeEventListener("grabstart",this.onGrabStart),this.el.removeEventListener("grabend",this.onGrabEnd)},update(e){const t=this.data;if(e.handRotation!==t.handRotation||e.handPosition!==t.handPosition||e.handScale!==t.handScale){const e=(new THREE.Euler).set(Oi(t.handRotation.x),Oi(t.handRotation.y),Oi(t.handRotation.z),"YXZ"),i=(new THREE.Quaternion).setFromEuler(e);this.offsetMatrix.compose(t.handPosition,i,t.handScale),this.invRotationMatrix.makeRotationFromQuaternion(i),this.invRotationMatrix.getInverse(this.invRotationMatrix)}},tick:function(){const e=new THREE.Matrix4,t=new THREE.Matrix4,i=new THREE.Vector3(0,0,1),n=new THREE.Vector3,a=new THREE.Vector3,s=new THREE.Vector3,r=new THREE.Quaternion,o=new THREE.Matrix4;return function(){if(0===this.hands.length)return void this.el.sceneEl.removeBehavior(this);const l=this.el.object3D,c=this.hands[0].object3D;if(c.updateMatrixWorld(!0),l.parent.updateMatrixWorld(!0),t.getInverse(l.parent.matrixWorld),this.hands.length>1){const l=this.hands[1].object3D;l.updateMatrixWorld(!0),l.getWorldPosition(a),c.getWorldPosition(s),n.subVectors(s,a).normalize(),i.set(0,0,1),r.setFromUnitVectors(i,n),o.makeRotationFromQuaternion(r),o.multiply(this.invRotationMatrix),o.setPosition(s),e.copy(this.offsetMatrix).premultiply(o).premultiply(t)}else e.copy(this.offsetMatrix).premultiply(c.matrixWorld).premultiply(t);e.decompose(l.position,l.quaternion,l.scale),l.scale.multiply(this.originalScale)}}(),onGrabStart(e){const t=new THREE.Vector3,i=new THREE.Quaternion,n=this.data;this.hands.length=Math.min(n.maxHands-1,this.hands.length),this.hands.push(e.detail.hand),this.objectMatrixOnEquip.copy(this.el.object3D.matrix),this.el.object3D.matrix.decompose(t,i,this.originalScale),this.el.sceneEl.addBehavior(this)},onGrabEnd(e){const t=this.data,i=this.el.object3D,n=this.hands.indexOf(e.detail.hand);-1!==n&&(this.hands.splice(n,1),0===this.hands.length&&"respawnondrop"===t.usage&&this.objectMatrixOnEquip.decompose(i.position,i.quaternion,i.scale))}}),AFRAME.registerComponent("toy",{schema:{routeEvents:{default:"controllerconnected, controllerdisconnected, gripdown, gripup, gripchanged, trackpaddown, trackpadup, triggerdown, triggerup"},debug:{default:!1}},init(){this.invGrabMatrix=new THREE.Matrix4,this.grabHand=void 0,this.routeEvents=[],this.onGrabStart=this.onGrabStart.bind(this),this.onGrabEnd=this.onGrabEnd.bind(this),this.onRouteEvent=this.onRouteEvent.bind(this),this.el.sceneEl.systems["grab-system"].registerTarget(this.el)},play(){this.el.addEventListener("grabstart",this.onGrabStart),this.el.addEventListener("grabend",this.onGrabEnd),this.addRouteListeners()},pause(){this.removeRouteListeners(),this.el.removeEventListener("grabend",this.onGrabEnd),this.el.removeEventListener("grabstart",this.onGrabStart)},update(e){const t=this.data;e.routeEvents!==t.routeEvents&&(this.routeEvents=t.routeEvents.split(",").map(e=>e.trim()))},tick(){this.grabHand?this.stickToHand():this.el.sceneEl.removeBehavior(this)},stickToHand:function(){const e=new THREE.Matrix4,t=new THREE.Matrix4;return function(){const i=this.grabHand.object3D,n=this.el.object3D;e.getInverse(n.parent.matrixWorld),t.multiplyMatrices(i.matrixWorld,this.invGrabMatrix),t.premultiply(e),t.decompose(n.position,n.quaternion,n.scale)}}(),sendEvent(e,t,i){this.data.debug&&ae(this,`send '${t}' to '${Z(e)}'`),e.emit(t,i)},addRouteListeners(){if(this.grabHand)for(let e of this.routeEvents)this.grabHand.addEventListener(e,this.onRouteEvent)},removeRouteListeners(){if(this.grabHand)for(let e of this.routeEvents)this.grabHand.removeEventListener(e,this.onRouteEvent)},onGrabStart(e){this.data.debug&&ae(this,`${e.type}`),this.removeRouteListeners(),this.grabHand=e.detail.hand;const t=this.grabHand.object3D,i=this.el.object3D;this.invGrabMatrix.getInverse(t.matrixWorld).multiply(i.matrixWorld),this.addRouteListeners(),this.el.sceneEl.addBehavior(this)},onGrabEnd(e){this.data.debug&&ae(this,`${e.type}`),this.grabHand===e.detail.hand&&(this.removeRouteListeners(),this.grabHand=void 0)},onRouteEvent(e){this.sendEvent(this.el,e.type,{...e.detail,hand:this.grabHand})}}),AFRAME.registerComponent("trigger-zone",{schema:{triggerSelectors:{default:""},watch:{default:!1},debug:{default:!1},tickMS:{default:100},bubbles:{default:!1},enabled:{default:!0},test:{default:"overlap",oneOf:["overlap","within"]}},multiple:!0,init(){this.firstTime=!0,this.debugShape=void 0,this.overlapping=[],this.triggerElements=[],this.observer=void 0,this.onSceneLoaded=this.onSceneLoaded.bind(this),this.onSceneChanged=this.onSceneChanged.bind(this),this.el.sceneEl.addEventListener("loaded",this.onSceneLoaded)},remove(){this.el.sceneEl.removeEventListener("loaded",this.onSceneLoaded),this.observer&&(this.observer.disconnect(),this.observer=void 0),this.hideDebugShape()},update(e){const t=this.data;this.firstTime||e.triggerSelectors===t.triggerSelectors||this.gatherElements(),this.firstTime||e.watch===t.watch&&e.enabled===t.enabled||this.setupWatch(),e.tickMS!==t.tickMS&&(this.tick=AFRAME.utils.throttleTick(this.tick,t.tickMS,this)),e.debug===t.debug&&e.enabled===t.enabled||this.showDebugShape(),this.firstTime=!1},tick(){this.triggerElements.length>0&&this.data.enabled&&this.checkForEnterLeave()},gatherElements(){const e=this.data;this.triggerElements=e.triggerSelectors?Array.from(document.querySelectorAll(e.triggerSelectors)):[],e.debug&&console.log(`gathering ${this.triggerElements.length} elements`),0===this.triggerElements.length&&se(`no trigger elements using '${e.triggerSelectors}' for trigger-zone`)},checkForEnterLeave(){const e=this.findOverlapping(this.triggerElements,"cyan");for(let t of this.overlapping)e.includes(t)||this.sendTwoEvents("trigger-zone-leave",t);for(let t of e)this.overlapping.includes(t)||this.sendTwoEvents("trigger-zone-enter",t);this.overlapping=e},findOverlapping:function(){const e=new THREE.Vector3,t=new THREE.Vector3,i=new THREE.Vector3,n=new THREE.Vector3(-.5,-.5,-.5),a=new THREE.Vector3(.5,.5,.5);return function(s,r){let o=[];const l=this.el.object3D;l.updateMatrixWorld(!0),l.getWorldPosition(t),l.getWorldScale(i).multiplyScalar(.5);const c=Math.hypot(i.x,i.y,i.z);for(let i of s){if(!i.isEntity||!i.object3D)continue;let s=i.object3D;if(s.boundingSphere&&s.boundingBox&&!s.boundingBox.isEmpty()||Be(s,r),s.boundingBox.isEmpty())continue;e.copy(s.boundingSphere.center).applyMatrix4(s.matrixWorld);const d=s.boundingSphere.radius*Math.max(s.scale.x,s.scale.y,s.scale.z);if(t.distanceTo(e)>d+c)continue;let h=!1;(h="overlap"===this.data.test?Pe(s.boundingBox.min,s.boundingBox.max,s.matrixWorld.elements,n,a,l.matrixWorld.elements):He(s.boundingBox.min,s.boundingBox.max,s.matrixWorld.elements,n,a,l.matrixWorld.elements))&&o.push(i)}return o}}(),sendTwoEvents(e,t){this.data.debug&&console.log(e,Z(this.el),Z(t));const i=this.data.bubbles;this.el.emit(e,{zoneTarget:t,zoneSource:this.el},i),t.emit(e,{zoneTarget:t,zoneSource:this.el},i)},setupWatch(){this.data.watch&&this.data.enabled?(this.observer=this.observer?this.observer:new MutationObserver(this.onSceneChanged),this.observer.observe(this.el.sceneEl,{childList:!0,subtree:!0})):this.observer&&this.observer.disconnect()},showDebugShape(){this.hideDebugShape();const e=new THREE.BoxBufferGeometry,t=new THREE.WireframeGeometry(e);this.debugShape=new THREE.LineSegments(t,new THREE.LineBasicMaterial({color:this.data.enabled?"blue":"grey"})),this.el.object3D.add(this.debugShape)},hideDebugShape(){this.debugShape&&(this.el.object3D.remove(this.debugShape),this.debugShape=void 0)},onSceneLoaded(e){this.gatherElements(),this.setupWatch()},onSceneChanged(e){!function(e,t,i){for(let n of t){for(let t of n.addedNodes)t.matches(i)&&e.push(t);for(let t of n.removedNodes)t.matches(i)&&e.splice(e.indexOf(t),1)}}(this.triggerElements,e,this.data.triggerSelectors)}});const Di={repeat:THREE.RepeatWrapping,clamptoedge:THREE.ClampToEdgeWrapping,mirroredrepeat:THREE.MirroredRepeatWrapping};AFRAME.registerComponent("uv-transform",{schema:{offset:{type:"vec2"},repeat:{type:"vec2",default:{x:1,y:1}},rotate:{type:"number"},pivot:{type:"vec2",default:{x:.5,y:.5}},meshName:{default:"mesh"},wrapS:{default:"repeat",oneOf:["repeat","clampToEdge","mirroredRepeat"],parse:Li},wrapT:{default:"repeat",oneOf:["repeat","clampToEdge","mirroredRepeat"],parse:Li},maps:{type:"string",default:"map"},textureFrame:{type:"vec2",default:{x:1,y:1}},frame:{default:0}},multiple:!0,init(){this.onObject3DSet=this.onObject3DSet.bind(this),this.onMaterialTextureLoaded=this.onMaterialTextureLoaded.bind(this),this.el.addEventListener("object3dset",this.onObject3DSet),this.el.addEventListener("materialtextureloaded",this.onMaterialTextureLoaded)},remove(){this.el.removeEventListener("materialtextureloaded",this.onMaterialTextureLoaded),this.el.removeEventListener("object3dset",this.onObject3DSet)},update(e){const t=this.data;e.rotate!==t.rotate&&(this.rotate=THREE.Math.degToRad(t.rotate)),e.wrapS===t.wrapS&&e.wrapT===t.wrapT||(this.wrapS=Di[t.wrapS]||THREE.RepeatWrapping,this.wrapT=Di[t.wrapT]||THREE.RepeatWrapping),e.maps!==t.maps&&(this.maps=t.maps.split(",").map(e=>e.trim()),this.cloneMaps()),this.updateUVs()},onObject3DSet(e){e.target===this.el&&e.detail.type===this.data.meshName&&(this.cloneMaps(),this.updateUVs())},onMaterialTextureLoaded(e){e.target===this.el&&(this.cloneMaps(),this.updateUVs())},updateUVs(){const e=this.data,t=e.repeat,i=this.rotate,n=e.pivot,a=this.wrapS,s=this.wrapT,r=e.textureFrame,o=Math.trunc(e.frame),l=o%r.x/r.x,c=1-Math.floor(o/r.x)/r.y,d=e.offset.x+l-n.x+n.x/r.x,h=e.offset.y+c-n.y-(1-n.y)/r.y;const u=this.el.getObject3D(this.data.meshName);if(u&&u.material)for(let e of this.maps)(e=u.material[e])&&(e.wrapS=a,e.wrapT=s,e.offset.set(d,h),e.repeat.copy(t).divide(r),e.center.copy(n),e.rotation=i);var m},cloneMaps(){const e=this.el.getObject3D(this.data.meshName);if(e&&e.material&&this.maps)for(let t of this.maps){const i=e.material[t];i&&(e.material[t]=i.clone(),e.material[t].needsUpdate=!0)}}});function Fi(e){let t=function(e){let t={type:"",id:"",classes:[],attrs:{}},i="type",n=0,a="";function s(s,r){let o=e.slice(n,r);if(r>n)switch(i){case"type":t.type=o;break;case"id":t.id=o;break;case"class":t.classes.push(o);break;case"attr":a=o;break;case"value":a&&(t.attrs[a]=o)}i=s,n=r+1}for(let t=0,n=e.length;t<n;t++)switch(e[t]){case"\\":t++;break;case"#":"attr"!==i&&"value"!==i&&s("id",t);break;case".":"attr"!==i&&"value"!==i&&s("class",t);break;case"[":"attr"!==i&&"value"!==i&&s("attr",t);break;case"]":"attr"!==i&&"value"!==i||s("none",t);break;case"=":"attr"===i&&s("value",t)}return s("end",e.length),t}(e),i=t.type||"a-entity",n=document.createElement(i);if(n){t.id&&(n.id=t.id),t.classes.length>0&&n.classList.add(...t.classes);for(let e in t.attrs)AFRAME.utils.entity.setComponentProperty(n,e,ki(t.attrs[e]))}return n}function ki(e){const t="'"===(e=e.trim())[0]||'"'===e[0]?1:0,i=e.length;let n="'"===e[i-1]||'"'===e[i-1]?i-1:i;return 0===t&&n===i?e:e.slice(t,n)}function Pi(e,t,i){return e.replace(/\$([\.\w]+)/g,(e,n)=>(function(e,t,i){let n=e;0===e.indexOf("event")?i?n=q(x(i,e.slice(6).split("."))):console.log("value of $event but no event received"):n=q(J(t,e.slice(1)));return n})(n,t,i))}AFRAME.registerComponent("vertex-color",{schema:{color:{type:"color"},verts:{type:"array",parse:function(e){return"string"==typeof e?e.split(",").map(e=>parseInt(e,10)):e}},minPosition:{type:"vec3",default:{x:-1e10,y:-1e10,z:-1e10}},maxPosition:{type:"vec3",default:{x:1e10,y:1e10,z:1e10}},minSlope:{type:"int",default:0},maxSlope:{type:"int",default:90},meshName:{default:"mesh"}},multiple:!0,init(){this.onObject3DSet=this.onObject3DSet.bind(this),this.el.addEventListener("object3dset",this.onObject3DSet),this.isFirstFrame=!0},remove(){this.el.removeEventListener("object3dset",this.onObject3DSet)},update(){if(this.isFirstFrame)this.applyVertexColors(),this.isFirstFrame=!1;else{const e=this.el.components;for(let t in e)0===t.indexOf("vertex-color")&&e[t].applyVertexColors()}},onObject3DSet(e){e.target===this.el&&e.detail.type===this.data.meshName&&this.applyVertexColors()},applyVertexColors(){const e=this.data,t=this.el.getObject3D(e.meshName);if(t){const i=t.geometry,n=t.material,a=t.material.color;if(n.vertexColors=THREE.VertexColors,a.r<.3&&a.g<.3&&a.b<.3&&se("material color is very dark, vertex-color will also be dark"),console.assert(i.isBufferGeometry,"vertex-color only supports buffer geometry"),!i.getAttribute("color")){const e=new Float32Array(3*i.getAttribute("position").count).fill(1);i.addAttribute("color",new THREE.Float32BufferAttribute(e,3))}const s=i.getAttribute("position"),r=i.getAttribute("normal"),o=i.getAttribute("color"),l=e.minPosition.x-.5,c=e.minPosition.y,d=e.minPosition.z-.5,h=e.maxPosition.x-.5,u=e.maxPosition.y,m=e.maxPosition.z-.5,p=new THREE.Color(e.color),f=1e-5,g=THREE.Math.degToRad,v=Math.cos(g(Math.max(0,e.minSlope)))+f,y=Math.cos(g(Math.max(0,e.maxSlope)))-f;for(let t=0,i=o.count;t<i;t++){if(e.verts.length>0&&!e.verts.includes(t))continue;const i=s.getX(t),n=s.getY(t),a=s.getZ(t);if(i<l||i>h||n<c||n>u||a<d||a>m)continue;const f=Math.abs(r.getY(t));f<y||f>v||o.setXYZ(t,p.r,p.g,p.b)}o.needsUpdate=!0}}}),AFRAME.registerComponent("wait-add-remove",{schema:{delay:{default:"0"},events:{default:""},source:{default:""},sourceScope:{default:"document",oneOf:["parent","self","document"]},add:{type:"array"},addRepeat:{type:"int",default:1},remove:{type:"array"}},multiple:!0,init(){this.addRemoveEntities=this.addRemoveEntities.bind(this),this.onEvent=this.onEvent.bind(this),this.delayClock=ee(),this.eventListener=ie(this.el,this.onEvent)},remove(){this.delayClock.clearAllTimers(),this.eventListener.remove()},update(e){const t=this.data;e.events===t.events&&e.source===t.source&&e.sourceScope===t.sourceScope||this.eventListener.set(t.events,t.source,t.sourceScope),e.delay!==t.delay&&(this.delay=S(t.delay),""===t.events&&this.delayClock.startTimer(N(this.delay),this.addRemoveEntities))},pause(){this.delayClock.pause(),this.eventListener.remove()},play(){this.eventListener.add(),this.delayClock.resume()},onEvent(){this.data;this.delayClock.startTimer(N(this.delay),this.addRemoveEntities)},addRemoveEntities(){const e=this.data;for(let t of e.remove){this.el.querySelectorAll(t).forEach(e=>this.el.removeChild(e))}for(let t=0;t<e.addRepeat;++t)for(let t of e.add){let e=Fi(t);e&&this.el.appendChild(e)}}}),AFRAME.registerComponent("wait-emit",{schema:{events:{default:""},delay:{default:"0"},source:{default:""},sourceScope:{default:"document",oneOf:["parent","self","document"]},out:{default:""},target:{default:""},targetScope:{default:"document",oneOf:["parent","self","document","event"]},bubbles:{default:!1},debug:{default:!1}},multiple:!0,init(){this.onEvent=this.onEvent.bind(this),this.sendEvent=this.sendEvent.bind(this),this.sources=[],this.delayClock=ee(),this.eventListener=ie(this.el,this.onEvent)},remove(){this.eventListener.remove(),this.delayClock.clearAllTimeouts()},update(e){const t=this.data;t.events===e.events&&t.source===e.source&&t.sourceScope===e.sourceScope||this.eventListener.set(t.events,t.source,t.sourceScope),t.delay!==e.delay&&(this.delay=S(t.delay),""===t.events&&this.delayClock.startTimer(N(t.delay),this.sendEvent))},pause(){this.eventListener.remove(),this.delayClock.pause()},play(){this.eventListener.add(),this.delayClock.resume()},sendEvent(e){const t=this.data,i=te(this.el,t.target,t.targetScope,e?e.target:void 0),n=Object.assign(e,{source:this.el}),a=t.out?t.out:t.event,s=this.data.bubbles;for(let e of i)this.data.debug&&console.log(Z(e),this.attrName,"send",a,n,s),e.emit(a,n,s)},onEvent(e){this.data.debug&&console.log(Z(this.el),this.attrName,"onEvent",e.type);const t=this;this.delayClock.startTimer(N(this.delay),()=>t.sendEvent(e))}}),AFRAME.registerComponent("wait-set",{schema:{delay:{default:"0"},events:{default:""},source:{default:""},sourceScope:{default:"document",oneOf:["parent","self","document"]},target:{default:""},targetScope:{default:"document",oneOf:["parent","self","document","event"]},toggles:{default:""},seed:{type:"int",default:-1},debug:{default:!1}},multiple:!0,init(){this.onEvent=this.onEvent.bind(this),this.setProperties=this.setProperties.bind(this),this.rules={},this.toggles=[],this.eventListener=ie(this.el,this.onEvent),this.delayClock=ee(),this.lcg=p()},remove(){this.eventListener.remove(),this.delayClock.clearAllTimers()},updateSchema(e){"object"!=typeof e&&console.error(`invalid properties, expected format <property>:<value>; '${e}'`);const t=AFRAME.components[this.name].schema;let i={};for(let n in e)n in t||(i[n]={default:""});Object.keys(i).length>0&&this.extendSchema(i)},update(e){const t=AFRAME.components[this.name].schema,i=this.data;i.seed!==e.seed&&this.lcg.setSeed(i.seed);for(let e in this.rules)e in i||delete this.rules[e];for(let n in i)n in t||i[n]===e[n]||(this.rules[n]=S(i[n]));i.events===e.events&&i.source===e.source&&i.sourceScope===e.sourceScope||this.eventListener.set(i.events,i.source,i.sourceScope),i.toggles!==e.toggles&&(this.toggles=i.toggles.split(",").map(e=>e.trim()).filter(e=>e)),i.delay!==e.delay&&(this.delay=S(i.delay),""===i.events&&this.delayClock.startTimer(N(this.delay),this.setProperties))},pause(){this.eventListener.remove(),this.delayClock.pause()},play(){this.delayClock.resume(),this.eventListener.add()},setProperties(e){const t=Pi(this.data.target,this.el,e),i=te(this.el,t,this.data.targetScope,e?e.target:void 0);this.data.debug&&console.log(Z(this.el),this.attrName,"setProperties","target=",t);for(let t of i){for(let i in this.rules){const n=q(N(this.rules[i],this.lcg.random)),a=Pi(n,this.el,e);this.data.debug&&console.log(Z(this.el),this.attrName,"setProperties","element=",Z(t),"property=",i,"value=",n,"$event=",e),K(t,i,a)}for(let e of this.toggles){const i=!J(t,e);K(t,e,i)}}},onEvent(e){this.data.debug&&console.log(Z(this.el),this.attrName,"onEvent",e.type,e);const t=this;this.delayClock.startTimer(N(this.delay),()=>t.setProperties(e))}})});